[
["index.html", "R Basic Manual 머리말", " R Basic Manual Manboha 2020-07-10 머리말 이 책은 R을 공부하기 위한 기초 매뉴얼입니다. "],
["설치.html", "1 R 설치 ", " 1 R 설치 "],
["r이란.html", "1.1 R이란?", " 1.1 R이란? R은 오픈소스 프로그램으로 다양한 통계분석, 데이터 마이닝, 그래프 작성 등을 위한 프로그래밍 언어입니다. 기존의 통계분석용 프로그램 중 대표적인 것으로 SAS, SPSS 등이 있고, 보조적인 프로그램으로 Excel 등을 들 수 있습니다. 비용이나 다양성 등을 고려하였을 때 R이 가장 우수하다고 볼 수 있습니다. 현재 많은 대학들이 R을 기반으로 데이터 분석 및 통계분석 수업을 진행하고 있습니다. R의 장점은 다음과 같습니다. R은 오픈소스로서 무료입니다. 프로그래밍 언어로서 사용자의 실력에 따라 매우 복잡한 분석도 쉽게 자동화하여 수행할 수 있습니다. 다양한 최신 통계분석 기법, 데이터 마이닝 기법, 그래프 작성 기법 등이 사용자들에 의해 제공됩니다. 전 세계적으로 사용자들이 다양한 예제를 공유합니다.(영문 예제 다수) "],
["r-설치.html", "1.2 R 설치", " 1.2 R 설치 R을 다운받기 위해 웹브라우저로 www.r-project.org 에 접속합니다.(또는 구글에서 R로 검색) 화면에서 [download R]을 클릭합니다. 서버 목록 중 Korea를 찾으시고 그 중에서 하나를 클릭합니다. 윈도우 버전을 설치할 경우 [Download R for Windows]를 클릭합니다. [base]를 클릭합니다. [Download R 3.x.x for Windows]를 클릭하여 PC에 다운로드 받습니다. 다운받은 파일을 실행시켜 프로그램을 설치합니다. (계속 [다음]을 눌러 설치 진행) R 설치가 끝난 후 바탕화면에 생성된 아이콘을 더블 클릭하면 R이 실행됩니다. R이 시작되면 R Console이라는 창이 열리고, 그 창에 &gt; 가 나타나는 데 R의 프롬프트입니다. “&gt;” 기호 다음에 필요한 명령문을 입력하고 Enter 키를 치면 입력된 명령문이 실행됩니다. 명령문이 실행되면 그 실행결과가 바로 다음 줄에 출력됩니다. 32*27 #&gt; [1] 864 "],
["r의-특징.html", "1.3 R의 특징", " 1.3 R의 특징 R은 명령어를 1줄씩 처리하고 그 결과를 바로 보여주는 인터프리터 언어입니다. R의 콘솔창에 &gt; 기호(greater than sign, 부등호 기호)는 명령 프롬프트입니다. &gt; 뒤에 원하는 명령어를 입력하고 Enter를 치면 명령어가 실행됩니다. R은 대소문자를 구별합니다. 명령어를 입력할 때 대소문자를 명확히 파악하고 입력하여야 합니다. R 콘솔창에서 키보드의 상향(↑)를 누르면 이전에 실행했던 명령어를 순서대로 다시 불러올 수 있습니다. #은 주석 기호(메모 유사)입니다. 즉 맨 앞에 #이 있으면 그 줄은 실행하지 않습니다. 명령어를 입력할 때 오타가 많이 나고, 긴 명령어를 입력하거나 명령어를 재사용할 때는 R 콘솔창이 불편합니다. 따라서 주로 R스튜디오의 스크립트 창에서 명령어를 입력하고 [Ctrl + Enter]를 눌러 콘솔 창에 보내 명령어를 실행합니다. "],
["rstudio-설치.html", "1.4 RStudio 설치", " 1.4 RStudio 설치 R스튜디오을 다운받기 위해 웹브라우저로 www.rstudio.com 에 접속합니다. 상단 메뉴 [Product] → [RStudio]를 클릭합니다. [DOWNLOAD RSTUDIO DESKTOP]을 클릭한 후 [RStudio x.x.x - Windows Vista/7/8/10]를 클릭하여 PC에 다운로드 받습니다. 다운받은 파일을 실행시켜 프로그램을 설치합니다. 계속해서 [다음]을 눌러 설치를 진행하면 됩니다. R스튜디오 아이콘이 바탕화면에 없으면 다음과 같이 하여 아이콘을 바탕하면 만듭니다. [시작] → [모든 프로그램] → [Rstudio] → [Rstudio]를 마우스 오른쪽 단추로 클릭한 후 [보내기] → [바탕화면에 바로가기 만들기]를 클릭하여 바탕화면에 R스튜디오 아이콘을 만듭니다. 바탕화면의 R스튜디오 아이콘을 더블클릭하여 실행시킵니다. R스튜디오를 실행한 후 [File] → [New File] → [RScript]를 클릭하면 스크립트 창이 생성되면서, 총 4개의 창이 화면에 보입니다. 스크립트 창, 콘솔 창, 워크스페이스 창, 파일 등을 볼 수 있는 창입니다. 스크립트 창 : R 명령어를 입력하는 창입니다. 명령어에 커서를 두거나 명령어들을 선택하고 [Ctrl + Enter]를 누르면 콘솔 창에서 명령어가 실행됩니다. 스크립트 창의 장점은 명령어를 저장하고 불러올 수 있다는 점입니다. 콘솔 창 : 명령어가 실행되고 그 결과를 보여주는 창입니다. R의 콘솔 창과 거의 동일합니다. 워크스페이스 창 : 작업 중에 할당된 변수와 데이터를 보여주는 창입니다. 마지막 창은 파일, 그래프, 패키지, 도움말 등을 볼 수 있는 창입니다. 스크립트 창에서 32*79 라고 입력하고 [Ctrl + Enter]를 누르면 아래 콘솔 창에서 명령어가 실행되고, 그 결과 값인 2528이 출력되는 것을 볼 수 있습니다. 1.4.1 RStudio에서 프로젝트 만들기 RStudio에서 프로젝트를 만들면 하나의 폴더에서 코드와 데이터들을 체계적으로 관리할 수 있어 편리합니다. 새 프로젝트를 만드는 절차는 다음과 같습니다. (프로젝트 만들기) 메뉴 [File] → [New Project] 클릭 → [New Directory] → [New Project] → [Directory name]에 프로젝트이름 입력(예, rbasic) → 그 아래에 폴더 위치 지정(예, 바탕화면) → [Create Project] 클릭 (스크립트 파일 만들기) 메뉴 [File] → [New File] → [R Script]클릭 (스크립트에서 명령어 실행) 스크립트 창에서 32*27 을 입력하고 [Ctrl + Enter] 입력 (스크립트 저장) 메뉴 [File] → [save] → rbasic1.R 로 저장 프로젝트 이름으로 만들어진 폴더에 스크립트 파일들이 저장됩니다. 이 폴더에 데이터를 넣어두면 R에서 데이터를 불러올 때 편리합니다. 일종의 작업 디렉터리입니다. "],
["r-package-설치-및-사용.html", "1.5 R package 설치 및 사용", " 1.5 R package 설치 및 사용 R 패키지는 목적에 맞게 R 함수, 데이터 등을 모아 놓은 것입니다. 현재 수천 개의 패키지가 존재합니다. 이 중에서 유용하고 중요한 패키지들을 골라내어 사용법을 익히는 것이 필요합니다. 패키지는 기본적으로 CRAN에 등록되어 있는 것을 다운 받아 설치합니다. 패키지를 설치하고 사용하는 방법은 다음 절차를 따릅니다. 패키지 설치하기 install.packages(“패키지명”) 패키지 로드하기 library(패키지명) 함수 사용하기 install.packages(&quot;ggplot2&quot;) # ggplot2 패키지 설치 library(ggplot2) # ggplot2 패키지 로드 x &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;) qplot(x) # ggplot2에 있는 함수 qplot 사용하기 (빈도 막대그래프 출력) 2개 이상의 패키지를 한번의 명령으로 설치할 수도 있습니다. install.packages(c(&quot;rpart&quot;, &quot;survival&quot;)) CRAN이 아닌 Github로 부터 패키지를 다운 받아 설치하고자 한다면 devtools 패키지가 먼저 설치되어 있어야 합니다. install.packages(&quot;devtools&quot;) devtools::install_github(&quot;kassambara/survminer&quot;) RStudio에서는 패키지 창에서 Install 버튼을 눌러 패키지를 설치 할 수 있습니다. "],
["r-package-관리.html", "1.6 R package 관리", " 1.6 R package 관리 1.6.1 설치된 패키지 보기 installed.packages() RStudio에서는 패키지 창에서 설치된 패키지들을 확인할 수 있습니다. 1.6.2 패키지가 설치된 폴더 보기 .libPaths() 1.6.3 로드된 패키지 보기 search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:ggplot2&quot; &quot;package:stats&quot; #&gt; [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; #&gt; [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; #&gt; [10] &quot;package:base&quot; 1.6.4 패키지 언로드 하기 (메모리에서 내리기) detach(package:ggplot2, unload = TRUE) 1.6.5 설치된 패키지 제거하기 remove.packages(&quot;rpart&quot;) 1.6.6 패키지 업데이트하기 # 모든 패키지 업데이트 update.packages() # 특정 패키지 업데이트 update.packages(oldPkgs = c(&quot;readr&quot;, &quot;ggplot2&quot;)) "],
["프로그래밍.html", "2 R 프로그래밍 기초 ", " 2 R 프로그래밍 기초 "],
["기초-산술-연산자.html", "2.1 기초 산술 연산자", " 2.1 기초 산술 연산자 2.1.1 계산용 연산자 +(더하기), -(빼기), *(곱하기), /(나누기), ^(자승), %%(나머지), %/%(몫) 1 + 2 + (7 - 3) #&gt; [1] 7 6 / 3 * (5 + 7) #&gt; [1] 24 5^2 #&gt; [1] 25 5 %% 2 #&gt; [1] 1 5 %/% 2 #&gt; [1] 2 2.1.2 화씨온도가 100도라면 섭씨온도는? # 섭씨온도 = (5/9) * (화씨온도-32) (5 / 9) * (100 - 32) #&gt; [1] 37.8 "],
["논리-연산자.html", "2.2 논리 연산자", " 2.2 논리 연산자 5 == 5 #&gt; [1] TRUE 5 != 5 #&gt; [1] FALSE 5 &gt; 5 #&gt; [1] FALSE 5 &gt;= 5 #&gt; [1] TRUE 3 &lt; 5 #&gt; [1] TRUE 6 &lt;= 5 #&gt; [1] FALSE !TRUE # Not x #&gt; [1] FALSE TRUE | FALSE # x OR y #&gt; [1] TRUE TRUE &amp; FALSE # x AND y #&gt; [1] FALSE isTRUE(TRUE) # if x is TRUE #&gt; [1] TRUE "],
["기초-산술-함수.html", "2.3 기초 산술 함수", " 2.3 기초 산술 함수 2.3.1 통계 함수 sum(c(2, 5, 6)) # 합계 #&gt; [1] 13 mean(c(2, 5, 6)) # 평균 #&gt; [1] 4.33 sd(c(2, 5, 6)) # 표준편차 #&gt; [1] 2.08 var(c(2, 5, 6)) # 분산 #&gt; [1] 4.33 median(c(2, 5, 6)) # 중위수 #&gt; [1] 5 max(c(1, 3, 5, 7)) # 최대값 #&gt; [1] 7 min(c(1, 3, 5, 7)) # 최소값 #&gt; [1] 1 IQR(c(1, 3, 5, 7)) # 사분위 범위 #&gt; [1] 3 quantile(c(1, 3, 5, 7), 0.25) # 백분위 수 #&gt; 25% #&gt; 2.5 range(c(1, 3, 5, 7)) # 최대값과 최소값 #&gt; [1] 1 7 2.3.2 로그 및 지수 함수 (Logarithms and Exponentials) log(10) # 자연로그 logarithms base e of x, e=2.7182818284⋯ #&gt; [1] 2.3 log2(10) # 이진로그 logarithms base 2 of x #&gt; [1] 3.32 log10(10) # 상용로그 logaritms base 10 of x #&gt; [1] 1 exp(10) # 지수 Exponential of x #&gt; [1] 22026 2.3.3 삼각 함수 x &lt;- 1 cos(x) # Cosine of x #&gt; [1] 0.54 sin(x) # Sine of x #&gt; [1] 0.841 tan(x) #Tangent of x #&gt; [1] 1.56 acos(x) # arc-cosine of x #&gt; [1] 0 asin(x) # arc-sine of x #&gt; [1] 1.57 atan(x) #arc-tangent of x #&gt; [1] 0.785 2.3.4 기타 수학 함수 pi # 파이 값 #&gt; [1] 3.14 abs(-3) # 절대 값 absolute value of x #&gt; [1] 3 sqrt(3) # 제곱근 square root of x #&gt; [1] 1.73 round(2.345, 2) # 반올림 #&gt; [1] 2.35 ceiling(2.345) # 정수로 올림 #&gt; [1] 3 floor(2.345) # 정수로 내림 #&gt; [1] 2 trunc(2.345) # 소수점 아래 버리기, 0에 더 가까운 값 반환 #&gt; [1] 2 signif(2.345, 3) # 전체 자릿수에 맞게 반올림 #&gt; [1] 2.35 프로젝트 전체에서 자리수를 지정하고 싶다면 options() 함수를 사용합니다. 자리수 디폴트는 7이지만 __options(digits = 5)__와 같이 지정하면 5자리로 설정됩니다. "],
["객체변수의-할당과-삭제.html", "2.4 객체(변수)의 할당과 삭제", " 2.4 객체(변수)의 할당과 삭제 2.4.1 객체(변수) 만들기 변수는 일종의 데이터를 담고 있는 상자입니다. 이 상자에는 숫자나 문자 등을 넣어 보관하거나 필요할 때 빼서 사용할 수 있습니다. 또 상자 안의 내용물을 바꿀 수도 있습니다. 변수명은 항상 왼쪽에 쓰며, ‘&lt;-’ 기호를 사용하여 변수라는 상자 안에 데이터를 넣을 수 있습니다. (예, a &lt;- 2) 또한 ‘&lt;-’ 기호 대신 ’=’를 사용하여도 됩니다. 변수명은 영어와 숫자 모두 사용할 수 있으나 시작 글자는 반드시 문자여야 합니다. # 3이라는 숫자를 변수 x에 담기 x &lt;- 3 # 5라는 숫자를 변수 y에 담기 y &lt;- 5 # 변수 x에 담긴 값을 출력 x #&gt; [1] 3 # print() 함수를 사용하여 출력 가능 print(y) #&gt; [1] 5 # 변수 x에 담긴 값과 변수 y에 담긴 값 계산 x * y # 3 * 5 #&gt; [1] 15 x + y # 3 + 5 #&gt; [1] 8 # x/y의 결과 값을 변수 z에 담기 z &lt;- x / y z #&gt; [1] 0.6 2.4.2 객체(변수) 리스트 보기 ls() #&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; 2.4.3 객체(변수) 지우기 # 객체 x와 y 삭제 rm(x, y) # 남아 있는 객체 리스트 출력 ls() #&gt; [1] &quot;z&quot; "],
["기본-데이터-타입-basic-data-types.html", "2.5 기본 데이터 타입 (Basic data types)", " 2.5 기본 데이터 타입 (Basic data types) 기본 데이터 타입으로 숫자(numeric), 문자(character), 논리(logical), 날짜(date), 결측치(missing) 등이 있습니다. # 숫자 데이터 my_age &lt;- 21 # 문자 데이터 - 문자는 따옴표(&quot; 또는 &#39;)로 둘러쌉니다. my_name &lt;- &quot;영희&quot; # 논리 데이터 - TRUE, FALSE is_student &lt;- TRUE # 날짜 데이터 my_birthday &lt;- as.Date(&quot;2007-08-02&quot;) # 결측치(missing data) - 논리 데이터의 일종 my_missing &lt;- NA 문자는 따옴표로 둘러싸는데, 만일 문자들 중에 따옴표가 있으면 \"\"을 추가합니다. my_say &lt;- &quot;나의 이름은 \\&quot;영희\\&quot;입니다.&quot; my_say #&gt; [1] &quot;나의 이름은 \\&quot;영희\\&quot;입니다.&quot; 데이터 타입을 확인하는 함수는 class()입니다. class(my_age) #&gt; [1] &quot;numeric&quot; class(my_name) #&gt; [1] &quot;character&quot; 객체의 데이터 타입이 숫자인지, 문자인지를 확인하는 함수도 있습니다. 맞으면 TRUE를 출력하고 틀리면 FALSE를 출력합니다. is.numeric(my_age) #&gt; [1] TRUE is.character(my_name) #&gt; [1] TRUE is.logical(is_student) #&gt; [1] TRUE is.na(my_missing) #&gt; [1] TRUE 만일 숫자가 따옴표로 둘려싸여 있어 문자로 인식될 경우 변환 함수를 이용하여 숫자 형식으로 변경할 수 있습니다. as.numeric(&quot;21&quot;) #&gt; [1] 21 2.5.1 숫자 데이터 - 실수와 정수 100000 # 1e+05 형태로 표시됨 #&gt; [1] 1e+05 150000000 # 1.5e+08 형태로 표시됨 #&gt; [1] 1.5e+08 5e+3 # 5000 #&gt; [1] 5000 5e-3 # 0.005 #&gt; [1] 0.005 # numeric 실수 x &lt;- 21 is.numeric(x) #&gt; [1] TRUE # 정수 y &lt;- 5L is.integer(y) #&gt; [1] TRUE typeof(5) # 부동소수점 실수 double #&gt; [1] &quot;double&quot; typeof(5L) # 정수 integer #&gt; [1] &quot;integer&quot; typeof(5i) # 복소수 complex #&gt; [1] &quot;complex&quot; # 정수와 실수가 같이 연산되면 결과값은 실수 4L * 2.8 #&gt; [1] 11.2 2.5.2 논리 데이터 - TRUE == 1, FALSE == 0 TRUE * 3 #&gt; [1] 3 FALSE * 3 #&gt; [1] 0 2.5.3 NULL 객체 객체에 NULL 값을 부여함으로써 객체를 삭제하는 데 사용되기도 합니다. x &lt;- c(21, NA, 23, NA, 25) str(x) #&gt; num [1:5] 21 NA 23 NA 25 # x에 NULL 부여 x &lt;- NULL str(x) #&gt; NULL "],
["내장형-상수-built-in-constants.html", "2.6 내장형 상수 Built-in Constants", " 2.6 내장형 상수 Built-in Constants # 영어 알파벳 대문자 26개 LETTERS #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; #&gt; [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # 영어 알파벳 소문자 26개 letters #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; #&gt; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; # 영어 월 이름 약어 month.abb #&gt; [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; # 영어 월 이름 month.name #&gt; [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; #&gt; [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; # 원주율 : 원의 지름에 대한 둘레의 비율 pi #&gt; [1] 3.14 "],
["예약어-reserved-words.html", "2.7 예약어 Reserved Words", " 2.7 예약어 Reserved Words R 예약어는 R에서 특별한 의미를 가지고 있는 단어입니다. 따라서 변수명이나 사용자가 만드는 함수 이름으로 사용하지 않는 것이 좋습니다. 예약어 : if, else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_, …, ..1, ..2 등 R의 예약어를 알고 싶으면 다음과 같이 하면 됩니다. ?reserved "],
["r-데이터-구조.html", "3 R 데이터 구조 ", " 3 R 데이터 구조 "],
["vector.html", "3.1 R 벡터 Vector", " 3.1 R 벡터 Vector 벡터란 동일한 형태(예, 숫자 또는 문자)의 데이터 값들이 나열되어 있는 데이터 구조입니다. 3.1.1 벡터 만들기 3.1.1.1 c() 함수로 벡터 만들기 # 변수 v1에 숫자 1, 2, 3을 할당 v1 &lt;- c(1, 2, 3) v2 &lt;- c(4, 5, 6) v1; v2 #&gt; [1] 1 2 3 #&gt; [1] 4 5 6 # 변수 v3에 변수 v1과 v2의 값들을 결합하여 할당 v3 &lt;- c(v1, v2) v3 #&gt; [1] 1 2 3 4 5 6 # 변수 s1에 문자열 벡터인 &quot;대한&quot;, &quot;민국&quot;, &quot;행정&quot;을 할당 s1 &lt;- c(&quot;대한&quot;, &quot;민국&quot;, &quot;행정&quot;) s1 #&gt; [1] &quot;대한&quot; &quot;민국&quot; &quot;행정&quot; 3.1.1.2 연속적인 숫자로 벡터 만들기 # 콜론(:)을 이용해 연속 숫자가 들어 있는 변수 만들기 var1 &lt;- c(1:5) # 1~5까지의 연속 값 var1 #&gt; [1] 1 2 3 4 5 # seq() 함수를 이용해 연속 숫자가 들어 있는 변수 만들기 var2 &lt;- seq(1, 5) # 1~5까지의 연속 값 var2 #&gt; [1] 1 2 3 4 5 # seq() 함수의 by 옵션을 이용해 일정한 간격의 연속 숫자가 들어 있는 변수 만들기 var3 &lt;- seq(1, 10, by = 2) # 1~10까지 2간격의 연속 값 var4 &lt;- seq(1, 10, by = 3) # 1~10까지 3간격의 연속 값 var5 &lt;- seq(from = 1.0, to = 2.0, length.out = 5) var3; var4; var5 #&gt; [1] 1 3 5 7 9 #&gt; [1] 1 4 7 10 #&gt; [1] 1.00 1.25 1.50 1.75 2.00 # rep() 함수를 이용해 반복값이 들어있는 변수 만들기 var6 &lt;- rep(5, times = 7) # 5를 7번 반복 var7 &lt;- rep(c(&quot;a&quot;, &quot;b&quot;), each = 3) # 각 문자 3번 반복 var6; var7 #&gt; [1] 5 5 5 5 5 5 5 #&gt; [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; 3.1.1.3 벡터 요소 값에 이름 부여 # names() 함수를 이용해 값마다 이름 부여 mscore &lt;- c(95, 85, 75) names(mscore) &lt;- c(&quot;김철수&quot;, &quot;이영희&quot;, &quot;홍길동&quot;) mscore #&gt; 김철수 이영희 홍길동 #&gt; 95 85 75 3.1.2 벡터 요소 추출 벡터 안에 들어있는 값들을 요소라고 부릅니다. 3.1.2.1 특정 위치에 있는 요소 추출 벡터 내의 특정 위치에 있는 요소를 불러오려면 벡터명[번호]라고 하면 됩니다. v &lt;- c(11, 12, 13, 14, 15) w &lt;- c(1, 2, 3, 4, 5) v[1] #&gt; [1] 11 v[2:3] #&gt; [1] 12 13 v[c(1, 3, 5)] #&gt; [1] 11 13 15 w[seq(1, 5, 2)] # 홀수번째 값 출력 #&gt; [1] 1 3 5 3.1.2.2 이름으로 요소 추출 mscore &lt;- c(95, 85, 75) names(mscore) &lt;- c(&quot;김철수&quot;, &quot;이영희&quot;, &quot;홍길동&quot;) mscore[&quot;이영희&quot;] #&gt; 이영희 #&gt; 85 3.1.2.3 마이너스 기호(-)를 이용하여 요소 제외 # -를 사용하면 원하지 않는 값을 제외할 수 있음 v[-2] #&gt; [1] 11 13 14 15 w[-c(3:4)] #&gt; [1] 1 2 5 3.1.2.4 조건으로 요소 추출 s &lt;- c(3, 1, 5, 9, 7, 10) # 5보다 큰 값을 골라내 부분 벡터로 추출 s[s &gt;= 5] #&gt; [1] 5 9 7 10 # 8보다 큰 값을 골라내 부분 벡터로 추출 subset(s, s &gt;= 8) #&gt; [1] 9 10 # s에서 8보다 큰 element를 가진 index를 리턴 which(s &gt;= 8) #&gt; [1] 4 6 3.1.3 벡터 연산 v &lt;- c(11, 12, 13, 14, 15) w &lt;- c(1, 2, 3, 4, 5) v[1] + w[5] # 11+5=16 #&gt; [1] 16 v + w # 11+1, 12+2, ... #&gt; [1] 12 14 16 18 20 v * w # 11*1, 12*2, ... #&gt; [1] 11 24 39 56 75 w + 2 # 1+2, 2+2, ... #&gt; [1] 3 4 5 6 7 w - mean(w) # 1-평균, 2-평균, ... #&gt; [1] -2 -1 0 1 2 sqrt(w) # sqrt(1), sqrt(2), ... #&gt; [1] 1.00 1.41 1.73 2.00 2.24 sum(w) # 1+2+3+4+5 #&gt; [1] 15 3.1.4 기타 3.1.4.1 벡터 길이 측정 length(v) #&gt; [1] 5 3.1.4.2 벡터 결측값 # 결측값이 있는 벡터 생성 have_child &lt;- c(김철수 = &quot;yes&quot;, 이영철 = &quot;yes&quot;, 홍길동 = NA, 김연아 = NA) # 결측값 유무 검사 is.na(have_child) #&gt; 김철수 이영철 홍길동 김연아 #&gt; FALSE FALSE TRUE TRUE "],
["matrix.html", "3.2 R 행렬 Matrix", " 3.2 R 행렬 Matrix 동일한 형태의 데이터가 2차원으로 구성된 데이터 구조입니다. 표처럼 m × n 형태로 이루어진 데이터 구조입니다. 3.2.1 행렬 생성 3.2.1.1 matrix()를 사용하여 행렬 생성 # 1부터 12까지의 숫자를 3개열 형태의 행렬로 만들어 변수 m1에 할당 # ncol : 열의 수 m1 &lt;- matrix(1:12, ncol = 3) m1 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 # nrow : 행의 수 # byrow : FALSE(기본값)이면 행렬이 열로 채워지고 그렇지 않으면 행렬이 행으로 채워짐 m2 &lt;- matrix( data = c(1,2,3, 11,12,13), nrow = 2, byrow = TRUE ) m2 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 11 12 13 3.2.1.2 cbind() 또는 rbind()를 사용하여 행렬 생성 # 숫자 벡터 생성 col1 &lt;- c(5, 6, 7, 8, 9) col2 &lt;- c(2, 4, 5, 9, 8) col3 &lt;- c(7, 3, 4, 8, 7) # 열 기준으로 벡터 병합 m3 &lt;- cbind(col1, col2, col3) m3 #&gt; col1 col2 col3 #&gt; [1,] 5 2 7 #&gt; [2,] 6 4 3 #&gt; [3,] 7 5 4 #&gt; [4,] 8 9 8 #&gt; [5,] 9 8 7 3.2.2 행렬 이름 붙이기 3.2.2.1 rownames() 또는 colnames()를 사용하여 이름 붙이기 rownames(m3) &lt;- c(&quot;행1&quot;, &quot;행2&quot;, &quot;행3&quot;, &quot;행4&quot;, &quot;행5&quot;) colnames(m3) &lt;- c(&quot;열1&quot;, &quot;열2&quot;, &quot;열3&quot;) m3 #&gt; 열1 열2 열3 #&gt; 행1 5 2 7 #&gt; 행2 6 4 3 #&gt; 행3 7 5 4 #&gt; 행4 8 9 8 #&gt; 행5 9 8 7 3.2.2.2 matrix()의 dimnames 속성을 이용하여 이름 붙이기 m4 &lt;- matrix( data = c(1,2,3, 11,12,13), nrow = 2, byrow = TRUE, dimnames = list(c(&quot;행1&quot;, &quot;행2&quot;), c(&quot;일열&quot;, &quot;이열&quot;, &quot;삼열&quot;)) ) m4 #&gt; 일열 이열 삼열 #&gt; 행1 1 2 3 #&gt; 행2 11 12 13 3.2.3 행열 바꾸기 t(m2) #&gt; [,1] [,2] #&gt; [1,] 1 11 #&gt; [2,] 2 12 #&gt; [3,] 3 13 3.2.4 행렬의 차원 # 행의 갯수 nrow(m3) #&gt; [1] 5 # 열의 갯수 ncol(m3) #&gt; [1] 3 # 행과 열이 갯수 dim(m3) #&gt; [1] 5 3 3.2.5 행렬의 요소 추출 3.2.5.1 특정 위치에 있는 요소 추출 # 2번째 행에 있는 요소 추출 m3[2,] #&gt; 열1 열2 열3 #&gt; 6 4 3 # 2행 3열에 있는 요소 추출 m3[2, 3] #&gt; [1] 3 # 2행에서 3행 추출 m3[2:3,] #&gt; 열1 열2 열3 #&gt; 행2 6 4 3 #&gt; 행3 7 5 4 # 2행과 5행 추출 m3[c(2,5),] #&gt; 열1 열2 열3 #&gt; 행2 6 4 3 #&gt; 행5 9 8 7 3.2.5.2 행렬 이름으로 요소 추출 # 두번째 열 추출 m3[, &quot;열2&quot;] #&gt; 행1 행2 행3 행4 행5 #&gt; 2 4 5 9 8 # 세번째 행 추출 m3[&quot;행3&quot;,] #&gt; 열1 열2 열3 #&gt; 7 5 4 3.2.5.3 마이너스 기호(-)를 이용하여 요소 제외 # 2행과 2열 제외 m3[-2, -2] #&gt; 열1 열3 #&gt; 행1 5 7 #&gt; 행3 7 4 #&gt; 행4 8 8 #&gt; 행5 9 7 3.2.5.4 조건으로 요소 추출 # 3열의 값이 5이상인 경우 추출 col3 &lt;- m3[, 3] m3[col3 &gt;= 5,] #&gt; 열1 열2 열3 #&gt; 행1 5 2 7 #&gt; 행4 8 9 8 #&gt; 행5 9 8 7 # 5보다 큰 수 모두 추출 m3[m3 &gt; 5] #&gt; [1] 6 7 8 9 9 8 7 8 7 # 짝수만 추출 m3[m3 %% 2 == 0] #&gt; [1] 6 8 2 4 8 4 8 3.2.6 행렬 요소 수정 # 하나의 요소 값 수정 mm &lt;- m3; mm #&gt; 열1 열2 열3 #&gt; 행1 5 2 7 #&gt; 행2 6 4 3 #&gt; 행3 7 5 4 #&gt; 행4 8 9 8 #&gt; 행5 9 8 7 mm[2, 2] &lt;- 9; mm #&gt; 열1 열2 열3 #&gt; 행1 5 2 7 #&gt; 행2 6 9 3 #&gt; 행3 7 5 4 #&gt; 행4 8 9 8 #&gt; 행5 9 8 7 # 5미만 인 경우 0으로 수정 mm[mm &lt; 6] &lt;- 0; mm #&gt; 열1 열2 열3 #&gt; 행1 0 0 7 #&gt; 행2 6 9 0 #&gt; 행3 7 0 0 #&gt; 행4 8 9 8 #&gt; 행5 9 8 7 3.2.7 행렬 연산 m1 * 2 #&gt; [,1] [,2] [,3] #&gt; [1,] 2 10 18 #&gt; [2,] 4 12 20 #&gt; [3,] 6 14 22 #&gt; [4,] 8 16 24 log2(m1) #&gt; [,1] [,2] [,3] #&gt; [1,] 0.00 2.32 3.17 #&gt; [2,] 1.00 2.58 3.32 #&gt; [3,] 1.58 2.81 3.46 #&gt; [4,] 2.00 3.00 3.58 # 행합계 rowSums() rowSums(m3) #&gt; 행1 행2 행3 행4 행5 #&gt; 14 13 16 25 24 # 열합계 colSums() colSums(m3) #&gt; 열1 열2 열3 #&gt; 35 28 29 # 행 평균 apply(m3, 1, mean) #&gt; 행1 행2 행3 행4 행5 #&gt; 4.67 4.33 5.33 8.33 8.00 # 열 평균 apply(m3, 2, mean) #&gt; 열1 열2 열3 #&gt; 7.0 5.6 5.8 행렬곱 %*% 행열간의 곱하기는 수학적으로 곱이 가능한 형태를 갖는 행렬만이 가능합니다. x &lt;- matrix(1:9, nrow = 3) y &lt;- matrix(11:19, nrow = 3) x %*% y #&gt; [,1] [,2] [,3] #&gt; [1,] 150 186 222 #&gt; [2,] 186 231 276 #&gt; [3,] 222 276 330 "],
["factor.html", "3.3 R 팩터 Factor", " 3.3 R 팩터 Factor 범주형(명목형) 자료의 데이터 구조입니다. Levles는 이 팩터(요인)가 가질 수 있는 값들입니다. 예를 들면 성별 데이터는 범주형 데이터로서 팩터 데이터 구조를 가질 수 있는데, “남성”와 “여성”은 Levels라 할 수 있습니다. R에서 분석을 하다보면 팩터형식의 데이터이어야 하는 경우가 있고, 팩터형식이 아니어야 하는 경우가 있습니다. 상황에 따라 적절한 형식으로 변환하며 사용해야 합니다. 3.3.1 팩터 변수 만들기 sex &lt;- factor(c(&quot;남성&quot;, &quot;여성&quot;, &quot;여성&quot;, &quot;남성&quot;, &quot;남성&quot;)) sex #&gt; [1] 남성 여성 여성 남성 남성 #&gt; Levels: 남성 여성 sex &lt;- c(&quot;남성&quot;, &quot;여성&quot;, &quot;여성&quot;, &quot;남성&quot;, &quot;남성&quot;) sex &lt;- factor(sex) # Or sex &lt;- factor(sex, levels = c(&quot;여성&quot;, &quot;남성&quot;)) sex #&gt; [1] 남성 여성 여성 남성 남성 #&gt; Levels: 여성 남성 # 팩터 변수의 levels 보기 levels(sex) #&gt; [1] &quot;여성&quot; &quot;남성&quot; 팩터는 벡터와 밀접한 관계입니다. 사실상 펙터는 정수 벡터로 저장된 데이터 구조입니다. 아래에서 보듯이 levels는 문자로 저장되어 있으나, 각 요소는 숫자로 저장되어 있습니다. 1은 여성이고 2는 남성인 것입니다. str(sex) #&gt; Factor w/ 2 levels &quot;여성&quot;,&quot;남성&quot;: 2 1 1 2 2 3.3.2 팩터 요소 추출 팩터의 요소 추출은 벡터와 유사합니다. sex[3] #&gt; [1] 여성 #&gt; Levels: 여성 남성 sex[c(1, 3)] #&gt; [1] 남성 여성 #&gt; Levels: 여성 남성 sex[-1] #&gt; [1] 여성 여성 남성 남성 #&gt; Levels: 여성 남성 3.3.3 팩터 요소 수정 팩터 요소의 수정은 벡터와 비슷하나, Levels 값의 범위를 벗어날 수 없습니다. sex[1] &lt;- &quot;여성&quot; sex #&gt; [1] 여성 여성 여성 남성 남성 #&gt; Levels: 여성 남성 sex[1] &lt;- &quot;양성&quot; #&gt; Warning in `[&lt;-.factor`(`*tmp*`, 1, value = &quot;양성&quot;): invalid factor level, NA #&gt; generated sex #&gt; [1] &lt;NA&gt; 여성 여성 남성 남성 #&gt; Levels: 여성 남성 Levels 값의 범위를 벗어난 값을 추가하려면 먼저 새로운 Levels 값을 추가합니다. # 새로운 Levels 값 추가 levels(sex) &lt;- c(levels(sex), &quot;양성&quot;) sex[1] &lt;- &quot;양성&quot; sex #&gt; [1] 양성 여성 여성 남성 남성 #&gt; Levels: 여성 남성 양성 3.3.4 기타 3.3.4.1 팩터 레벨의 순서 변경 팩터 레벨의 순서는 levels 속성에서 정의하여 줍니다. sex &lt;- factor(sex, levels = c(&quot;여성&quot;, &quot;양성&quot;, &quot;남성&quot;)) sex #&gt; [1] 양성 여성 여성 남성 남성 #&gt; Levels: 여성 양성 남성 3.3.4.2 팩터 형식 검사 is.factor(sex) #&gt; [1] TRUE 3.3.4.3 팩터 변환 factor()와 as.factor()는 거의 유사하나, 입력 데이터가 이미 factor이거나 vector이면 as.factor()의 속도가 더 빠릅니다. pf &lt;- c(1, 5, 1, 3, 3, 2, 4, 2, 5, 1, 3, 5) pf &lt;- as.factor(pf) pf #&gt; [1] 1 5 1 3 3 2 4 2 5 1 3 5 #&gt; Levels: 1 2 3 4 5 3.3.4.4 팩터 변수 요약 summary(sex) #&gt; 여성 양성 남성 #&gt; 2 1 2 "],
["array.html", "3.4 R 배열 Array", " 3.4 R 배열 Array 배열은 동일한 형태의 데이터가 2차원 이상으로 구성된 데이터 구조입니다. 벡터가 1차원이고, 행렬은 2차원, 배열은 2차원 이상의 구조입니다. 배열은 행렬을 층층히 쌓으면서 3차원, 4차원, 5차원 등으로 확대할 수 있습니다. 3.4.1 배열 생성 # 1~24의 숫자를 3x4 행렬의 2층 짜리 배열 만들기 arr1 &lt;- array(1:24, dim = c(3, 4, 2)) arr1 #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 13 16 19 22 #&gt; [2,] 14 17 20 23 #&gt; [3,] 15 18 21 24 3.4.2 배열 이름 붙이기 # array()의 dimnames 속성을 이용하여 이름 붙이기 arr2 &lt;- array( data = 1:24, dim = c(4, 3, 2), dimnames = list(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;), c(&quot;ray&quot;, &quot;karl&quot;, &quot;mimo&quot;), c(&quot;steve&quot;, &quot;mark&quot;) ) ) arr2 #&gt; , , steve #&gt; #&gt; ray karl mimo #&gt; one 1 5 9 #&gt; two 2 6 10 #&gt; three 3 7 11 #&gt; four 4 8 12 #&gt; #&gt; , , mark #&gt; #&gt; ray karl mimo #&gt; one 13 17 21 #&gt; two 14 18 22 #&gt; three 15 19 23 #&gt; four 16 20 24 3.4.3 배열의 요소 추출 3.4.3.1 특정위치에 있는 요소 추출 # 2행, 2열, 2층 요소 추출 arr2[2, 2, 2] #&gt; [1] 18 # 각 층의 2행 추출 arr2[2, , ] #&gt; steve mark #&gt; ray 2 14 #&gt; karl 6 18 #&gt; mimo 10 22 # 각층의 3행, 3열 요소 추출 arr2[3, 3, ] #&gt; steve mark #&gt; 11 23 # 2층의 행렬 추출 arr2[,,2] #&gt; ray karl mimo #&gt; one 13 17 21 #&gt; two 14 18 22 #&gt; three 15 19 23 #&gt; four 16 20 24 3.4.3.2 이름으로 요소 추출 # 2행(two), 2열(karl), 2층(mark) 요소 추출 arr2[&quot;two&quot;, &quot;karl&quot;, &quot;mark&quot;] #&gt; [1] 18 # 각 층의 2행(two) 추출 arr2[&quot;two&quot;, , ] #&gt; steve mark #&gt; ray 2 14 #&gt; karl 6 18 #&gt; mimo 10 22 # 각층의 3행(three), 3열(mimo) 요소 추출 arr2[&quot;three&quot;, &quot;mimo&quot;, ] #&gt; steve mark #&gt; 11 23 # 2층(mark)의 행렬 추출 arr2[,,&quot;mark&quot;] #&gt; ray karl mimo #&gt; one 13 17 21 #&gt; two 14 18 22 #&gt; three 15 19 23 #&gt; four 16 20 24 3.4.3.3 마이너스 기호(-)를 이용하여 요소 제외 # 2행과 2열 제외 arr2[-2, -2, ] #&gt; , , steve #&gt; #&gt; ray mimo #&gt; one 1 9 #&gt; three 3 11 #&gt; four 4 12 #&gt; #&gt; , , mark #&gt; #&gt; ray mimo #&gt; one 13 21 #&gt; three 15 23 #&gt; four 16 24 3.4.3.4 조건으로 요소 추출 # 11초과인 값 추출 arr2[arr2 &gt; 11] #&gt; [1] 12 13 14 15 16 17 18 19 20 21 22 23 24 # 짝수 추출 arr2[arr2 %% 2 == 0] #&gt; [1] 2 4 6 8 10 12 14 16 18 20 22 24 3.4.4 배열 요소 수정 arr2[2, 2, 1] &lt;- 55 arr2 #&gt; , , steve #&gt; #&gt; ray karl mimo #&gt; one 1 5 9 #&gt; two 2 55 10 #&gt; three 3 7 11 #&gt; four 4 8 12 #&gt; #&gt; , , mark #&gt; #&gt; ray karl mimo #&gt; one 13 17 21 #&gt; two 14 18 22 #&gt; three 15 19 23 #&gt; four 16 20 24 3.4.5 배열 연산 arr2 * 3 #&gt; , , steve #&gt; #&gt; ray karl mimo #&gt; one 3 15 27 #&gt; two 6 165 30 #&gt; three 9 21 33 #&gt; four 12 24 36 #&gt; #&gt; , , mark #&gt; #&gt; ray karl mimo #&gt; one 39 51 63 #&gt; two 42 54 66 #&gt; three 45 57 69 #&gt; four 48 60 72 rowSums(arr2) #&gt; one two three four #&gt; 66 121 78 84 colSums(arr2) #&gt; steve mark #&gt; ray 10 58 #&gt; karl 75 74 #&gt; mimo 42 90 배열의 차원이 같다면 배열끼리 계산이 가능합니다. ax &lt;- array(1:12, dim = c(2, 3, 2)) ay &lt;- array(11:22, dim = c(2, 3, 2)) ax; ay #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 11 13 15 #&gt; [2,] 12 14 16 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 17 19 21 #&gt; [2,] 18 20 22 ax + ay #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 12 16 20 #&gt; [2,] 14 18 22 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 24 28 32 #&gt; [2,] 26 30 34 ax * ay #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 11 39 75 #&gt; [2,] 24 56 96 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 119 171 231 #&gt; [2,] 144 200 264 ax / ay #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 0.0909 0.231 0.333 #&gt; [2,] 0.1667 0.286 0.375 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 0.412 0.474 0.524 #&gt; [2,] 0.444 0.500 0.545 ax + (1:2) #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 2 4 6 #&gt; [2,] 4 6 8 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 8 10 12 #&gt; [2,] 10 12 14 "],
["dataframe.html", "3.5 R 데이터 프레임 Data frame", " 3.5 R 데이터 프레임 Data frame 데이터 프레임은 다양한 형태의 데이터가 2차원으로 구성된 데이터 구조입니다. 행(케이스)과 열(변수)로 구성된 표와 같이 생겼습니다. 엑셀에서 이름 필드, 연령 필드, 성적 필드 등으로 이루어진 표와 같다고 보면 됩니다. 통계분석에 가장 많이 사용됩니다. 3.5.1 데이터 프레임 만들기 데이터 프레임을 생성하는 방법은 많습니다. 그 중에서 가장 많이 쓰이는 방법은 외부에서 만들어진 정리된 데이터를 R에서 읽어 들이는 방법입니다. 이 방법은 R 입출력에서 자세히 다루겠습니다. 두 번째 방법은 벡터 형식의 자료를 묶어서 데이터 프레임을 만드는 것입니다. 아래 예제는 data.frame 함수를 이용하여 벡터 변수 name, age, sex, score를 하나로 묶어서 데이터 프레임 df를 만들어 보겠습니다. name &lt;- c(&quot;유재석&quot;, &quot;홍진영&quot;, &quot;송가인&quot;, &quot;강호동&quot;, &quot;이영자&quot;, &quot;김종민&quot;, &quot;김연아&quot;) age &lt;- c(24, 28, 31, 25, 27, 22, 29) sex &lt;- c(&quot;남&quot;, &quot;여&quot;, &quot;여&quot;, &quot;남&quot;, &quot;여&quot;, &quot;남&quot;, &quot;여&quot;) score &lt;- c(90, 80, 85, 75, 95, 80, 70) # &#39;stringsAsFactors = FALSE&#39; 옵션 : 문자 데이터를 팩터로 변환시키지 않음 df &lt;- data.frame(name, age, sex, score, stringsAsFactors = FALSE) df #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 28 여 80 #&gt; 3 송가인 31 여 85 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 3.5.2 데이터 프레임 구조 보기 # 데이터 프레임 구조 str(df) #&gt; &#39;data.frame&#39;: 7 obs. of 4 variables: #&gt; $ name : chr &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; ... #&gt; $ age : num 24 28 31 25 27 22 29 #&gt; $ sex : chr &quot;남&quot; &quot;여&quot; &quot;여&quot; &quot;남&quot; ... #&gt; $ score: num 90 80 85 75 95 80 70 # 행 개수 nrow(df) #&gt; [1] 7 # 열 개수 ncol(df) #&gt; [1] 4 3.5.3 데이터 프레임 요약 보기 summary(df) #&gt; name age sex score #&gt; Length:7 Min. :22.0 Length:7 Min. :70.0 #&gt; Class :character 1st Qu.:24.5 Class :character 1st Qu.:77.5 #&gt; Mode :character Median :27.0 Mode :character Median :80.0 #&gt; Mean :26.6 Mean :82.1 #&gt; 3rd Qu.:28.5 3rd Qu.:87.5 #&gt; Max. :31.0 Max. :95.0 3.5.4 데이터 프레임에서 데이터 추출 3.5.4.1 특정 위치(행과 열 기준)에 있는 데이터 추출하기 # name 열(변수) 데이터 추출 # 데이터프레임과 컬럼사이에 $기호가 사용됨 df$name #&gt; [1] &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; &quot;이영자&quot; &quot;김종민&quot; &quot;김연아&quot; # df$name 대신 아래처럼 사용 가능 df[, &quot;name&quot;] #&gt; [1] &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; &quot;이영자&quot; &quot;김종민&quot; &quot;김연아&quot; # 첫번째 열(name) 추출 df[, 1] #&gt; [1] &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; &quot;이영자&quot; &quot;김종민&quot; &quot;김연아&quot; # 1열과 3열 추출 df[, c(1, 3)] #&gt; name sex #&gt; 1 유재석 남 #&gt; 2 홍진영 여 #&gt; 3 송가인 여 #&gt; 4 강호동 남 #&gt; 5 이영자 여 #&gt; 6 김종민 남 #&gt; 7 김연아 여 # name 열(변수)의 3번째 데이터 추출 df$name[3] #&gt; [1] &quot;송가인&quot; # 2~3번째 행 추출 df[2:3, ] #&gt; name age sex score #&gt; 2 홍진영 28 여 80 #&gt; 3 송가인 31 여 85 # 연령 변수의 데이터를 추출하여 평균을 구함 # na.rm = TRUE는 missing value를 제외하고 계산함 mean(df$age, na.rm = TRUE) #&gt; [1] 26.6 3.5.4.2 마이너스 기호(-)를 이용하여 데이터 제외 # 3번째 열 제외 df[, -3] #&gt; name age score #&gt; 1 유재석 24 90 #&gt; 2 홍진영 28 80 #&gt; 3 송가인 31 85 #&gt; 4 강호동 25 75 #&gt; 5 이영자 27 95 #&gt; 6 김종민 22 80 #&gt; 7 김연아 29 70 3.5.4.3 조건으로 데이터 추출 특정 조건에 맞는 데이터만 추출할 때 대괄호 안에 조건식을 입력하여 추출하거나 subset 함수를 이용하여 추출할 수 있습니다. 데이터가 매우 많을 경우에는 대괄호 안에 조건식을 입력하여 추출하는 것이 subset 함수를 이용하는 것 보다 더 빠릅니다. 3.5.4.3.1 대괄호 안에 조건식 입력하여 추출 # score가 90이상인 데이터 추출 df[df$score &gt;= 90, ] #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 5 이영자 27 여 95 # score가 90이상인 데이터의 name과 age만 추출 # 1:2 대신 c(&quot;name&quot;, &quot;age&quot;)를 사용해도 됨 df[df$score &gt;= 90, 1:2] #&gt; name age #&gt; 1 유재석 24 #&gt; 5 이영자 27 # 조건식과 출력 컬럼명을 변수에 입력하고 이를 활용 score90 &lt;- df$score &gt;= 90 cols &lt;- c(&quot;name&quot;, &quot;age&quot;) df[score90, cols] #&gt; name age #&gt; 1 유재석 24 #&gt; 5 이영자 27 3.5.4.3.2 subset()을 이용하여 추출 # score가 90이상인 데이터 추출 subset(df, score &gt;= 90) #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 5 이영자 27 여 95 # score가 90이상인 데이터의 name과 age만 추출 subset(df, score &gt;= 90, select = c(&quot;name&quot;, &quot;age&quot;)) #&gt; name age #&gt; 1 유재석 24 #&gt; 5 이영자 27 # score가 90이상인 데이터에서 age와 sex만 제외하고 추출 subset(df, score &gt;= 90, select = -(age:sex)) #&gt; name score #&gt; 1 유재석 90 #&gt; 5 이영자 95 3.5.5 데이터 프레임의 데이터 수정 # 2번째 행에 있는 홍진영의 age를 29로 수정 df$age[2] &lt;- 29 df #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 29 여 80 #&gt; 3 송가인 31 여 85 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 # 3행에 있는 송가인의 score를 95로 수정 df[3, &quot;score&quot;] &lt;- 95 df #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 29 여 80 #&gt; 3 송가인 31 여 95 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 3.5.6 데이터 프레임 구조 수정 3.5.6.1 데이터 프레임 행열 추가 3.5.6.1.1 행 추가 new_data &lt;- list(&quot;김남준&quot;, 24, &quot;남&quot;, 92) new_data #&gt; [[1]] #&gt; [1] &quot;김남준&quot; #&gt; #&gt; [[2]] #&gt; [1] 24 #&gt; #&gt; [[3]] #&gt; [1] &quot;남&quot; #&gt; #&gt; [[4]] #&gt; [1] 92 df &lt;- rbind(df, new_data) df #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 29 여 80 #&gt; 3 송가인 31 여 95 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 #&gt; 8 김남준 24 남 92 new_data &lt;- data.frame( name = &quot;이지은&quot;, age = 26, sex = &quot;여&quot;, score = 93) df &lt;- rbind(df, new_data) df #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 29 여 80 #&gt; 3 송가인 31 여 95 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 #&gt; 8 김남준 24 남 92 #&gt; 9 이지은 26 여 93 3.5.6.1.2 열 추가 # salary 열 추가 df$salary &lt;- c(220, 180, 250, 170, 220, 270, 250, 290, 210) df #&gt; name age sex score salary #&gt; 1 유재석 24 남 90 220 #&gt; 2 홍진영 29 여 80 180 #&gt; 3 송가인 31 여 95 250 #&gt; 4 강호동 25 남 75 170 #&gt; 5 이영자 27 여 95 220 #&gt; 6 김종민 22 남 80 270 #&gt; 7 김연아 29 여 70 250 #&gt; 8 김남준 24 남 92 290 #&gt; 9 이지은 26 여 93 210 # 또는 cbind를 활용할 수 있음 # salary 열 추가 salary2 &lt;- c(220, 180, 250, 170, 220, 270, 250, 290, 210) df &lt;- cbind(df, salary2) df #&gt; name age sex score salary salary2 #&gt; 1 유재석 24 남 90 220 220 #&gt; 2 홍진영 29 여 80 180 180 #&gt; 3 송가인 31 여 95 250 250 #&gt; 4 강호동 25 남 75 170 170 #&gt; 5 이영자 27 여 95 220 220 #&gt; 6 김종민 22 남 80 270 270 #&gt; 7 김연아 29 여 70 250 250 #&gt; 8 김남준 24 남 92 290 290 #&gt; 9 이지은 26 여 93 210 210 salary3 &lt;- c(220, 180, 250, 170, 220, 270, 250, 290, 210) new_data &lt;- data.frame(salary3) df &lt;- cbind(df, new_data) df #&gt; name age sex score salary salary2 salary3 #&gt; 1 유재석 24 남 90 220 220 220 #&gt; 2 홍진영 29 여 80 180 180 180 #&gt; 3 송가인 31 여 95 250 250 250 #&gt; 4 강호동 25 남 75 170 170 170 #&gt; 5 이영자 27 여 95 220 220 220 #&gt; 6 김종민 22 남 80 270 270 270 #&gt; 7 김연아 29 여 70 250 250 250 #&gt; 8 김남준 24 남 92 290 290 290 #&gt; 9 이지은 26 여 93 210 210 210 3.5.6.2 데이터 프레임 행열 삭제 3.5.6.2.1 행 삭제 # 9행 삭제 df &lt;- df[-9, ] df #&gt; name age sex score salary salary2 salary3 #&gt; 1 유재석 24 남 90 220 220 220 #&gt; 2 홍진영 29 여 80 180 180 180 #&gt; 3 송가인 31 여 95 250 250 250 #&gt; 4 강호동 25 남 75 170 170 170 #&gt; 5 이영자 27 여 95 220 220 220 #&gt; 6 김종민 22 남 80 270 270 270 #&gt; 7 김연아 29 여 70 250 250 250 #&gt; 8 김남준 24 남 92 290 290 290 # score 가 80이하 삭제 df &lt;- df[!df$score &lt; 80, ] df #&gt; name age sex score salary salary2 salary3 #&gt; 1 유재석 24 남 90 220 220 220 #&gt; 2 홍진영 29 여 80 180 180 180 #&gt; 3 송가인 31 여 95 250 250 250 #&gt; 5 이영자 27 여 95 220 220 220 #&gt; 6 김종민 22 남 80 270 270 270 #&gt; 8 김남준 24 남 92 290 290 290 3.5.6.2.2 열 삭제 # salary3 변수(열) 삭제 df$salary3 &lt;- NULL df #&gt; name age sex score salary salary2 #&gt; 1 유재석 24 남 90 220 220 #&gt; 2 홍진영 29 여 80 180 180 #&gt; 3 송가인 31 여 95 250 250 #&gt; 5 이영자 27 여 95 220 220 #&gt; 6 김종민 22 남 80 270 270 #&gt; 8 김남준 24 남 92 290 290 # 5열(salary)과 6열(salary2) 삭제 df &lt;- df[, -(5:6)] df #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 29 여 80 #&gt; 3 송가인 31 여 95 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 8 김남준 24 남 92 3.5.7 기타 3.5.7.1 데이터 프레인 컬럼명 추출 names(df) #&gt; [1] &quot;name&quot; &quot;age&quot; &quot;sex&quot; &quot;score&quot; 3.5.7.2 데이터 프레임 컬럼(열) 개수 # 컬럼의 갯수 보기 ncol == length ncol(df); length(df) #&gt; [1] 4 #&gt; [1] 4 3.5.7.3 데이터 프레임 행 개수 nrow(df) #&gt; [1] 6 3.5.7.4 데이터 프레임 연산 # rowSums(), colSums(), colMeans(), rowMeans() # 연산을 위해 숫자가 아인 컬럼 제거 (1열 name, 3열 sex) df2 &lt;- df[, -c(1, 3)] df2 #&gt; age score #&gt; 1 24 90 #&gt; 2 29 80 #&gt; 3 31 95 #&gt; 5 27 95 #&gt; 6 22 80 #&gt; 8 24 92 colMeans(df2) #&gt; age score #&gt; 26.2 88.7 "],
["list.html", "3.6 R 리스트 List", " 3.6 R 리스트 List 리스트(List)는 벡터, 행렬, 배열, 데이터 프레임 등과 같은 서로 다른 구조의 객체들을 하나로 묶은 것입니다. 기차처럼 이어서 묶어 놓은 것을 상상하면 될 것입니다. 3.6.1 리스트 만들기 숫자 벡터, 문자벡터, 행렬, 데이터 프레임을 하나로 묶어서 mylist라는 변수에 할당하겠습니다. # 숫자 벡터 numvec &lt;- seq(1, 10, by = 2) # 문자 벡터 strvec &lt;- c(&quot;대한&quot;, &quot;민국&quot;, &quot;행정&quot;) # 행렬 mtx &lt;- matrix(1:12, ncol = 3) # 데이터 프레임 name &lt;- c(&quot;유재석&quot;, &quot;홍진영&quot;, &quot;송가인&quot;, &quot;강호동&quot;, &quot;이영자&quot;, &quot;김종민&quot;, &quot;김연아&quot;) age &lt;- c(24, 28, 31, 25, 27, 22, 29) sex &lt;- c(&quot;남&quot;, &quot;여&quot;, &quot;여&quot;, &quot;남&quot;, &quot;여&quot;, &quot;남&quot;, &quot;여&quot;) score &lt;- c(90, 80, 85, 75, 95, 80, 70) df &lt;- data.frame(name, age, sex, score, stringsAsFactors = FALSE) # 리스트 만들기 : 리스트 요소에 이름이 지정되지 않음 mylist &lt;- list(numvec, strvec, mtx, df) mylist #&gt; [[1]] #&gt; [1] 1 3 5 7 9 #&gt; #&gt; [[2]] #&gt; [1] &quot;대한&quot; &quot;민국&quot; &quot;행정&quot; #&gt; #&gt; [[3]] #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; #&gt; [[4]] #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 28 여 80 #&gt; 3 송가인 31 여 85 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 # 리스트 요소에 이름을 지정하여 리스트 만들기 mylist &lt;- list(numvec = numvec, strvec = strvec, mtx = mtx, df = df) mylist #&gt; $numvec #&gt; [1] 1 3 5 7 9 #&gt; #&gt; $strvec #&gt; [1] &quot;대한&quot; &quot;민국&quot; &quot;행정&quot; #&gt; #&gt; $mtx #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; #&gt; $df #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 28 여 80 #&gt; 3 송가인 31 여 85 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 3.6.1.1 리스트 요소 이름 지정 또는 변경하기 names(mylist) &lt;- c(&quot;numbers&quot;, &quot;strings&quot;, &quot;matrix_num&quot;, &quot;df_score&quot;) mylist #&gt; $numbers #&gt; [1] 1 3 5 7 9 #&gt; #&gt; $strings #&gt; [1] &quot;대한&quot; &quot;민국&quot; &quot;행정&quot; #&gt; #&gt; $matrix_num #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; #&gt; $df_score #&gt; name age sex score #&gt; 1 유재석 24 남 90 #&gt; 2 홍진영 28 여 80 #&gt; 3 송가인 31 여 85 #&gt; 4 강호동 25 남 75 #&gt; 5 이영자 27 여 95 #&gt; 6 김종민 22 남 80 #&gt; 7 김연아 29 여 70 3.6.2 리스트 구조 보기 # 리스트 구조 보기 str(mylist) #&gt; List of 4 #&gt; $ numbers : num [1:5] 1 3 5 7 9 #&gt; $ strings : chr [1:3] &quot;대한&quot; &quot;민국&quot; &quot;행정&quot; #&gt; $ matrix_num: int [1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ df_score :&#39;data.frame&#39;: 7 obs. of 4 variables: #&gt; ..$ name : chr [1:7] &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; ... #&gt; ..$ age : num [1:7] 24 28 31 25 27 22 29 #&gt; ..$ sex : chr [1:7] &quot;남&quot; &quot;여&quot; &quot;여&quot; &quot;남&quot; ... #&gt; ..$ score: num [1:7] 90 80 85 75 95 80 70 # 리스트에 있는 객체(요소)의 개수 length(mylist) #&gt; [1] 4 # 리스트 요소의 이름 추출 names(mylist) #&gt; [1] &quot;numbers&quot; &quot;strings&quot; &quot;matrix_num&quot; &quot;df_score&quot; 3.6.3 리스트에서 데이터 추출 3.6.3.1 특정 위치에 있는 데이터 추출하기 # 행렬(matrix_num) 요소 데이터 추출 # 리스트와 요소사이에 $기호가 사용됨 mylist$matrix_num #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 # 위치 번호 대신 요소 이름을 사용하여 추출 # []는 리스트의 하위 요소를 보여주는 것임. 타입은 list mylist[&quot;matrix_num&quot;]; typeof(mylist[&quot;matrix_num&quot;]) #&gt; $matrix_num #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; [1] &quot;list&quot; # [[]]는 리스트 하위 요소의 데이터를 보여줌. 타입은 integer mylist[[&quot;matrix_num&quot;]]; typeof(mylist[[&quot;matrix_num&quot;]]) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 #&gt; [1] &quot;integer&quot; # df$matrix_num 대신 아래처럼 사용 가능 - 3번째 요소 # mylist$numbers == mylist[[&quot;numbers&quot;]] == mylist[[1]] mylist$numbers; mylist[[&quot;numbers&quot;]]; mylist[[1]] #&gt; [1] 1 3 5 7 9 #&gt; [1] 1 3 5 7 9 #&gt; [1] 1 3 5 7 9 # 리스트의 strings 요소의 3번째 데이터 추출 # 아래 3가지 방식이 동일함 s1 &lt;- mylist$strings[3] s2 &lt;- mylist[[&quot;strings&quot;]][3] s3 &lt;- mylist[[2]][3] s1; s2; s3 #&gt; [1] &quot;행정&quot; #&gt; [1] &quot;행정&quot; #&gt; [1] &quot;행정&quot; # 리스트의 요소인 df_score 데이터 프레임의 name 변수 데이터 추출 mylist$df_score$name #&gt; [1] &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; &quot;이영자&quot; &quot;김종민&quot; &quot;김연아&quot; 3.6.4 리스트의 데이터 수정 # 리스트의 strings 요소의 3번째 데이터를 &quot;정부&quot;로 수정 mylist$strings[3] &lt;- &quot;정부&quot; mylist$strings #&gt; [1] &quot;대한&quot; &quot;민국&quot; &quot;정부&quot; 3.6.5 리스트 구조 수정 3.6.5.1 리스트 요소 추가 mylist$new_list &lt;- 1:5 str(mylist) #&gt; List of 5 #&gt; $ numbers : num [1:5] 1 3 5 7 9 #&gt; $ strings : chr [1:3] &quot;대한&quot; &quot;민국&quot; &quot;정부&quot; #&gt; $ matrix_num: int [1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ df_score :&#39;data.frame&#39;: 7 obs. of 4 variables: #&gt; ..$ name : chr [1:7] &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; ... #&gt; ..$ age : num [1:7] 24 28 31 25 27 22 29 #&gt; ..$ sex : chr [1:7] &quot;남&quot; &quot;여&quot; &quot;여&quot; &quot;남&quot; ... #&gt; ..$ score: num [1:7] 90 80 85 75 95 80 70 #&gt; $ new_list : int [1:5] 1 2 3 4 5 3.6.5.2 리스트 요소 제거 mylist$new_list &lt;- NULL str(mylist) #&gt; List of 4 #&gt; $ numbers : num [1:5] 1 3 5 7 9 #&gt; $ strings : chr [1:3] &quot;대한&quot; &quot;민국&quot; &quot;정부&quot; #&gt; $ matrix_num: int [1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ df_score :&#39;data.frame&#39;: 7 obs. of 4 variables: #&gt; ..$ name : chr [1:7] &quot;유재석&quot; &quot;홍진영&quot; &quot;송가인&quot; &quot;강호동&quot; ... #&gt; ..$ age : num [1:7] 24 28 31 25 27 22 29 #&gt; ..$ sex : chr [1:7] &quot;남&quot; &quot;여&quot; &quot;여&quot; &quot;남&quot; ... #&gt; ..$ score: num [1:7] 90 80 85 75 95 80 70 3.6.5.3 리스트 병합 list1 &lt;- list(x1 = 1:5, x2 = LETTERS) list2 &lt;- list(y1 = 11:17, y2 = letters) # 2개 리스트 병합 mlist &lt;- c(list1, list2) mlist #&gt; $x1 #&gt; [1] 1 2 3 4 5 #&gt; #&gt; $x2 #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; #&gt; [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; #&gt; #&gt; $y1 #&gt; [1] 11 12 13 14 15 16 17 #&gt; #&gt; $y2 #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; #&gt; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 3.6.6 리스트를 벡터로 변환 # 리스트를 벡터로 변환 unlist(list1) #&gt; x11 x12 x13 x14 x15 x21 x22 x23 x24 x25 x26 x27 x28 x29 x210 x211 #&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; #&gt; x212 x213 x214 x215 x216 x217 x218 x219 x220 x221 x222 x223 x224 x225 x226 #&gt; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; # 리스트 요소를 벡터로 변환 unlist(mylist$numbers) #&gt; [1] 1 3 5 7 9 "],
["r-제어문.html", "4 R 제어문", " 4 R 제어문 제어문은 프로그램이 흐름을 제어할 수 있도록 도와주는 함수입니다. R의 제어문은 조건문과 반복문으로 구성되어 있습니다. 조건문 if() ifelse() switch() 반복문 for() while() repeat() "],
["if.html", "4.1 if()", " 4.1 if() if() 함수가 사용되는 방식은 3가지가 있습니다. 첫번째 형식은 (조건)이 참(TRUE)이면 해당 명령어를 실행합니다. 두번째 형식은 else 문을 써서 조건이 참(TRUE)이 아니면 else 다음에 있는 명령어를 실행합니다. 세번째 형식은 else if를 써서 조건을 반복시키는 것입니다. if (조건) {조건이 만족되면 실행} if (조건) {조건이 만족되면 실행} else {조건이 만족되지 못하면 실행} if (조건1) {조건1 만족 실행} else if (조건2) {조건2 만족 실행} else {불만족 실행} # x가 0보다 크면 양수 x &lt;- 7 if (x &gt; 0) { print(&quot;양수&quot;) } #&gt; [1] &quot;양수&quot; # x가 0보다 크면 양수, 그렇지 않으면 음수 x &lt;- -3 if (x &gt; 0) { print(&quot;양수&quot;) } else { print(&quot;음수&quot;) } #&gt; [1] &quot;음수&quot; # x가 90 이상이면 A, ..., 60 이상이면 D, 나머지(60미만)는 F x &lt;- 92 if (x &gt;= 90) { print(&quot;A&quot;) } else if (x &gt;= 80) { print(&quot;B&quot;) } else if (x &gt;= 70) { print(&quot;C&quot;) } else if (x &gt;= 60) { print(&quot;D&quot;) } else { print(&quot;F&quot;) } #&gt; [1] &quot;A&quot; 아래 코드와 같이 브라켓을 사용하지 않고도 if()를 사용할 수 있으나 이해하기 어려우므로 사용하지 않는 것이 좋습니다. 브라켓({})을 사용하는 위 예제코드 방식으로 쓰는 것이 좋습니다. # {}를 사용하지 않는 코드는 나중에 이해하기 어려우므로 추천하지 않습니다. x &lt;- 5 if (x &gt; 0) print(&quot;양수&quot;) else print(&quot;음수&quot;) #&gt; [1] &quot;양수&quot; 조건이 2개 이상이 있는 경우나 조건결과를 반대로 할 경우에는 아래 논리연산자를 사용합니다. &amp;는 그리고의 의미가 있고, |는 또는의 의미가 있습니다. !는 조건 결과를 반대로 뒤집습니다. Table 4.1: 조건에 사용하는 논리 연산자 연산자 의미 수식예 &amp; AND x &gt; 3 &amp; x &lt; 7 | OR x &lt; 3 | x &gt; 7 ! NOT !(x &gt; 3) x &lt;- 25 y &lt;- 75 if (x &gt; 0 &amp; y &lt; 100) { print(&quot;TRUE 입니다&quot;) } else { print(&quot;FALSE 입니다&quot;) } #&gt; [1] &quot;TRUE 입니다&quot; "],
["ifelse.html", "4.2 ifelse()", " 4.2 ifelse() ifelse() 함수는 엑셀의 if() 함수와 사용법이 거의 유사합니다. 1번째 인수인 조건을 검사해서 그 결과가 참이면 2번째 인수를 실행하고 그렇지 않으면 3번째 인수를 실행합니다. ifelse(조건, 조건이 만족되면 실행, 조건이 만족되지 못하면 실행) x &lt;- 5 ifelse(x %% 2 == 0, &quot;짝수&quot;, &quot;홀수&quot;) #&gt; [1] &quot;홀수&quot; ifelse()는 벡터 데이터도 검사해서 그 결과를 벡터로 출력합니다. 데이터에 결측치(NA)가 있을 경우에는 그대로 NA를 출력합니다. x &lt;- c(1, 2, 3, 4, 5, NA, 7) ifelse(x %% 2 == 0, &quot;짝수&quot;, &quot;홀수&quot;) #&gt; [1] &quot;홀수&quot; &quot;짝수&quot; &quot;홀수&quot; &quot;짝수&quot; &quot;홀수&quot; NA &quot;홀수&quot; "],
["switch.html", "4.3 switch()", " 4.3 switch() switch()는 if()와 비슷한 조건함수입니다. 조건이 많을때 코드를 간결하게 표현하기 위해서 if() 대신 사용하기도 합니다. switch(지시값, 지시값1 = 실행1, 지시값2 = 실행2, 지시값3....) x &lt;- &quot;한국인&quot; switch(x, &quot;영국인&quot; = print(&quot;영국인입니다!&quot;), &quot;한국인&quot; = print(&quot;한국인입니다!&quot;), &quot;미국인&quot; = print(&quot;미국인입니다!&quot;), stop(&quot;지시값이 정확하지 않습니다!&quot;) ) #&gt; [1] &quot;한국인입니다!&quot; 지시값을 직접 텍스트로 입력하지 않아도 됩니다. 숫자를 입력하면 해당 순서에 있는 것이 출력됩니다. x &lt;- 2 switch(x, &quot;영국인&quot; = print(&quot;영국인입니다!&quot;), &quot;한국인&quot; = print(&quot;한국인입니다!&quot;), &quot;미국인&quot; = print(&quot;미국인입니다!&quot;), stop(&quot;지시값이 정확하지 않습니다!&quot;) ) #&gt; [1] &quot;한국인입니다!&quot; 아래 예제는 R 도움말에 있는 예제를 활용한 것입니다. 평균, 중위수 등을 선택해서 사용하도록 하는 함수를 만들었습니다. center &lt;- function(x, type) { switch(type, mean = mean(x), median = median(x), trimmed = mean(x, trim = .1), stop(&quot;type 값을 잘못 입력하였습니다!&quot;) ) } set.seed(123) x &lt;- sample(x=1:30, size=10, replace=T) center(x, &quot;mean&quot;) #&gt; [1] 13.7 center(x, &quot;median&quot;) #&gt; [1] 14.5 center(x, 2) # median 호출 #&gt; [1] 14.5 "],
["for.html", "4.4 for()", " 4.4 for() fot() 함수는 반복적인 작업에 유용합니다. 매번 조건을 확인하면서 조건이 허락할 때까지 반복을 합니다. for()와 유사한 반복문 함수로 while()과 repeat()가 있습니다. 일반적으로 R 전문가들은 R의 벡터 연산의 특성을 살려 처리성능을 높이려면 가급적 반복함수보다는 map()이나 apply()를 이용한 벡터기반 반복작업을 하라고 추천합니다. for (item in vector) {반복 실행} vector의 갯수만큼 반복됩니다. 예를 들면 1에서 5까지 있는 벡터가 있다면 1, 2, … 이런 순으로 반복이 됩니다. # 1부터 5까지 출력 for (i in 1:5) { print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # 알파벳 철자 순서대로 5개 출력, x의 각 요소를 출력 x &lt;- LETTERS[1:5] for (i in 1:5) { print(x[i]) } #&gt; [1] &quot;A&quot; #&gt; [1] &quot;B&quot; #&gt; [1] &quot;C&quot; #&gt; [1] &quot;D&quot; #&gt; [1] &quot;E&quot; seq_along() 함수는 객체의 길이만큼 일련번호를 출력합니다. 예를 들면 x &lt;- LETTERS[1:5]에서 객체 x의 길이는 5입니다. lenth(x)를 하면 5입니다. seq_along(x)를 실행하면 1:lenth(x) 즉 1:5까지의 일련번호가 나옵니다. x &lt;- LETTERS[1:5] for (i in seq_along(x)) { print(x[i]) } #&gt; [1] &quot;A&quot; #&gt; [1] &quot;B&quot; #&gt; [1] &quot;C&quot; #&gt; [1] &quot;D&quot; #&gt; [1] &quot;E&quot; 주의할 점은 for 함수에서 사용된 변수 i는 이미 다른 곳에서 변수로 사용하는 경우 조심하여야 합니다. 변수 i의 값이 for 함수를 사용하면서 변경되기 때문입니다. # for 함수에서 사용된 아이템 변수 i는 변함 i &lt;- 55 print(i) #&gt; [1] 55 for (i in 1:3) { print(paste0(i, &quot;입니다~&quot;)) } #&gt; [1] &quot;1입니다~&quot; #&gt; [1] &quot;2입니다~&quot; #&gt; [1] &quot;3입니다~&quot; print(i) #&gt; [1] 3 for 함수를 반복 작업 중에 강제로 종료시키려면 next나 break를 사용합니다. next는 현재 진행중인 반복에서만 나와 다음 반복으로 넘어가는 반면, break는 for() 함수 전체에서 빠져나옵니다. # 3미만이면 이후 명령을 실행하지 않고 다음으로 넘어가고 # 5초과이면 for 반복에서 빠져 나옴 for (i in 1:10) { if (i &lt; 3) { next } print(i) if (i &gt;= 5) { break } } #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 for 함수 내에서 산출된 결과를 저장할 변수(아래 예제에서는 out)는 사전에 정의하여야 에러가능성도 낮고 속도도 빨라집니다. means &lt;- c(1, 30, 50) sds &lt;- c(1, 2, 3) out &lt;- vector(&quot;list&quot;, length(means)) for (i in seq_along(means)) { out[[i]] &lt;- rnorm(5, means[[i]], sds[[i]]) } print(out) #&gt; [[1]] #&gt; [1] 0.883 1.183 2.281 -0.727 2.690 #&gt; #&gt; [[2]] #&gt; [1] 31.0 35.1 31.1 30.5 27.9 #&gt; #&gt; [[3]] #&gt; [1] 53.9 52.5 49.8 47.6 47.8 for 반복문 안에 다시 for 반복문을 사용할 수 있습니다. 참고로 seq_along(x) == seq_len(length(x)) 입니다. x &lt;- matrix(1:6, nrow = 2, ncol = 3) for (i in seq_len(nrow(x))) { for (j in seq_len(ncol(x))) { print(x[i, j]) } } #&gt; [1] 1 #&gt; [1] 3 #&gt; [1] 5 #&gt; [1] 2 #&gt; [1] 4 #&gt; [1] 6 "],
["while.html", "4.5 while()", " 4.5 while() while() 함수는 for() 함수와 유사합니다. 차이점은 while()이 for()보다 더 유연하다는 점입니다. while은 조건을 만족하는 한 계속 반복합니다. while (조건문) {반복 실행} i &lt;- 1 while (i &lt; 3) { print(i) i &lt;- i + 1 } #&gt; [1] 1 #&gt; [1] 2 count &lt;- 3 while (count &lt;= 5) { print(c(count, count - 1, count - 2)) count &lt;- count + 1 } #&gt; [1] 3 2 1 #&gt; [1] 4 3 2 #&gt; [1] 5 4 3 set.seed(123) x &lt;- 5 while (x &gt;= 3 &amp; x &lt;= 10) { coin &lt;- rbinom(1, 1, 0.5) # 0과 1 무작위로 추출 if (coin == 1) { x &lt;- x + 1 } else { x &lt;- x - 1 } } print(x) #&gt; [1] 11 "],
["repeat.html", "4.6 repeat()", " 4.6 repeat() repeat() 함수는 for()나 while()처럼 반복적인 작업에 사용되는 함수이고, while() 보다 더 유연하다는 점이 차이점입니다. repeat 함수는 break 함수를 만날때까지 계속 반복합니다. 따라서 무한 루프에서 벗어나기 위해서는 break 함수를 반드시 포함해야 합니다. repeat { 반복 실행 if (조건) { break } } # 1 ~ 5까지 출력 (x가 6이되면 반복 종료) x &lt;- 1 repeat { print(x) x &lt;- x + 1 if (x == 6) { break } } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 "],
["r-기본-함수.html", "5 R 기본 함수 ", " 5 R 기본 함수 "],
["r-수학-함수.html", "5.1 R 수학 함수", " 5.1 R 수학 함수 5.1.1 abs() abs(x)는 x의 절대값을 반환합니다. abs(-123) #&gt; [1] 123 5.1.2 ceiling() ceiling(x)는 x보다 큰 수 중 가장 작은 정수를 반환합니다. ceiling(2.5) #&gt; [1] 3 ceiling(-2.5) #&gt; [1] -2 5.1.3 floor() floor(x)는 x보다 작은 수 중 가장 큰 정수를 반환합니다. floor(2.5) #&gt; [1] 2 floor(-2.5) #&gt; [1] -3 5.1.4 trunc() trunc(x)는 0과 x사이의 가장 큰 정수를 반환합니다. trunc(2.5) #&gt; [1] 2 trunc(-2.5) #&gt; [1] -2 5.1.5 round() ‘round(x, digits = n)’는 x를 소수점 n+1 자리에서 반올림하여 소수점 n번째 자리까지 반환합니다. 만일 digits의 값이 음수이면 10n-1 자리에서 반올림하여 0을 10n 자리까지 만들어 반환합니다. digits 인자의 기본값은 0입니다. R의 반올림 함수는 국제표준(IEEE 754:2008, ISO/IEC/IEEE 60559:2011)을 따르고 있습니다. 따라서 Excel의 반올림 함수와는 다른 결과 값을 보여줍니다. 예를 들면 Excel에서 =round(2.5, 0)을 하면 3이 나오지만, R에서는 round(2.5, digits = 0)을 하게 되면 2가 나오게 됩니다. 이는 위 부동소숫점 실수와 관련된 국제표준에서 반올림의 모드로 제시된 5가지 방법 중 짝수로 반올림(round to nearest, ties to even)를 기본모드로 선택하였기 때문입니다. ’짝수로 반올림’ 모드는 ‘은행원의 반올림’, ’오사오입’이라고도 불리우는 방법으로 반올림으로 인한 오류의 기대값을 0으로 하는 효과가 있습니다. 이 방법은 가장 가까운 표현 가능한 숫자로 반올림하되, 원래 값이 가능한 숫자 두 개의 중간에 걸쳐 있으면 둘 중 가수부의 마지막 자리가 짝수인 값으로 반올림합니다. 예를 들면 52.5는 52, 51.5는 52로 반올림합니다. round(.5 + -3:4) #&gt; [1] -2 -2 0 0 2 2 4 4 round(2.2579, digits = 2) #&gt; [1] 2.26 round(2578.23, digits = -2) #&gt; [1] 2600 5.1.6 signif() signif(x, digits = n)는 지정한 유효숫자(significant digits)인 n만큼 자리수를 만들어 반올림 합니다. digits 인자의 기본값은 6입니다. 숫자들의 열을 깔끔하게 맞추고자 할 때 많이 사용합니다. signif(3.141593, digits = 3) #&gt; [1] 3.14 signif(23.593, digits = 3) #&gt; [1] 23.6 5.1.7 sqrt() sqrt(x)는 x의 제곱근을 반환합니다. sqrt(9) #&gt; [1] 3 5.1.8 로그함수 log(x)는 밑이 e인 x의 자연로그값을 반환합니다. log10(x)은 밑이 10인 x의 상용로그값을 반환합니다. log2(x)는 밑이 2인 x의 이진로그값을 반환합니다. log(x, base) 밑이 base인 x의 로그값을 반환합니다. log1p(x)는 밑이 e인 x+1의 자연로그값을 반환합니다. log(3) #&gt; [1] 1.1 log10(3) #&gt; [1] 0.477 log2(3) #&gt; [1] 1.58 log(3, 5) #&gt; [1] 0.683 log(0) #&gt; [1] -Inf log1p(0) #&gt; [1] 0 5.1.9 exp() exp(x)는 상수 e를 x만큼 제곱한 값을 반환합니다. expm1(x)는 상수 e를 x만큼 제곱한 값에서 1을 뺀 값을 반환합니다. exp(3) #&gt; [1] 20.1 exp(log(3)) #&gt; [1] 3 expm1(3) #&gt; [1] 19.1 5.1.10 삼각함수 cos(x)는 x 라디안 각도의 코사인 값을 반환한다. sin(x)는 x 라디안 각도의 사인 값을 반환한다. tan(x)는 x 라디안 각도의 탄젠트 값을 반환한다. acos(x), asin(x), atan(x), atan2(x)는 역삼각함수입니다. cospi(x), sinpi(x), tanpi(x) 는 pi*x의 삼각함수입니다. 입력이 pi의 배수일 때 정밀한 계산을 위해 사용합니다. sin(pi) #&gt; [1] 1.22e-16 sin(1) #&gt; [1] 0.841 sinpi(3) #&gt; [1] 0 asin(1) #&gt; [1] 1.57 # 사인 곡선 (Sign Curve) x &lt;- seq(-10, 10, 0.1) plot(x, sin(x), type = &quot;l&quot;, col = &quot;blue&quot;, ylab = &quot;&quot;, xlab = &quot;&quot;, main = &quot;삼각함수 그래프&quot;) lines(x, cos(x), type = &quot;l&quot;, col = &quot;red&quot;) legend(&quot;topleft&quot;, c(&quot;sin(x)&quot;, &quot;cos(x)&quot;), fill=c(&quot;blue&quot;, &quot;red&quot;)) # 삼각함수 그래프 x &lt;- seq(0, 2*pi, 0.1) plot(x, sin(x), type = &quot;l&quot;, col = &quot;blue&quot;, ylab = &quot;&quot;, xlab = &quot;&quot;, main = &quot;사인 곡선&quot;) 5.1.11 누적함수 cumsum(x) x 벡터의 누적 합 벡터를 반환합니다. cumprod(x) x 벡터의 누적 곱 벡터를 반환합니다. cummax(x) x 벡터의 누적 최대값 벡터를 반환합니다. cummin(x) x 벡터의 누적 최소값 벡터를 반환합니다. cumsum(1:10) #&gt; [1] 1 3 6 10 15 21 28 36 45 55 cumprod(1:9) #&gt; [1] 1 2 6 24 120 720 5040 40320 362880 # 오른쪽으로 숫자를 이동하면서 과거 지나온 숫자를 비교하여 최대 또는 최소값을 반환 (x &lt;- c(3:1, 2:0, 4:2)) #&gt; [1] 3 2 1 2 1 0 4 3 2 cummax(x) #&gt; [1] 3 3 3 3 3 3 4 4 4 cummin(x) #&gt; [1] 3 2 1 1 1 0 0 0 0 5.1.12 sum() sum(x, na.rm = FALSE)는 x벡터의 합계를 반환합니다. sum(1:5) #&gt; [1] 15 sum(1:5, NA) #&gt; [1] NA sum(1:5, NA, na.rm = TRUE) #&gt; [1] 15 5.1.13 diff() diff(x, lag = 1, differences = 1)는 두 수의 차이값을 반환합니다. lag 인수는 두 수의 간격을 나타냅니다. lag = 2이면 두 칸 간격의 두 수 차이입니다. differences 인수는 차분의 차수입니다. differences = 2이면 차분을 두번한 값을 반환합니다. x &lt;- c(1, 5, 10, 16, 23) diff(x) # 5-1, 10-5, ... #&gt; [1] 4 5 6 7 diff(x, lag = 2) # 10-1, 16-5, ... #&gt; [1] 9 11 13 diff(x, differences = 2) # diff(diff(x)), (10-5)-(5-1), ... #&gt; [1] 1 1 1 5.1.14 prod() prod(x, na.rm = FALSE)는 x 벡터의 곱을 반환합니다. prod(2, 3, 5) # 2*3*5 #&gt; [1] 30 prod(c(2, 3, 5, NA), na.rm = TRUE) #&gt; [1] 30 prod(1:5) # 1*2*3*4*5 #&gt; [1] 120 gamma(6) # 1*2*3*4*5 #&gt; [1] 120 factorial(5) # 1*2*3*4*5 #&gt; [1] 120 5.1.15 gamma(), factorial() 감마함수(gamma function)는 오일러(Leonhard Euler)가 정수만 적용되는 n!을 실수로 확장하기 위해 제안한 함수입니다. gamma(x)는 x-1의 계승값을 반환합니다. 즉 gamma(x)는 factorial(x-1)과 동일합니다. factorial(x)는 x의 계승값을 반환합니다. gamma(6) #&gt; [1] 120 factorial(5) #&gt; [1] 120 gamma(5.32) #&gt; [1] 39.3 factorial(4.32) #&gt; [1] 39.3 # lgamma()는 gamma()의 결과값에 자연로그를 적용하는 함수 lgamma(6) #&gt; [1] 4.79 log(gamma(6)) #&gt; [1] 4.79 # lfactorial()은 factorial()의 결과값에 자연로그를 적용하는 함수 lfactorial(5) #&gt; [1] 4.79 log(factorial(5)) #&gt; [1] 4.79 lgamma(5+1) #&gt; [1] 4.79 gamma() 함수와 연관된 함수는 lgamma() 외에도 psigamma(x, deriv = 0), digamma(x), trigamma(x)가 있습니다. 5.1.16 beta() 베타함수는 감마함수를 만든 오일러가 만든 함수입니다. 감마보다 먼저 만들어진 함수라서 알파, 베타, 감마의 순서에 따라 베타함수로 이름이 지어졌습니다. 베타함수는 이항계수의 일반화라고 할 수 있습니다. beta(2, 5) #&gt; [1] 0.0333 5.1.17 choose() choose(n, k)는 n개에서 순서에 상관없이 k개를 뽑는 경우의 수를 반환합니다. 수식은 \\(n!/(n-k)!k!\\) 입니다. choose(5, 2) #&gt; [1] 10 # 로또 확률 (45개 중 순서에 상관없이 6개 뽑기) choose(45, 6) #&gt; [1] 8145060 5.1.18 복소수 함수 R에서는 복소수 관련 연산이나 함수를 지원합니다. Re(x)는 복소수 x의 실수(Real) 부분을 반환합니다. Im(x)는 복소수 x의 허수(Imaginary) 부분을 반환합니다. Mod(x)는 복소수 x의 절대값(modulus)을 반환합니다. Arg(x)는 복소수 x의 편각(argument)을 반환합니다. Conj(x)는 복소수 x의 공액 복소수(허수부의 부호만 바뀐 복소수)를 반환합니다. x &lt;- 2 + 3i Re(x) #&gt; [1] 2 Im(x) #&gt; [1] 3 Mod(x) #&gt; [1] 3.61 Arg(x) #&gt; [1] 0.983 Conj(x) #&gt; [1] 2-3i 5.1.19 집합 함수 union(x, y)는 x와 y의 합집합을 반환합니다. intersect(x, y)는 x와 y의 교집합을 반환합니다. setdiff(x, y)는 x에 있고 y에는 없는 (x-y)차집합을 반환합니다. setequal(x, y)는 x와 y가 같은지 비교검사 결과를 반환합니다. is.element(el, set)는 el에 있는 각 원소들이 set집합에 포함되는지를 검사합니다. x %in% y와 동일합니다. set.seed(123) (x &lt;- c(sort(sample(1:20, 9)), NA)) #&gt; [1] 2 3 5 6 10 11 14 15 19 NA (y &lt;- c(sort(sample(3:23, 7)), NA)) #&gt; [1] 5 7 10 11 12 16 22 NA union(x, y) # 합집합 #&gt; [1] 2 3 5 6 10 11 14 15 19 NA 7 12 16 22 intersect(x, y) # 교집합 #&gt; [1] 5 10 11 NA setdiff(x, y) # 차집합(x-y) #&gt; [1] 2 3 6 14 15 19 setdiff(y, x) # 차집합(y-x) #&gt; [1] 7 12 16 22 setequal(x, y) # 비교 #&gt; [1] FALSE is.element(x, y) #&gt; [1] FALSE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE TRUE x %in% y # is.element(x, y)와 동일 #&gt; [1] FALSE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE TRUE all(is.element(x, y)) # x가 y에 모두 포함되어 있으면 TRUE #&gt; [1] FALSE 5.1.20 푸리에 함수 fft(x, inverse = FALSE)는 x의 고속 푸리에 변환 값을 반환합니다. mvfft(x, inverse = FALSE)는 행렬 x의 각 열의 고속 푸리에 변환 값을 반환합니다. filter(x, filter)는 시계열에 선형 필터를 적용합니다. convolve(x, y) (x &lt;- matrix(c(1, 2, 3, 2, 20, 26, 3, 26, 38), nrow = 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 2 20 26 #&gt; [3,] 3 26 38 fft(x) #&gt; [,1] [,2] [,3] #&gt; [1,] 121.0+ 0.0i -51.5+16.5i -51.5-16.5i #&gt; [2,] -51.5+16.5i 19.0-13.9i 28.0- 0.0i #&gt; [3,] -51.5-16.5i 28.0+ 0.0i 19.0+13.9i mvfft(x) #&gt; [,1] [,2] [,3] #&gt; [1,] 6.0+0.00i 48+0.0i 67+ 0.0i #&gt; [2,] -1.5+0.87i -21+5.2i -29+10.4i #&gt; [3,] -1.5-0.87i -21-5.2i -29-10.4i x &lt;- 1:5 filter(x, rep(1, 3), method=&quot;recursive&quot;) #&gt; Time Series: #&gt; Start = 1 #&gt; End = 5 #&gt; Frequency = 1 #&gt; [1] 1 3 7 15 30 5.1.21 수치해석 함수 polyroot 근구하기 uniroot D 미분 integrate 적분 "],
["r-행렬-함수.html", "5.2 R 행렬 함수", " 5.2 R 행렬 함수 5.2.1 t() t(x)는 행렬 x의 전치행렬(행과 열이 서로 바뀜)을 반환합니다. (x &lt;- matrix(1:12, 3, 4)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 t(x) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 5.2.2 diag() diag(x = 1, nrow, ncol, names = TRUE)는 대각행렬을 반환합니다. # 주대각선의 원소가 모두 1인(단위행렬) 3x3 대각행렬 diag(3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 0 0 #&gt; [2,] 0 1 0 #&gt; [3,] 0 0 1 # 주대각선의 원소가 모두 10인 3x4 대각행렬 diag(10, 3, 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 10 0 0 0 #&gt; [2,] 0 10 0 0 #&gt; [3,] 0 0 10 0 # 주대각선의 원소를 지정한 대각행렬 diag(c(2, 5, 3, 1)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 0 0 0 #&gt; [2,] 0 5 0 0 #&gt; [3,] 0 0 3 0 #&gt; [4,] 0 0 0 1 # 행렬 x의 대각행렬 (x = matrix(c(1,3,-2, 5, 7, -3, 1, 0, 1), 3, 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 1 #&gt; [2,] 3 7 0 #&gt; [3,] -2 -3 1 diag(x) #&gt; [1] 1 7 1 5.2.3 %*% x %*% y는 행렬 x와 행렬 y의 곱셈 결과를 반환합니다. (x &lt;- 1:4) #&gt; [1] 1 2 3 4 (y &lt;- diag(x)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 0 0 0 #&gt; [2,] 0 2 0 0 #&gt; [3,] 0 0 3 0 #&gt; [4,] 0 0 0 4 (z &lt;- matrix(1:12, ncol = 3, nrow = 4)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 x %*% x #&gt; [,1] #&gt; [1,] 30 y %*% z #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 4 12 20 #&gt; [3,] 9 21 33 #&gt; [4,] 16 32 48 y %*% x #&gt; [,1] #&gt; [1,] 1 #&gt; [2,] 4 #&gt; [3,] 9 #&gt; [4,] 16 x %*% z #&gt; [,1] [,2] [,3] #&gt; [1,] 30 70 110 5.2.4 outer() outer(x, y, FUN = \"*\", ...)는 두 벡터 또는 배열의 외적(outer product)를 반환합니다. 외적이란 x에 y의 전치행렬을 곱한 결과입니다. outer(x, y)는 x %*% t(y)와 동일하며, x%o%y와 동일합니다. (x &lt;- 1:4) #&gt; [1] 1 2 3 4 (y &lt;- 5:8) #&gt; [1] 5 6 7 8 outer(x, y) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 5 6 7 8 #&gt; [2,] 10 12 14 16 #&gt; [3,] 15 18 21 24 #&gt; [4,] 20 24 28 32 x %*% t(y) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 5 6 7 8 #&gt; [2,] 10 12 14 16 #&gt; [3,] 15 18 21 24 #&gt; [4,] 20 24 28 32 x%o%y #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 5 6 7 8 #&gt; [2,] 10 12 14 16 #&gt; [3,] 15 18 21 24 #&gt; [4,] 20 24 28 32 outer(x, y, FUN = \"*\", ...)에서 FUN = \"*\"로 인해 곱셈을 합니다. 만일 기본값인 *을 +로 변경하면 덧셈을 하게 됩니다. outer(x, y, FUN = &quot;+&quot;) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 6 7 8 9 #&gt; [2,] 7 8 9 10 #&gt; [3,] 8 9 10 11 #&gt; [4,] 9 10 11 12 5.2.5 solve() solve(a, b, ...)는 수식 a %*% x = b에서 x를 구하여 반환합니다. 만일 b를 지정하지 않으면 a의 역행렬을 반환합니다. (a &lt;- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 1 #&gt; [2,] 3 7 0 #&gt; [3,] -2 -3 1 (b &lt;- c(2, -1, 1)) #&gt; [1] 2 -1 1 # ax=b에서 x를 구하여 반환 solve(a, b) #&gt; [1] -5 2 -3 # a의 역행렬을 반환환 solve(a) #&gt; [,1] [,2] [,3] #&gt; [1,] -2.33 2.67 2.33 #&gt; [2,] 1.00 -1.00 -1.00 #&gt; [3,] -1.67 2.33 2.67 5.2.6 rowSums() rowSums(x, na.rm = FALSE, dims = 1)는 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 행 합계를 반환합니다. (x &lt;- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 1 #&gt; [2,] 3 7 0 #&gt; [3,] -2 -3 1 rowSums(x) #&gt; [1] 7 10 -4 a &lt;- 1:5 b &lt;- 1:5*2 c &lt;- 1:5*3 df &lt;- data.frame(a, b, c) df #&gt; a b c #&gt; 1 1 2 3 #&gt; 2 2 4 6 #&gt; 3 3 6 9 #&gt; 4 4 8 12 #&gt; 5 5 10 15 rowSums(df) #&gt; [1] 6 12 18 24 30 5.2.7 colSums() colSums (x, na.rm = FALSE, dims = 1)은 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 열 합계를 반환합니다. (x &lt;- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 1 #&gt; [2,] 3 7 0 #&gt; [3,] -2 -3 1 colSums(x) #&gt; [1] 2 9 2 a &lt;- 1:5 b &lt;- 1:5*2 c &lt;- 1:5*3 df &lt;- data.frame(a, b, c) df #&gt; a b c #&gt; 1 1 2 3 #&gt; 2 2 4 6 #&gt; 3 3 6 9 #&gt; 4 4 8 12 #&gt; 5 5 10 15 colSums(df) #&gt; a b c #&gt; 15 30 45 5.2.8 rowMeans() rowMeans(x, na.rm = FALSE, dims = 1)는 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 행 평균을 반환합니다. (x &lt;- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 1 #&gt; [2,] 3 7 0 #&gt; [3,] -2 -3 1 rowMeans(x) #&gt; [1] 2.33 3.33 -1.33 a &lt;- 1:5 b &lt;- 1:5*2 c &lt;- 1:5*3 df &lt;- data.frame(a, b, c) df #&gt; a b c #&gt; 1 1 2 3 #&gt; 2 2 4 6 #&gt; 3 3 6 9 #&gt; 4 4 8 12 #&gt; 5 5 10 15 rowMeans(df) #&gt; [1] 2 4 6 8 10 5.2.9 colMeans() colMeans (x, na.rm = FALSE, dims = 1)은 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 열 합계를 반환합니다. (x &lt;- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 1 #&gt; [2,] 3 7 0 #&gt; [3,] -2 -3 1 colMeans(x) #&gt; [1] 0.667 3.000 0.667 a &lt;- 1:5 b &lt;- 1:5*2 c &lt;- 1:5*3 df &lt;- data.frame(a, b, c) df #&gt; a b c #&gt; 1 1 2 3 #&gt; 2 2 4 6 #&gt; 3 3 6 9 #&gt; 4 4 8 12 #&gt; 5 5 10 15 colMeans(df) #&gt; a b c #&gt; 3 6 9 5.2.10 nrow(), ncol() nrow(x)는 행의 갯수를 반환합니다. ncol(x)는 열의 갯수를 반환합니다. NROW(x)는 행의 갯수를 반환합니다. (벡터 계산 가능) NCOL(x)는 열의 갯수를 반환합니다. (벡터 계산 가능) x &lt;- matrix(1:12, 3, 4) nrow(x) #&gt; [1] 3 ncol(x) #&gt; [1] 4 NROW(x) #&gt; [1] 3 NCOL(x) #&gt; [1] 4 (x &lt;- array(1:24, dim = c(3,4,2))) # 3행*4열의 3차원 배열 #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 13 16 19 22 #&gt; [2,] 14 17 20 23 #&gt; [3,] 15 18 21 24 nrow(x) #&gt; [1] 3 ncol(x) #&gt; [1] 4 NROW와 NCOL은 행렬이 아닌 벡터도 계산합니다. x &lt;- 1:12 nrow(x) #&gt; NULL NROW(x) #&gt; [1] 12 ncol(x) #&gt; NULL NCOL(x) #&gt; [1] 1 5.2.11 det() det(x)는 행렬 x의 행렬식을 구하여 반환합니다. 행렬식은 정방행렬(nxn 행렬)인 경우에만 구할 수 있습니다. \\(det \\begin{pmatrix}a&amp;b\\\\c&amp;d\\end{pmatrix} = ad-bc\\) (x &lt;- matrix(1:4, nrow = 2)) #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 det(x) #&gt; [1] -2 5.2.12 eigen() eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE)는 행렬 x의 고유값과 고유벡터를 반환합니다. 고유값과 고유벡터는 행렬 A에 대하여 \\(Av = \\lambda v\\) 등식을 만족하는 상수와 열벡터입니다. 등식에서 v는 고유벡터이고 \\(\\lambda\\)는 고유값입니다. 고유값과 고유벡터는 정방행렬(nxn 행렬)인 경우에만 구할 수 있습니다. (x &lt;- matrix(1:4, nrow = 2)) #&gt; [,1] [,2] #&gt; [1,] 1 3 #&gt; [2,] 2 4 eigen(x) #&gt; eigen() decomposition #&gt; $values #&gt; [1] 5.372 -0.372 #&gt; #&gt; $vectors #&gt; [,1] [,2] #&gt; [1,] -0.566 -0.909 #&gt; [2,] -0.825 0.416 5.2.13 svd() svd(x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)는 행렬 x의 특이값을 분해하여 그 결과를 반환합니다. 고유값 분해는 정방행렬(nxn 행렬)인 경우에만 가능합니다. 이를 직사각행렬(mxn행렬)에서도 가능하게 만든 것이 특이값 분해(SVD: Singular Value Decomposition)입니다. \\(M = UDV^T\\) x &lt;- matrix(c(0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0), byrow = TRUE, nrow = 10) x #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 0 0 0 1 1 0 0 0 #&gt; [2,] 1 0 0 1 1 0 0 0 #&gt; [3,] 0 0 0 1 1 0 0 0 #&gt; [4,] 1 1 1 1 1 1 1 1 #&gt; [5,] 1 1 1 1 1 1 1 1 #&gt; [6,] 1 1 1 1 1 1 1 1 #&gt; [7,] 1 1 1 1 1 1 1 1 #&gt; [8,] 0 0 0 1 1 0 0 0 #&gt; [9,] 0 0 0 1 1 0 0 0 #&gt; [10,] 0 0 0 1 1 0 0 0 x_svd &lt;- svd(x) x_svd #&gt; $d #&gt; [1] 6.06e+00 2.75e+00 8.48e-01 2.84e-16 2.47e-31 4.47e-33 1.64e-49 5.91e-67 #&gt; #&gt; $u #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] -0.153 0.385 0.1692 8.94e-01 -7.18e-16 -1.67e-16 2.78e-17 -5.55e-17 #&gt; [2,] -0.208 0.323 -0.9231 -2.78e-16 -1.18e-17 -9.03e-18 -1.42e-17 -1.61e-18 #&gt; [3,] -0.153 0.385 0.1692 -2.24e-01 -8.64e-01 -6.47e-02 -3.13e-16 3.69e-17 #&gt; [4,] -0.458 -0.197 0.0344 5.55e-17 -6.47e-02 8.64e-01 -2.67e-16 -1.67e-16 #&gt; [5,] -0.458 -0.197 0.0344 0.00e+00 2.16e-02 -2.88e-01 8.16e-01 -3.43e-18 #&gt; [6,] -0.458 -0.197 0.0344 0.00e+00 2.16e-02 -2.88e-01 -4.08e-01 7.07e-01 #&gt; [7,] -0.458 -0.197 0.0344 0.00e+00 2.16e-02 -2.88e-01 -4.08e-01 -7.07e-01 #&gt; [8,] -0.153 0.385 0.1692 -2.24e-01 2.88e-01 2.16e-02 8.51e-17 4.65e-18 #&gt; [9,] -0.153 0.385 0.1692 -2.24e-01 2.88e-01 2.16e-02 8.51e-17 4.65e-18 #&gt; [10,] -0.153 0.385 0.1692 -2.24e-01 2.88e-01 2.16e-02 8.51e-17 4.65e-18 #&gt; #&gt; $v #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] -0.337 -0.169 -0.9262 0.00e+00 0.0000 0.00000 0.00e+00 0.00e+00 #&gt; [2,] -0.303 -0.287 0.1624 7.74e-01 -0.4483 0.01146 0.00e+00 0.00e+00 #&gt; [3,] -0.303 -0.287 0.1624 -6.28e-01 -0.6370 0.01628 0.00e+00 0.00e+00 #&gt; [4,] -0.463 0.530 0.0718 -3.89e-16 0.0181 0.70688 -1.35e-16 0.00e+00 #&gt; [5,] -0.463 0.530 0.0718 -5.00e-16 -0.0181 -0.70688 1.49e-16 0.00e+00 #&gt; [6,] -0.303 -0.287 0.1624 -4.87e-02 0.3618 -0.00925 8.16e-01 8.76e-17 #&gt; [7,] -0.303 -0.287 0.1624 -4.87e-02 0.3618 -0.00925 -4.08e-01 -7.07e-01 #&gt; [8,] -0.303 -0.287 0.1624 -4.87e-02 0.3618 -0.00925 -4.08e-01 7.07e-01 # 특이값 벡터 d의 첫번째와 두번째 값을 이용하여 원래 행렬 구하기 round(x_svd$u[,c(1,2)] %*% diag(x_svd$d[c(1,2)]) %*% t(x_svd$v[,c(1,2)])) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 0 0 0 1 1 0 0 0 #&gt; [2,] 0 0 0 1 1 0 0 0 #&gt; [3,] 0 0 0 1 1 0 0 0 #&gt; [4,] 1 1 1 1 1 1 1 1 #&gt; [5,] 1 1 1 1 1 1 1 1 #&gt; [6,] 1 1 1 1 1 1 1 1 #&gt; [7,] 1 1 1 1 1 1 1 1 #&gt; [8,] 0 0 0 1 1 0 0 0 #&gt; [9,] 0 0 0 1 1 0 0 0 #&gt; [10,] 0 0 0 1 1 0 0 0 5.2.14 qr() qr(x)은 행렬 x의 QR 분해결과를 반환합니다. QR분해는 행렬 A를 \\(A = QR\\)로 분해하는 것입니다. Q는 단위 노름 직교 벡터를 갖는 행렬이고, R은 상삼각행렬입니다. x &lt;- matrix(c(1,2,3, 2,4,6, 3,3,3), nrow=3) x_qr &lt;- qr(x) x_qr #&gt; $qr #&gt; [,1] [,2] [,3] #&gt; [1,] -3.742 -4.811 -7.48 #&gt; [2,] 0.535 1.964 0.00 #&gt; [3,] 0.802 0.989 0.00 #&gt; #&gt; $rank #&gt; [1] 2 #&gt; #&gt; $qraux #&gt; [1] 1.27 1.15 0.00 #&gt; #&gt; $pivot #&gt; [1] 1 3 2 #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;qr&quot; 5.2.15 scale() scale(x, center = TRUE, scale = TRUE)는 행렬이나 벡터 x를 정규화(표준화)한 결과를 반환합니다. 옵션 center는 평균을 의미하며, scale은 표준편차를 의미합니다. x가 벡터일 경우 \\(z = (x-u)/\\sigma\\)를 구해서 반환합니다. center가 FALSE이면 값에서 평균을 빼지 않으며, scale이 FALSE이면 표준편차로 나누지 않습니다. # 1~9 벡터를 표준화하기 (평균을 빼고 표준편차로 나눔) (x &lt;- 1:9) #&gt; [1] 1 2 3 4 5 6 7 8 9 scale(x) #&gt; [,1] #&gt; [1,] -1.461 #&gt; [2,] -1.095 #&gt; [3,] -0.730 #&gt; [4,] -0.365 #&gt; [5,] 0.000 #&gt; [6,] 0.365 #&gt; [7,] 0.730 #&gt; [8,] 1.095 #&gt; [9,] 1.461 #&gt; attr(,&quot;scaled:center&quot;) #&gt; [1] 5 #&gt; attr(,&quot;scaled:scale&quot;) #&gt; [1] 2.74 x가 행렬일 경우에는 열을 기준으로 평균과 표준편차를 구한 후, 열 기준으로 표준화를 합니다. (x &lt;- matrix(1:9, ncol = 3)) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 scale(x) #&gt; [,1] [,2] [,3] #&gt; [1,] -1 -1 -1 #&gt; [2,] 0 0 0 #&gt; [3,] 1 1 1 #&gt; attr(,&quot;scaled:center&quot;) #&gt; [1] 2 5 8 #&gt; attr(,&quot;scaled:scale&quot;) #&gt; [1] 1 1 1 "],
["r-논리-함수.html", "5.3 R 논리 함수", " 5.3 R 논리 함수 5.3.1 any() any(..., na.rm = FALSE)는 주어진 논리 벡터 중에 어느 하나라도 TRUE이면 TRUE를 반환합니다. # 어느 하나라도 0미만 이면 TRUE 반환 (x &lt;- seq(-3, 3, by = 1)) #&gt; [1] -3 -2 -1 0 1 2 3 any(x &lt; 0) #&gt; [1] TRUE if (any(x &lt; 0)) cat(&quot;x는 음수를 포함하고 있습니다\\n&quot;) #&gt; x는 음수를 포함하고 있습니다 5.3.2 all() all(..., na.rm = FALSE)는 주어진 논리 벡터 모두가 TRUE이면 TRUE를 반환합니다. 어느 하나라도 FALSE가 있으면 FALSE를 반환합니다. (x &lt;- seq(-3, 3, by = 1)) #&gt; [1] -3 -2 -1 0 1 2 3 all(x &lt; 0) #&gt; [1] FALSE if (all(x &gt;= -3 )) cat(&quot;x에 포함된 수는 모두 -3 이상입니다\\n&quot;) #&gt; x에 포함된 수는 모두 -3 이상입니다 5.3.3 which() which(x, arr.ind = FALSE, useNames = TRUE)는 벡터(또는 배열) x에서 TRUE인 것의 위치를 반환합니다. x가 배열인 경우 arr.ind = TRUE이면 배열형태의 위치를 반환합니다. # 벡터 위치 반환 (x &lt;- 5:10) #&gt; [1] 5 6 7 8 9 10 which(x == 7) #&gt; [1] 3 x[which(x == 7)] #&gt; [1] 7 # 배열 위치 반환 x &lt;- 5:16 dim(x) &lt;- c(2, 2, 3); x # x를 2x2 행렬의 3층 배열로 만들기 #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 5 7 #&gt; [2,] 6 8 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 9 11 #&gt; [2,] 10 12 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] #&gt; [1,] 13 15 #&gt; [2,] 14 16 which(x == 15) # 벡터형태의 위치 반환 #&gt; [1] 11 which(x == 15, arr.ind = TRUE) # 배열형태의 위치 반환 #&gt; dim1 dim2 dim3 #&gt; [1,] 1 2 3 # 행렬 위치 반환 (배열과 유사) x &lt;- matrix(5:16, 3, 4); x #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 5 8 11 14 #&gt; [2,] 6 9 12 15 #&gt; [3,] 7 10 13 16 which(x %% 3 == 0) # 벡터형태의 위치 반환 #&gt; [1] 2 5 8 11 which(x %% 3 == 0, arr.ind = TRUE) # 행렬형태의 위치 반환 #&gt; row col #&gt; [1,] 2 1 #&gt; [2,] 2 2 #&gt; [3,] 2 3 #&gt; [4,] 2 4 # 데이터 프레임 위치 반환 str(women) # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드) #&gt; &#39;data.frame&#39;: 15 obs. of 2 variables: #&gt; $ height: num 58 59 60 61 62 63 64 65 66 67 ... #&gt; $ weight: num 115 117 120 123 126 129 132 135 139 142 ... which(women$height &lt; 60) #&gt; [1] 1 2 women[which(women$height &lt; 60),] #&gt; height weight #&gt; 1 58 115 #&gt; 2 59 117 5.3.4 which.min() which.min(x)는 벡터 x의 최소값 위치를 반환합니다. # 벡터 x &lt;- c(1:4, 0:5, 11); x #&gt; [1] 1 2 3 4 0 1 2 3 4 5 11 which.min(x) #&gt; [1] 5 # 데이터프레임 str(women) # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드) #&gt; &#39;data.frame&#39;: 15 obs. of 2 variables: #&gt; $ height: num 58 59 60 61 62 63 64 65 66 67 ... #&gt; $ weight: num 115 117 120 123 126 129 132 135 139 142 ... which.min(women$weight) #&gt; [1] 1 women[which.min(women$weight)] #&gt; height #&gt; 1 58 #&gt; 2 59 #&gt; 3 60 #&gt; 4 61 #&gt; 5 62 #&gt; 6 63 #&gt; 7 64 #&gt; 8 65 #&gt; 9 66 #&gt; 10 67 #&gt; 11 68 #&gt; 12 69 #&gt; 13 70 #&gt; 14 71 #&gt; 15 72 5.3.5 which.max() which.max(x)는 벡터 x의 최대값 위치를 반환합니다. # 벡터 x &lt;- c(1:4, NA, 11, 0:5); x #&gt; [1] 1 2 3 4 NA 11 0 1 2 3 4 5 which.max(x) #&gt; [1] 6 # 데이터프레임 str(women) # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드) #&gt; &#39;data.frame&#39;: 15 obs. of 2 variables: #&gt; $ height: num 58 59 60 61 62 63 64 65 66 67 ... #&gt; $ weight: num 115 117 120 123 126 129 132 135 139 142 ... which.max(women$weight) #&gt; [1] 15 women[which.max(women$weight),] #&gt; height weight #&gt; 15 72 164 5.3.6 isTRUE() isTRUE(x)는 x가 TRUE이면 TRUE를 반환합니다. 유사한 것으로 isFALSE(x)가 있습니다. x &lt;- TRUE isTRUE(x) #&gt; [1] TRUE isFALSE(x) #&gt; [1] FALSE "],
["r-반복-함수.html", "5.4 R 반복 함수", " 5.4 R 반복 함수 5.4.1 apply() apply(X, MARGIN, FUN, …)는 X를 입력받아 행 또는 열 방향으로 함수를 적용하여 결과값을 반환합니다. MARGIN 인수가 1이면 행 방향으로, 2이면 열 방향으로 연산이 됩니다. apply 함수에 입력하는 데이터(X)는 배열, 매트릭스만 가능하고, 만일 데이터프레임이 모두 같은 데이터 타입이면 가능합니다. 반환되는 값은 벡터나 행렬입니다. (x &lt;- matrix(1:12, c(3,4))) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 apply(x, 1, mean) # 행 방향으로 평균 #&gt; [1] 5.5 6.5 7.5 apply(x, 2, mean, na.rm = TRUE) # 열 방향으로 평균, mean함수 옵션 추가 #&gt; [1] 2 5 8 11 벡터는 apply에 입력데이터로 사용할 수 없습니다(에러 발생). 만일 벡터를 사용하고자 한다면 배열로 변환하여 사용하여야 합니다. x &lt;- 1:12 dim(x) &lt;- c(1, length(x)); x # 벡터를 배열로 변환 #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #&gt; [1,] 1 2 3 4 5 6 7 8 9 10 11 12 apply(x, 1, mean) #&gt; [1] 6.5 함수는 사용자 정의 함수를 만들어서 사용할 수 있습니다. (x &lt;- matrix(1:12, c(3,4))) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 apply(x, 2, function(x) {x*2}) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 8 14 20 #&gt; [2,] 4 10 16 22 #&gt; [3,] 6 12 18 24 # 행방향으로 하면 행과 열이 바뀝니다. apply(x, 1, function(x) {x}) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 apply(x, 1, function(x) {x*2}) #&gt; [,1] [,2] [,3] #&gt; [1,] 2 4 6 #&gt; [2,] 8 10 12 #&gt; [3,] 14 16 18 #&gt; [4,] 20 22 24 데이터프레임도 데이터가 모두 같은 타입이라면 apply를 적용할 수 있습니다. R의 기본 데이터셋인 iris에서 Factor 타입인 Species를 제거한 후 apply에 사용하도록 하겠습니다. str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... x &lt;- iris[, -5]; str(x) #&gt; &#39;data.frame&#39;: 150 obs. of 4 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... apply(x, 2, mean, na.rm = TRUE) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 5.84 3.06 3.76 1.20 apply(x, 2, function(x) {median(x*2-1, na.rm = TRUE)}) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 10.6 5.0 7.7 1.6 5.4.2 lapply() lapply(X, FUN, …)는 X를 입력받아 함수를 적용하여 결과값을 반환합니다. lapply 함수에 입력하는 데이터(X)는 벡터, 리스트 등도 가능하고, 반환되는 값은 리스트입니다. apply는 X의 행이나 열 방향의 데이터가 한꺼번에 함수로 전달되는 반면에, lapply는 X의 데이터 요소가 하나 하나 함수로 전달됩니다. 행렬이나 배열의 요소는 기본적으로 벡터의 요소와 같은 방식이기 때문에 값이 하나 하나 전달됩니다. # 아래와 같이 코드를 실행하면 x의 평균이 반환되지 않습니다. # x값이 하나 하나 mean 함수에 전달되어 각각 계산되기 때문입니다. x &lt;- matrix(1:6, c(2,3)) lapply(x, mean, na.rm = TRUE) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] 4 #&gt; #&gt; [[5]] #&gt; [1] 5 #&gt; #&gt; [[6]] #&gt; [1] 6 lapply는 리스트로 반환이 됩니다. 이를 벡터로 변환하고자 한다면 unlist 함수를 적용합니다. x &lt;- 1:3 lapply(x, function(x) {x*2+1}) # 리스트 형태로 반환 #&gt; [[1]] #&gt; [1] 3 #&gt; #&gt; [[2]] #&gt; [1] 5 #&gt; #&gt; [[3]] #&gt; [1] 7 unlist(lapply(x, function(x) {x*2+1})) # 리스트를 벡터로 변환하여 반환 #&gt; [1] 3 5 7 데이터프레임도 lapply 함수에 입력데이터로 사용 가능합니다. 데이터프레임의 각 요소 즉 각 변수별로 한꺼번에 함수에 전달됩니다. str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... lapply(iris, mean, na.rm = TRUE) #&gt; Warning in mean.default(X[[i]], ...): argument is not numeric or logical: #&gt; returning NA #&gt; $Sepal.Length #&gt; [1] 5.84 #&gt; #&gt; $Sepal.Width #&gt; [1] 3.06 #&gt; #&gt; $Petal.Length #&gt; [1] 3.76 #&gt; #&gt; $Petal.Width #&gt; [1] 1.2 #&gt; #&gt; $Species #&gt; [1] NA 리스트가 입력되면 리스트의 각 요소가 한꺼번에 함수에 전달됩니다. 예를 들어 mean함수를 사용하면 리스트 각 요소별 평균값을 반환합니다. x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)) x #&gt; $a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $beta #&gt; [1] 0.0498 0.1353 0.3679 1.0000 2.7183 7.3891 20.0855 #&gt; #&gt; $logic #&gt; [1] TRUE FALSE FALSE TRUE lapply(x, mean) #&gt; $a #&gt; [1] 5.5 #&gt; #&gt; $beta #&gt; [1] 4.54 #&gt; #&gt; $logic #&gt; [1] 0.5 lapply(x, quantile, probs = (1:3)/4) #&gt; $a #&gt; 25% 50% 75% #&gt; 3.25 5.50 7.75 #&gt; #&gt; $beta #&gt; 25% 50% 75% #&gt; 0.252 1.000 5.054 #&gt; #&gt; $logic #&gt; 25% 50% 75% #&gt; 0.0 0.5 1.0 5.4.3 sapply() sapply(X, FUN, …, simplify = TRUE, USE.NAMES = TRUE)는 단순화된(simplify) lapply 함수라 할 수 있습니다. lapply는 리스트 형태로 반환되기 때문에 사용하기 불편한 점이 있는데 sapply는 기본적으로 벡터나 행렬 형태로 반환합니다. 만일 옵션 simplify = FALSE이면 lapply와 동일하게 리스트 형태로 반환됩니다. x &lt;- 1:3 sapply(x, function(x) {x*2+1}) #&gt; [1] 3 5 7 str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... sapply(iris, mean, na.rm = TRUE) #&gt; Warning in mean.default(X[[i]], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 5.84 3.06 3.76 1.20 NA x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)) x #&gt; $a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 #&gt; #&gt; $beta #&gt; [1] 0.0498 0.1353 0.3679 1.0000 2.7183 7.3891 20.0855 #&gt; #&gt; $logic #&gt; [1] TRUE FALSE FALSE TRUE sapply(x, mean) #&gt; a beta logic #&gt; 5.50 4.54 0.50 sapply(x, quantile, probs = (1:3)/4) #&gt; a beta logic #&gt; 25% 3.25 0.252 0.0 #&gt; 50% 5.50 1.000 0.5 #&gt; 75% 7.75 5.054 1.0 5.4.4 vapply() vapply(X, FUN, FUN.VALUE, …, USE.NAMES = TRUE)는 sapply와 유사합니다. 차이점은 반환되는 결과의 양식을 지정할 수 있습니다. str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # sapply로 fivenum 출력 sapply(iris[, 1:4], fivenum, na.rm = TRUE) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; [1,] 4.3 2.0 1.00 0.1 #&gt; [2,] 5.1 2.8 1.60 0.3 #&gt; [3,] 5.8 3.0 4.35 1.3 #&gt; [4,] 6.4 3.3 5.10 1.8 #&gt; [5,] 7.9 4.4 6.90 2.5 # vapply로 fivenum 출력, 출력양식 지정 vapply(iris[, 1:4], fivenum, c(&quot;최소값&quot; = 0, &quot;1사분위수&quot; = 0, &quot;중위수&quot; = 0, &quot;3사분위수&quot; = 0, &quot;최대값&quot; = 0), na.rm = TRUE) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 최소값 4.3 2.0 1.00 0.1 #&gt; 1사분위수 5.1 2.8 1.60 0.3 #&gt; 중위수 5.8 3.0 4.35 1.3 #&gt; 3사분위수 6.4 3.3 5.10 1.8 #&gt; 최대값 7.9 4.4 6.90 2.5 5.4.5 tapply() tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)는 요인(factor) 변수를 기준으로 그룹별로 나누어서 함수를 적용합니다. X는 벡터입니다. INDEX는 요인 또는 요인 리스트가 들어가는 인수입니다. 만일 X에 데이터프레임을 넣고 싶으면 by()함수를 쓰면 됩니다. # iris 데이터의 요인변수 Species 별로 평균 구하기 str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... tapply(iris$Sepal.Length, iris$Species, mean, na.rm = TRUE) #&gt; setosa versicolor virginica #&gt; 5.01 5.94 6.59 # 팩터변수가 2개가 되면 교차표가 만들어짐 # x[, -1]은 wool과 tension으로 구성된 데이터프레임 str(x &lt;- warpbreaks) #&gt; &#39;data.frame&#39;: 54 obs. of 3 variables: #&gt; $ breaks : num 26 30 54 25 70 52 51 26 67 18 ... #&gt; $ wool : Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ tension: Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;H&quot;: 1 1 1 1 1 1 1 1 1 2 ... tapply(x$breaks, x[, -1], sum) #&gt; tension #&gt; wool L M H #&gt; A 401 216 221 #&gt; B 254 259 169 # 데이터 무작위 30개 만들어 x에 할당 set.seed(234) x &lt;- c(rnorm(10), runif(10), rnorm(10, 1)) str(x) #&gt; num [1:30] 0.661 -2.053 -1.499 1.471 1.459 ... # 팩터 변수 생성(값 30개) # gl(n, k)는 1부터 n까지 정수로된 팩터 레벨을 k만큼 반복해서 만듬 fac &lt;- gl(3, 10) # factor(rep(1:3, each = 10), levels = 1:3)와 동일 fac #&gt; [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 #&gt; Levels: 1 2 3 tapply(x, fac, mean) #&gt; 1 2 3 #&gt; -0.422 0.606 1.116 tapply(x, fac, range) #&gt; $`1` #&gt; [1] -3.04 1.47 #&gt; #&gt; $`2` #&gt; [1] 0.192 0.883 #&gt; #&gt; $`3` #&gt; [1] 0.0699 2.0163 5.4.6 mapply() mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)는 sapply의 다변량 버전이라 할 수 있습니다. 여러 개의 인자를 입력할 수 있고, 반환하는 값은 리스트, 벡터, 배열 등이 가능합니다. MoreArgs는 함수에 들어갈 또다른 인수 리스트입니다. # rep(1, 4), rep(2, 3), ..., rep(x = 4, times = 1) =&gt; 리스트 반환 mapply(rep, 1:4, 4:1) #&gt; [[1]] #&gt; [1] 1 1 1 1 #&gt; #&gt; [[2]] #&gt; [1] 2 2 2 #&gt; #&gt; [[3]] #&gt; [1] 3 3 #&gt; #&gt; [[4]] #&gt; [1] 4 # rep(1, 3), rep(2, 3), ..., rep(x = 4, times = 3) =&gt; 행렬 반환 mapply(rep, 1:4, 3) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 1 2 3 4 #&gt; [3,] 1 2 3 4 # rep(times = 1, x = 4), rep(times = 2, x = 3), ... mapply(rep, times = 1:4, x = 4:1) #&gt; [[1]] #&gt; [1] 4 #&gt; #&gt; [[2]] #&gt; [1] 3 3 #&gt; #&gt; [[3]] #&gt; [1] 2 2 2 #&gt; #&gt; [[4]] #&gt; [1] 1 1 1 1 # rep(x = 23, times = 1), rep(x = 23, times = 2), ... mapply(rep, 1:4, MoreArgs = list(x = 23)) #&gt; [[1]] #&gt; [1] 23 #&gt; #&gt; [[2]] #&gt; [1] 23 23 #&gt; #&gt; [[3]] #&gt; [1] 23 23 23 #&gt; #&gt; [[4]] #&gt; [1] 23 23 23 23 # sprintf(&quot; %d%s &quot;, 1, &quot;a&quot;), .... mapply(function(i, s) { sprintf(&quot; %d%s &quot;, i, s) }, i = 1:3, s = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; [1] &quot; 1a &quot; &quot; 2b &quot; &quot; 3c &quot; MoreArgs 인수는 여러 개의 데이터를 한꺼번에 함수에 넣어줍니다. 이 것을 사용하지 않으면 데이터가 하나씩 함수에 들어갑니다. sumsq &lt;- function(x, mean = 0, sd = 1) { sum(((x - mean) / sd)^2) } set.seed(123) x &lt;- rnorm(10000) # sumsq(x, mean = 1, sd = 1), sumsq(x, mean = 2, sd = 2), ... mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x)) #&gt; [1] 20019 12517 11124 10635 10408 10285 10210 10162 10128 10104 10087 10073 #&gt; [13] 10063 10054 10047 10042 10037 10033 10030 10027 10025 10023 10021 10019 #&gt; [25] 10018 10017 10015 10014 10013 10013 10012 10011 10011 10010 10009 10009 #&gt; [37] 10009 10008 10008 10007 10007 10007 10006 10006 10006 10006 10006 10005 #&gt; [49] 10005 10005 10005 10005 10004 10004 10004 10004 10004 10004 10004 10004 #&gt; [61] 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 #&gt; [73] 10003 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 #&gt; [85] 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 #&gt; [97] 10002 10002 10001 10001 # 만일 이렇게 mapply(sumsq, mean = 1:100, sd = 1:100, x = x) 하면 # sumsq(x = x[1], mean = 1, sd = 1), ... 이런식으로 계산되어 # 원하는 결과가 나오지 않음. 여기서 x[1]은 -0.560475647임 5.4.7 eapply() eapply(env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE)는 환경(Environment)에 있는 변수나 함수들을 반복 계산해 줍니다. # 새로운 환경 만들기; R에서 전역환경은 .GlobalEnv 임 env &lt;- new.env() env$a &lt;- 10 env$b &lt;- 20:23 env$c &lt;- 30:35 # 전역변수 자료형 확인하기 eapply(env, typeof) #&gt; $a #&gt; [1] &quot;double&quot; #&gt; #&gt; $b #&gt; [1] &quot;integer&quot; #&gt; #&gt; $c #&gt; [1] &quot;integer&quot; # env 환경변수의 각 요소에 2를 곱하기 eapply(env, function(x) {x * 2}) #&gt; $a #&gt; [1] 20 #&gt; #&gt; $b #&gt; [1] 40 42 44 46 #&gt; #&gt; $c #&gt; [1] 60 62 64 66 68 70 5.4.8 by() by(data, INDICES, FUN, …, simplify = TRUE)는 데이터프레임을 위한 tapply라 할 수 있다. 요인(factor) 변수를 기준으로 그룹별로 나누어서 함수를 적용합니다. data는 데이터프레임이나 행렬입니다. INDEX는 요인 또는 요인 리스트가 들어가는 인수입니다. str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... by(iris, iris$Species, summary) #&gt; iris$Species: setosa #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; Min. :4.30 Min. :2.30 Min. :1.00 Min. :0.100 setosa :50 #&gt; 1st Qu.:4.80 1st Qu.:3.20 1st Qu.:1.40 1st Qu.:0.200 versicolor: 0 #&gt; Median :5.00 Median :3.40 Median :1.50 Median :0.200 virginica : 0 #&gt; Mean :5.01 Mean :3.43 Mean :1.46 Mean :0.246 #&gt; 3rd Qu.:5.20 3rd Qu.:3.67 3rd Qu.:1.57 3rd Qu.:0.300 #&gt; Max. :5.80 Max. :4.40 Max. :1.90 Max. :0.600 #&gt; ------------------------------------------------------------ #&gt; iris$Species: versicolor #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; Min. :4.90 Min. :2.00 Min. :3.00 Min. :1.00 setosa : 0 #&gt; 1st Qu.:5.60 1st Qu.:2.52 1st Qu.:4.00 1st Qu.:1.20 versicolor:50 #&gt; Median :5.90 Median :2.80 Median :4.35 Median :1.30 virginica : 0 #&gt; Mean :5.94 Mean :2.77 Mean :4.26 Mean :1.33 #&gt; 3rd Qu.:6.30 3rd Qu.:3.00 3rd Qu.:4.60 3rd Qu.:1.50 #&gt; Max. :7.00 Max. :3.40 Max. :5.10 Max. :1.80 #&gt; ------------------------------------------------------------ #&gt; iris$Species: virginica #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; Min. :4.90 Min. :2.20 Min. :4.50 Min. :1.40 setosa : 0 #&gt; 1st Qu.:6.22 1st Qu.:2.80 1st Qu.:5.10 1st Qu.:1.80 versicolor: 0 #&gt; Median :6.50 Median :3.00 Median :5.55 Median :2.00 virginica :50 #&gt; Mean :6.59 Mean :2.97 Mean :5.55 Mean :2.03 #&gt; 3rd Qu.:6.90 3rd Qu.:3.17 3rd Qu.:5.88 3rd Qu.:2.30 #&gt; Max. :7.90 Max. :3.80 Max. :6.90 Max. :2.50 # 팩터변수가 2개가 되면 그만큼 그룹으로 더 나뉘어짐 # x[, -1]은 wool과 tension으로 구성된 데이터프레임 str(warpbreaks) #&gt; &#39;data.frame&#39;: 54 obs. of 3 variables: #&gt; $ breaks : num 26 30 54 25 70 52 51 26 67 18 ... #&gt; $ wool : Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ tension: Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;H&quot;: 1 1 1 1 1 1 1 1 1 2 ... by(warpbreaks[, 1], warpbreaks[, -1], summary) #&gt; wool: A #&gt; tension: L #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 25.0 26.0 51.0 44.6 54.0 70.0 #&gt; ------------------------------------------------------------ #&gt; wool: B #&gt; tension: L #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 14.0 20.0 29.0 28.2 31.0 44.0 #&gt; ------------------------------------------------------------ #&gt; wool: A #&gt; tension: M #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 12 18 21 24 30 36 #&gt; ------------------------------------------------------------ #&gt; wool: B #&gt; tension: M #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 16.0 21.0 28.0 28.8 39.0 42.0 #&gt; ------------------------------------------------------------ #&gt; wool: A #&gt; tension: H #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 10.0 18.0 24.0 24.6 28.0 43.0 #&gt; ------------------------------------------------------------ #&gt; wool: B #&gt; tension: H #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 13.0 15.0 17.0 18.8 21.0 28.0 5.4.9 split() split(x, f, drop = FALSE, ...)은 f에 정의된 그룹(보통 팩터 또는 리스트)에 따라 벡터 x를 분리합니다. 반환되는 값은 리스트입니다. unsplit(value, f, drop = FALSE)은 분리된 벡터 리스트 또는 데이터프레임인 value를 f에 정의된 그룹기준으로 원상태로 되돌립니다. 반환되는 값은 벡터나 데이터프레임입니다. str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # iris 데이터프레임을 Species 기준으로 분리합니다. (결과 리스트 형태) x &lt;- split(iris, iris$Species) str(x) #&gt; List of 3 #&gt; $ setosa :&#39;data.frame&#39;: 50 obs. of 5 variables: #&gt; ..$ Sepal.Length: num [1:50] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; ..$ Sepal.Width : num [1:50] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; ..$ Petal.Length: num [1:50] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; ..$ Petal.Width : num [1:50] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ versicolor:&#39;data.frame&#39;: 50 obs. of 5 variables: #&gt; ..$ Sepal.Length: num [1:50] 7 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 ... #&gt; ..$ Sepal.Width : num [1:50] 3.2 3.2 3.1 2.3 2.8 2.8 3.3 2.4 2.9 2.7 ... #&gt; ..$ Petal.Length: num [1:50] 4.7 4.5 4.9 4 4.6 4.5 4.7 3.3 4.6 3.9 ... #&gt; ..$ Petal.Width : num [1:50] 1.4 1.5 1.5 1.3 1.5 1.3 1.6 1 1.3 1.4 ... #&gt; ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... #&gt; $ virginica :&#39;data.frame&#39;: 50 obs. of 5 variables: #&gt; ..$ Sepal.Length: num [1:50] 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 ... #&gt; ..$ Sepal.Width : num [1:50] 3.3 2.7 3 2.9 3 3 2.5 2.9 2.5 3.6 ... #&gt; ..$ Petal.Length: num [1:50] 6 5.1 5.9 5.6 5.8 6.6 4.5 6.3 5.8 6.1 ... #&gt; ..$ Petal.Width : num [1:50] 2.5 1.9 2.1 1.8 2.2 2.1 1.7 1.8 1.8 2.5 ... #&gt; ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... # 분리된 것을 다시 원상태로 돌립니다. (결과 데이터프레임) y &lt;- unsplit(x, iris$Species) str(y) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 두 개 칼럼을 기준으로 분리할 수 있습니다. 2개 이상의 칼럼을 기준으로 할 때에는 리스트 구조로 묶어줍니다. str(infert) # R 내장 데이터 infert #&gt; &#39;data.frame&#39;: 248 obs. of 8 variables: #&gt; $ education : Factor w/ 3 levels &quot;0-5yrs&quot;,&quot;6-11yrs&quot;,..: 1 1 1 1 2 2 2 2 2 2 ... #&gt; $ age : num 26 42 39 34 35 36 23 32 21 28 ... #&gt; $ parity : num 6 1 6 4 3 4 1 2 1 2 ... #&gt; $ induced : num 1 1 2 2 1 2 0 0 0 0 ... #&gt; $ case : num 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ spontaneous : num 2 0 0 0 1 1 0 0 1 0 ... #&gt; $ stratum : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ pooled.stratum: num 3 1 4 2 32 36 6 22 5 19 ... x &lt;- split(infert, list(infert$spontaneous, infert$education)) str(x, max.level = 1) #&gt; List of 9 #&gt; $ 0.0-5yrs :&#39;data.frame&#39;: 9 obs. of 8 variables: #&gt; $ 1.0-5yrs :&#39;data.frame&#39;: 1 obs. of 8 variables: #&gt; $ 2.0-5yrs :&#39;data.frame&#39;: 2 obs. of 8 variables: #&gt; $ 0.6-11yrs:&#39;data.frame&#39;: 71 obs. of 8 variables: #&gt; $ 1.6-11yrs:&#39;data.frame&#39;: 33 obs. of 8 variables: #&gt; $ 2.6-11yrs:&#39;data.frame&#39;: 16 obs. of 8 variables: #&gt; $ 0.12+ yrs:&#39;data.frame&#39;: 61 obs. of 8 variables: #&gt; $ 1.12+ yrs:&#39;data.frame&#39;: 37 obs. of 8 variables: #&gt; $ 2.12+ yrs:&#39;data.frame&#39;: 18 obs. of 8 variables: 행의 갯수를 지정해서 데이터를 분리할 수 있습니다. 인수 f에 데이터를 나눌 기준이 될 벡터을 만들면 됩니다. 그러면 같은 수를 가진 행끼리 하나의 그룹으로 만들어집니다. 단, 이 기준 벡터의 수와 데이터의 갯수가 같아야 오류가 나지 않습니다. # infert 데이터의 전체 행을 10개씩 구분하는 기준 벡터를 만듭니다. df &lt;- iris # 데이터 gnum &lt;- 10 # 그룹의 갯수 f &lt;- c(rep(1:floor((nrow(df)/gnum)), each = gnum), rep(ceiling(nrow(df)/gnum), each = nrow(df)%%gnum)) x &lt;- split(df, f) print(x[1:2]); cat(&quot;... 이하 생략 ...&quot;) #&gt; $`1` #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa #&gt; 7 4.6 3.4 1.4 0.3 setosa #&gt; 8 5.0 3.4 1.5 0.2 setosa #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 10 4.9 3.1 1.5 0.1 setosa #&gt; #&gt; $`2` #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 11 5.4 3.7 1.5 0.2 setosa #&gt; 12 4.8 3.4 1.6 0.2 setosa #&gt; 13 4.8 3.0 1.4 0.1 setosa #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 15 5.8 4.0 1.2 0.2 setosa #&gt; 16 5.7 4.4 1.5 0.4 setosa #&gt; 17 5.4 3.9 1.3 0.4 setosa #&gt; 18 5.1 3.5 1.4 0.3 setosa #&gt; 19 5.7 3.8 1.7 0.3 setosa #&gt; 20 5.1 3.8 1.5 0.3 setosa #&gt; ... 이하 생략 ... # 위 예제에서 분리된 것을 같은 기준으로 하나로 묶습니다. y &lt;- unsplit(x, f) str(y) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 5.4.10 Vectorize() Vectorize(FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, USE.NAMES = TRUE) 함수는 인자 FUN에 들어간 함수가 벡터 방식으로 작동하도록 만드는 함수입니다. 함수 중에는 함수의 인자가 단 하나의 값만 들어가야 하는 경우가 있어 인자에 여러 개의 값 즉 벡터형식으로 넣을 수 없는 함수들이 있습니다. Vectorize() 함수는 이 문제를 해결하여 줍니다. 이때 벡터형식으로 들어갈 인자를 vectorize.args에 지정합니다. 반환되는 결과는 벡터로 들어간 인자들이 각각 투입된 만큼의 결과들이 행렬이나 배열로 묶여서 나옵니다. 아래 예제는 iris$Species에서 vi나 se로 시작하는 행을 추출하고자 하는 것입니다. # grepl함수는 pattern 인수에 단 하나의 값만 넣을 수 있습니다. # 만일 아래 같이 벡터형식으로 값을 여러 개 넣으면 첫번째 요소만 사용되어 # 원하는 결과를 얻을 수없습니다. x &lt;- grepl(pattern = c(&quot;^vi&quot;, &quot;^se&quot;), x = iris$Species) #&gt; Warning in grepl(pattern = c(&quot;^vi&quot;, &quot;^se&quot;), x = iris$Species): 인자 &#39;pattern&#39;는 #&gt; 반드시 길이가 1 보다 커야 하고, 오로지 첫번째 요소만이 사용될 것입니다 head(x) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE # grepl 함수를 벡터작업이 가능한 함수 vgrepl로 만듭니다. # 벡터로 들어갈 인수는 pattern으로 지정합니다. vgrepl &lt;- Vectorize(grepl, vectorize.args = &quot;pattern&quot;) x &lt;- vgrepl(pattern = c(&quot;^vi&quot;, &quot;^se&quot;), x = iris$Species) head(x) #&gt; ^vi ^se #&gt; [1,] FALSE TRUE #&gt; [2,] FALSE TRUE #&gt; [3,] FALSE TRUE #&gt; [4,] FALSE TRUE #&gt; [5,] FALSE TRUE #&gt; [6,] FALSE TRUE # 조건에 맞는 행들을 추출합니다. str(iris[rowSums(x) &gt; 0, ]) #&gt; &#39;data.frame&#39;: 100 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 물론 Vectorize() 함수를 사용하지 않고 sapply() 함수를 사용하여 같은 결과를 얻을 수 있습니다. x &lt;- sapply(c(&quot;^vi&quot;, &quot;^se&quot;), function(pattern) {grepl(pattern = pattern, x = iris$Species)}) head(x) #&gt; ^vi ^se #&gt; [1,] FALSE TRUE #&gt; [2,] FALSE TRUE #&gt; [3,] FALSE TRUE #&gt; [4,] FALSE TRUE #&gt; [5,] FALSE TRUE #&gt; [6,] FALSE TRUE sumsq &lt;- function(x, mean = 0, sd = 1) { sum(((x - mean) / sd)^2)} set.seed(123) x &lt;- rnorm(10000) # mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x))와 같은 결과 vsumsq &lt;- Vectorize(sumsq, c(&quot;mean&quot;, &quot;sd&quot;)) vsumsq(x, 1:100, 1:100) #&gt; [1] 20019 12517 11124 10635 10408 10285 10210 10162 10128 10104 10087 10073 #&gt; [13] 10063 10054 10047 10042 10037 10033 10030 10027 10025 10023 10021 10019 #&gt; [25] 10018 10017 10015 10014 10013 10013 10012 10011 10011 10010 10009 10009 #&gt; [37] 10009 10008 10008 10007 10007 10007 10006 10006 10006 10006 10006 10005 #&gt; [49] 10005 10005 10005 10005 10004 10004 10004 10004 10004 10004 10004 10004 #&gt; [61] 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 #&gt; [73] 10003 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 #&gt; [85] 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 #&gt; [97] 10002 10002 10001 10001 sumsq &lt;- function(x, mean = 0, sd = 1) { sum(((x - mean) / sd)^2) } set.seed(123) x &lt;- rnorm(10000) # sumsq(x, mean = 1, sd = 1), sumsq(x, mean = 2, sd = 2), ... mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x)) #&gt; [1] 20019 12517 11124 10635 10408 10285 10210 10162 10128 10104 10087 10073 #&gt; [13] 10063 10054 10047 10042 10037 10033 10030 10027 10025 10023 10021 10019 #&gt; [25] 10018 10017 10015 10014 10013 10013 10012 10011 10011 10010 10009 10009 #&gt; [37] 10009 10008 10008 10007 10007 10007 10006 10006 10006 10006 10006 10005 #&gt; [49] 10005 10005 10005 10005 10004 10004 10004 10004 10004 10004 10004 10004 #&gt; [61] 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 10003 #&gt; [73] 10003 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 #&gt; [85] 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 10002 #&gt; [97] 10002 10002 10001 10001 # 만일 이렇게 mapply(sumsq, mean = 1:100, sd = 1:100, x = x) 하면 # sumsq(x = x[1], mean = 1, sd = 1), ... 이런식으로 계산되어 # 원하는 결과가 나오지 않음. 여기서 x[1]은 -0.560475647임 5.4.11 replicate() replicate(n, expr, simplify = \"array\") 함수는 sapply() 함수의 간소화 버전이라 할 수 있습니다. expr 인자를 n번 만큼 반복수행합니다. expr 인자에는 주로 함수들이 많이 들어갑니다. 반환되는 결과는 기본적으로 배열입니다. 만일 반환되는 값을 리스트 형태로 받고자 한다면 simplify = FALSE로 지정합니다. 아래 예제는 rnorm(5, mean = 0, sd = 1)을 3번 반복하여 그 결과를 행렬형태로 얻는 것입니다. set.seed(123) replicate(n = 3, rnorm(5, mean = 0, sd = 1)) #&gt; [,1] [,2] [,3] #&gt; [1,] -0.5605 1.715 1.224 #&gt; [2,] -0.2302 0.461 0.360 #&gt; [3,] 1.5587 -1.265 0.401 #&gt; [4,] 0.0705 -0.687 0.111 #&gt; [5,] 0.1293 -0.446 -0.556 5.4.12 rep() rep(x, ...) 함수는 특정값을 반복해서 만들어 반환해주는 함수입니다. ...에는 인자로 times, length.out, each가 들어갈 수 있습니다. times는 x를 몇 번 반복할지를 정해주는 인수입니다. length.out은 최종 반환되는 값들의 길이를 정해주는 인수입니다. each는 x가 여러개의 값으로 구성된 벡터일 경우 각각 몇 번 반복할지를 정해주는 인수 입니다. rep.int(x, times)와 rep_len(x, length.out)는 rep() 함수와 기능이 거의 같으나 인수가 제한됩니다. 이 함수들은 rep() 함수보다 더 빠릅니다. rep(1:5, 2) # rep(x = 1:4, times = 2)와 동일 #&gt; [1] 1 2 3 4 5 1 2 3 4 5 rep(1:5, each = 2) #&gt; [1] 1 1 2 2 3 3 4 4 5 5 rep(1:5, c(2, 3, 2, 1, 2)) # rep(1:5, times = c(2, 3, 2, 1, 2)) 동일 #&gt; [1] 1 1 2 2 2 3 3 4 5 5 rep(1:5, each = 2, len = 5) #&gt; [1] 1 1 2 2 3 rep(1:2, each = 2, len = 7) # 길이를 채우기 위해 다시 반복 #&gt; [1] 1 1 2 2 1 1 2 rep(1:3, each = 2, times =3) #&gt; [1] 1 1 2 2 3 3 1 1 2 2 3 3 1 1 2 2 3 3 rep(2, 5.9) # 소수점 이하는 버리고 반복 #&gt; [1] 2 2 2 2 2 rep(c(&quot;abc&quot;, &quot;123&quot;), times = 3) #&gt; [1] &quot;abc&quot; &quot;123&quot; &quot;abc&quot; &quot;123&quot; &quot;abc&quot; &quot;123&quot; rep(c(&quot;abc&quot;, &quot;123&quot;), each = 3) #&gt; [1] &quot;abc&quot; &quot;abc&quot; &quot;abc&quot; &quot;123&quot; &quot;123&quot; &quot;123&quot; rep.int(c(&quot;abc&quot;, &quot;123&quot;), 3) # 기본인자는 times임. each 인자는 사용할 수 없음 #&gt; [1] &quot;abc&quot; &quot;123&quot; &quot;abc&quot; &quot;123&quot; &quot;abc&quot; &quot;123&quot; rep_len(c(&quot;abc&quot;, &quot;123&quot;), 5) # 기본인자는 length.out임 #&gt; [1] &quot;abc&quot; &quot;123&quot; &quot;abc&quot; &quot;123&quot; &quot;abc&quot; 5.4.13 seq() seq(...) 함수는 일련번호 숫자를 생성하여 반환합니다. ...에는 인자로 from, to, by, length.out, along.with가 들어갈 수 있습니다. from : 시작 숫자 to : 끝 숫자 by : 증가 간격 length.out : 생성되는 일련번호의 길이 along.with : 인자에 들어가는 값들의 길이만큼 일련번호 생성 seq.int()는 seq() 함수와 거의 동일하고, seq_along(along.with)와 seq_len(length.out)는 무조건 시작이 1이고, 각각 하나의 인자를 받아 일련번호를 생성합니다. 이 함수들은 1부터 시작하는 일련번호를 seq() 함수보다 약간 더 빠르게 만들어 줍니다. 가장 많이 사용하는 형태는 다음과 같습니다. seq(from, to) seq(from, to, by = ) seq(from, to, length.out = ) seq(along.with = ) seq(from) seq(length.out = ) seq(2, 7) # seq(from = 2, to = 7과 동일) #&gt; [1] 2 3 4 5 6 7 seq(7, 2) #&gt; [1] 7 6 5 4 3 2 seq(2, 10, by = 2) #&gt; [1] 2 4 6 8 10 seq(2, 10, by = pi) #&gt; [1] 2.00 5.14 8.28 seq(2, 10, length.out = 3) #&gt; [1] 2 6 10 seq(along.with = c(2:7)) # c(2:7)의 길이는 6이므로 6개 생성 #&gt; [1] 1 2 3 4 5 6 seq(2, 10, along.with = c(2:7)) #&gt; [1] 2.0 3.6 5.2 6.8 8.4 10.0 seq(7) # 1부터 7까지 생성 #&gt; [1] 1 2 3 4 5 6 7 seq(length.out = 12) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 seq.int(2, 10, by = pi) #&gt; [1] 2.00 5.14 8.28 seq_len(12) # seq(length.out = 12)와 동일하나 약간 더 빠름 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 seq_along(c(2:7)) #&gt; [1] 1 2 3 4 5 6 n &lt;- 999999999999999 start &lt;- proc.time() x &lt;- seq(length.out = n) end &lt;- proc.time() end - start #&gt; user system elapsed #&gt; 0 0 0 start &lt;- proc.time() x &lt;- seq_len(n) end &lt;- proc.time() end - start #&gt; user system elapsed #&gt; 0 0 0 일련 날짜를 생성할 수 있습니다. # 1년 간격 seq(as.Date(&quot;2001/1/1&quot;), as.Date(&quot;2020/1/1&quot;), &quot;years&quot;) #&gt; [1] &quot;2001-01-01&quot; &quot;2002-01-01&quot; &quot;2003-01-01&quot; &quot;2004-01-01&quot; &quot;2005-01-01&quot; #&gt; [6] &quot;2006-01-01&quot; &quot;2007-01-01&quot; &quot;2008-01-01&quot; &quot;2009-01-01&quot; &quot;2010-01-01&quot; #&gt; [11] &quot;2011-01-01&quot; &quot;2012-01-01&quot; &quot;2013-01-01&quot; &quot;2014-01-01&quot; &quot;2015-01-01&quot; #&gt; [16] &quot;2016-01-01&quot; &quot;2017-01-01&quot; &quot;2018-01-01&quot; &quot;2019-01-01&quot; &quot;2020-01-01&quot; # 월 간격 seq(as.Date(&quot;2001/1/1&quot;), by = &quot;month&quot;, length.out = 12) #&gt; [1] &quot;2001-01-01&quot; &quot;2001-02-01&quot; &quot;2001-03-01&quot; &quot;2001-04-01&quot; &quot;2001-05-01&quot; #&gt; [6] &quot;2001-06-01&quot; &quot;2001-07-01&quot; &quot;2001-08-01&quot; &quot;2001-09-01&quot; &quot;2001-10-01&quot; #&gt; [11] &quot;2001-11-01&quot; &quot;2001-12-01&quot; # 분기 간격 seq(as.Date(&quot;2015/1/1&quot;), as.Date(&quot;2020/1/1&quot;), by = &quot;quarter&quot;) #&gt; [1] &quot;2015-01-01&quot; &quot;2015-04-01&quot; &quot;2015-07-01&quot; &quot;2015-10-01&quot; &quot;2016-01-01&quot; #&gt; [6] &quot;2016-04-01&quot; &quot;2016-07-01&quot; &quot;2016-10-01&quot; &quot;2017-01-01&quot; &quot;2017-04-01&quot; #&gt; [11] &quot;2017-07-01&quot; &quot;2017-10-01&quot; &quot;2018-01-01&quot; &quot;2018-04-01&quot; &quot;2018-07-01&quot; #&gt; [16] &quot;2018-10-01&quot; &quot;2019-01-01&quot; &quot;2019-04-01&quot; &quot;2019-07-01&quot; &quot;2019-10-01&quot; #&gt; [21] &quot;2020-01-01&quot; # 월 간격 반대로 seq(as.Date(&quot;2020-1-7&quot;), as.Date(&quot;2019-1-17&quot;), by = &quot;-1 month&quot;) #&gt; [1] &quot;2020-01-07&quot; &quot;2019-12-07&quot; &quot;2019-11-07&quot; &quot;2019-10-07&quot; &quot;2019-09-07&quot; #&gt; [6] &quot;2019-08-07&quot; &quot;2019-07-07&quot; &quot;2019-06-07&quot; &quot;2019-05-07&quot; &quot;2019-04-07&quot; #&gt; [11] &quot;2019-03-07&quot; &quot;2019-02-07&quot; seq(ISOdate(2015,1,1), ISOdate(2020,1,1), &quot;years&quot;) #&gt; [1] &quot;2015-01-01 12:00:00 GMT&quot; &quot;2016-01-01 12:00:00 GMT&quot; #&gt; [3] &quot;2017-01-01 12:00:00 GMT&quot; &quot;2018-01-01 12:00:00 GMT&quot; #&gt; [5] &quot;2019-01-01 12:00:00 GMT&quot; &quot;2020-01-01 12:00:00 GMT&quot; seq(c(ISOdate(2020,3,20)), by = &quot;DSTday&quot;, length.out = 10) #&gt; [1] &quot;2020-03-20 21:00:00 KST&quot; &quot;2020-03-21 21:00:00 KST&quot; #&gt; [3] &quot;2020-03-22 21:00:00 KST&quot; &quot;2020-03-23 21:00:00 KST&quot; #&gt; [5] &quot;2020-03-24 21:00:00 KST&quot; &quot;2020-03-25 21:00:00 KST&quot; #&gt; [7] &quot;2020-03-26 21:00:00 KST&quot; &quot;2020-03-27 21:00:00 KST&quot; #&gt; [9] &quot;2020-03-28 21:00:00 KST&quot; &quot;2020-03-29 21:00:00 KST&quot; seq(c(ISOdate(2020,3,20)), by = &quot;7 DSTdays&quot;, length.out = 5) #&gt; [1] &quot;2020-03-20 21:00:00 KST&quot; &quot;2020-03-27 21:00:00 KST&quot; #&gt; [3] &quot;2020-04-03 21:00:00 KST&quot; &quot;2020-04-10 21:00:00 KST&quot; #&gt; [5] &quot;2020-04-17 21:00:00 KST&quot; seq(as.POSIXct(&quot;2015-3-14 17:22:15&quot;), as.POSIXct(&quot;2015-3-15 9:12:25&quot;), by = &quot;hours&quot;) #&gt; [1] &quot;2015-03-14 17:22:15 KST&quot; &quot;2015-03-14 18:22:15 KST&quot; #&gt; [3] &quot;2015-03-14 19:22:15 KST&quot; &quot;2015-03-14 20:22:15 KST&quot; #&gt; [5] &quot;2015-03-14 21:22:15 KST&quot; &quot;2015-03-14 22:22:15 KST&quot; #&gt; [7] &quot;2015-03-14 23:22:15 KST&quot; &quot;2015-03-15 00:22:15 KST&quot; #&gt; [9] &quot;2015-03-15 01:22:15 KST&quot; &quot;2015-03-15 02:22:15 KST&quot; #&gt; [11] &quot;2015-03-15 03:22:15 KST&quot; &quot;2015-03-15 04:22:15 KST&quot; #&gt; [13] &quot;2015-03-15 05:22:15 KST&quot; &quot;2015-03-15 06:22:15 KST&quot; #&gt; [15] &quot;2015-03-15 07:22:15 KST&quot; &quot;2015-03-15 08:22:15 KST&quot; 5.4.14 sequence() sequence(nvec, ...) 함수는 연속적인 숫자를 만들어 내는 함수입니다. 인자 nvec에 들어간 숫자 벡터들 만큼 seq() 함수가 수행되어 연속적인 숫자가 만들어집니다. 예를 들면 nvec = c(3, 2)이면 seq(3), seq(2)가 수행됩니다. sequence(nvec = c(3, 2)) # c(seq(3), seq(2)) 또는 c(1:3, 1:2)와 동일 #&gt; [1] 1 2 3 1 2 sequence(nvec = c(3, 2, 5)) #&gt; [1] 1 2 3 1 2 1 2 3 4 5 sequence(c(3, 2), from = 2) # 시작숫자 지정 #&gt; [1] 2 3 4 2 3 sequence(c(3, 2), from = 2, by = -2) # 시작숫자, 간격 지정 #&gt; [1] 2 0 -2 2 0 sequence(c(3, 2), by = c(2, -2)) #&gt; [1] 1 3 5 1 -1 5.4.15 gl() gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE) 함수는 요인 수준을 반복적으로 생성하여 반환합니다. gl은 generate levels의 약자로 생각됩니다. n : 수준을 나태내는 숫자. n = 2이면 label을 따로 지정하지 않은 경우 수준이 1, 2로 표현됩니다. k : 수준을 반복할 숫자. k = 8이면 8번 반복합니다. length : 생성되는 총 데이터의 갯수 labels : 수준에 대한 이름 ordered : TRUE이면 요인의 순서가 정해집니다. (순서형 데이터) gl(n = 2, k = 8) # 수준 1, 2를 각각 8번 반복 #&gt; [1] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 #&gt; Levels: 1 2 gl(n = 2, k = 8, labels = c(&quot;Contol&quot;, &quot;Treat&quot;)) # 수준 이름 지정 #&gt; [1] Contol Contol Contol Contol Contol Contol Contol Contol Treat Treat #&gt; [11] Treat Treat Treat Treat Treat Treat #&gt; Levels: Contol Treat gl(n = 2, k = 1, length = 10) # 수준 1, 2가 각각 1번씩 반복되며 10개 생성 #&gt; [1] 1 2 1 2 1 2 1 2 1 2 #&gt; Levels: 1 2 gl(n = 2, k = 2, length = 10) # 수준 1, 2가 각각 2번씩 반복되며 10개 생성 #&gt; [1] 1 1 2 2 1 1 2 2 1 1 #&gt; Levels: 1 2 # 수준 1, 2가 M과 F로 순서있게 네이밍 되고, 각각 3번씩 반복되며 10개 생성 gl(2, 3, 10, labels = c(&quot;M&quot;, &quot;F&quot;), ordered = TRUE) #&gt; [1] M M M F F F M M M F #&gt; Levels: M &lt; F 5.4.16 sweep() sweep(x, MARGIN, STATS, FUN = \"-\", check.margin = TRUE, ...) 함수는 행렬, 데이터프레임 등에 통계량과 함수를 적용하여 그 결과를 반환하는 함수입니다. 데이터 x에 일률적으로 특정 숫자만큼 더하거나 빼기를 할 때 많이 사용합니다. x : 입력 데이터로서 배열, 행렬, 데이터프레임 MARGIN : 행과 열 방향 지정. 1이면 열방향, 2이면 행방향 STATS : 적용할 요약 통계량 또는 수치 FUN : 적용할 함수 (기본값은 “-” 임) x &lt;- matrix(1:12, ncol = 3); x #&gt; [,1] [,2] [,3] #&gt; [1,] 1 5 9 #&gt; [2,] 2 6 10 #&gt; [3,] 3 7 11 #&gt; [4,] 4 8 12 # 행렬 x를 행방향(2)으로 1씩 빼줌 sweep(x, MARGIN = 2, STATS = 1, FUN = &quot;-&quot;) #&gt; [,1] [,2] [,3] #&gt; [1,] 0 4 8 #&gt; [2,] 1 5 9 #&gt; [3,] 2 6 10 #&gt; [4,] 3 7 11 # 행렬 x를 열방향(1)으로 각각 1, 2, 3, 4를 더해줌 sweep(x, 1, c(1,2,3,4), FUN = &quot;+&quot;) #&gt; [,1] [,2] [,3] #&gt; [1,] 2 6 10 #&gt; [2,] 4 8 12 #&gt; [3,] 6 10 14 #&gt; [4,] 8 12 16 # 행 기준 비율 계산 round(sweep(x, 1, apply(x, 1, sum), FUN = &quot;/&quot;) * 100, 1) #&gt; [,1] [,2] [,3] #&gt; [1,] 6.7 33.3 60.0 #&gt; [2,] 11.1 33.3 55.6 #&gt; [3,] 14.3 33.3 52.4 #&gt; [4,] 16.7 33.3 50.0 # 열 기준 비율 계산 round(sweep(x, 2, apply(x, 2, sum), FUN = &quot;/&quot;) * 100, 1) #&gt; [,1] [,2] [,3] #&gt; [1,] 10 19.2 21.4 #&gt; [2,] 20 23.1 23.8 #&gt; [3,] 30 26.9 26.2 #&gt; [4,] 40 30.8 28.6 # 전체 기준 비율 계산 round(sweep(x, 2, sum(x), FUN = &quot;/&quot;) * 100, 1) #&gt; [,1] [,2] [,3] #&gt; [1,] 1.3 6.4 11.5 #&gt; [2,] 2.6 7.7 12.8 #&gt; [3,] 3.8 9.0 14.1 #&gt; [4,] 5.1 10.3 15.4 # 데이터프레임의 숫자 열에 각각 1씩 빼기 str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... y &lt;- sweep(iris[1:4], MARGIN = 2, STATS = 1, FUN = &quot;-&quot;) str(y) #&gt; &#39;data.frame&#39;: 150 obs. of 4 variables: #&gt; $ Sepal.Length: num 4.1 3.9 3.7 3.6 4 4.4 3.6 4 3.4 3.9 ... #&gt; $ Sepal.Width : num 2.5 2 2.2 2.1 2.6 2.9 2.4 2.4 1.9 2.1 ... #&gt; $ Petal.Length: num 0.4 0.4 0.3 0.5 0.4 0.7 0.4 0.5 0.4 0.5 ... #&gt; $ Petal.Width : num -0.8 -0.8 -0.8 -0.8 -0.8 -0.6 -0.7 -0.8 -0.8 -0.9 ... 5.4.17 aggregate() aggregate(x, ...) 함수는 데이터 x의 그룹별로 함수를 적용하여 그 결과를 반환합니다. x : 입력 데이터 by : 그룹핑 변수(열)로서 리스트 형식이어야 함 FUN : 적용할 함수 str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... # 종류별로 평균을 구함 aggregate(iris[1:4], by = list(iris$Species), mean, na.rm = TRUE) #&gt; Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 5.01 3.43 1.46 0.246 #&gt; 2 versicolor 5.94 2.77 4.26 1.326 #&gt; 3 virginica 6.59 2.97 5.55 2.026 # 그룹핑 그룹에 이름을 지정할 수 있음(종류) aggregate(iris[1:4], by = list(종류 = iris$Species), mean, na.rm = TRUE) #&gt; 종류 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 5.01 3.43 1.46 0.246 #&gt; 2 versicolor 5.94 2.77 4.26 1.326 #&gt; 3 virginica 6.59 2.97 5.55 2.026 # 적용할 함수에 인자들을 지정할 수 있음 aggregate(iris[1:4], by = list(종류 = iris$Species), mean, na.rm = TRUE, trim = 0.1) #&gt; 종류 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 5.00 3.42 1.46 0.238 #&gt; 2 versicolor 5.94 2.78 4.29 1.325 #&gt; 3 virginica 6.57 2.96 5.51 2.033 str(infert) # R 내장 데이터 infert #&gt; &#39;data.frame&#39;: 248 obs. of 8 variables: #&gt; $ education : Factor w/ 3 levels &quot;0-5yrs&quot;,&quot;6-11yrs&quot;,..: 1 1 1 1 2 2 2 2 2 2 ... #&gt; $ age : num 26 42 39 34 35 36 23 32 21 28 ... #&gt; $ parity : num 6 1 6 4 3 4 1 2 1 2 ... #&gt; $ induced : num 1 1 2 2 1 2 0 0 0 0 ... #&gt; $ case : num 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ spontaneous : num 2 0 0 0 1 1 0 0 1 0 ... #&gt; $ stratum : int 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ pooled.stratum: num 3 1 4 2 32 36 6 22 5 19 ... # 2개 변수로 그룹핑 aggregate(infert[2:3], by = list(infert$education, infert$spontaneous), mean, na.rm = TRUE) #&gt; Group.1 Group.2 age parity #&gt; 1 0-5yrs 0 36.6 4.11 #&gt; 2 6-11yrs 0 33.7 1.72 #&gt; 3 12+ yrs 0 29.7 1.66 #&gt; 4 0-5yrs 1 34.0 4.00 #&gt; 5 6-11yrs 1 31.2 2.45 #&gt; 6 12+ yrs 1 28.9 1.70 #&gt; 7 0-5yrs 2 30.0 5.00 #&gt; 8 6-11yrs 2 32.4 3.06 #&gt; 9 12+ yrs 2 31.6 2.89 "],
["r-통계-함수.html", "5.5 R 통계 함수", " 5.5 R 통계 함수 5.5.1 sample() sample(x, size, replace = FALSE, prob = NULL) 함수는 데이터 x에서 무작위로 데이터를 size만큼 추출하여 반환합니다. x : 1개 이상의 요소를 가진 벡터(모집단) size : 추출할 갯수(표본의 크기) replace : 기본값은 FALSE로 비복원 추출, TRUE이면 복원 추출 prob : 표본이 추출될 가중치 간소화 버전 함수로 sample.int(n, size = n, replace = FALSE, prob = NULL)가 있습니다. 1부터 n 사이의 값에서 기본적으로 n만큼 데이터를 추출합니다. 만일 size를 지정하면 size 숫자만큼 추출합니다. set.seed(5) # 아래 무작위 추출 결과가 항상 동일하게 나오게 함 x &lt;- 1:12 sample(x, size = 5) #&gt; [1] 2 11 9 10 1 sample(x, size = 5, replace = TRUE) #&gt; [1] 5 7 7 3 3 # 1은 20%, 2는 30%, 3은 50% 확률로 추출됨 (가중표본추출) sample(1:3, size = 5, replace = TRUE, prob = c(2, 3, 5)) #&gt; [1] 2 3 3 3 1 # 베루누이 실험 - 100회 sample(0:1, 100, replace = TRUE) #&gt; [1] 1 1 0 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 #&gt; [38] 1 0 0 1 1 0 0 0 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 0 1 0 0 0 1 1 0 1 0 1 0 0 1 #&gt; [75] 0 1 0 0 1 0 1 0 1 1 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 1 # sample.int sample.int(10) #&gt; [1] 8 1 6 9 4 5 7 10 2 3 sample.int(10, size = 5) #&gt; [1] 4 5 7 8 9 # 데이터 프레임에서 무작위로 표본을 추출합니다. # 예제는 iris(150개 행)에서 30개를 무작위로 추출합니다. str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... set.seed(357) idx &lt;- sample(nrow(iris), 30) # sample(1:150, size = 30)과 동일 idx # 추출된 번호 확인(생략 가능) #&gt; [1] 119 24 145 75 10 90 70 147 51 135 85 25 46 143 44 50 149 42 124 #&gt; [20] 87 140 54 35 47 138 123 104 16 62 134 sam &lt;- iris[idx,] str(sam) #&gt; &#39;data.frame&#39;: 30 obs. of 5 variables: #&gt; $ Sepal.Length: num 7.7 5.1 6.7 6.4 4.9 5.5 5.6 6.3 7 6.1 ... #&gt; $ Sepal.Width : num 2.6 3.3 3.3 2.9 3.1 2.5 2.5 2.5 3.2 2.6 ... #&gt; $ Petal.Length: num 6.9 1.7 5.7 4.3 1.5 4 3.9 5 4.7 5.6 ... #&gt; $ Petal.Width : num 2.3 0.5 2.5 1.3 0.1 1.3 1.1 1.9 1.4 1.4 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 3 1 3 2 1 2 2 3 2 3 ... 데이터를 80:20으로 나누어 추출하겠습니다. dataset &lt;- iris str(dataset) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... set.seed(357) idx &lt;- sample(1:nrow(dataset), size = round(0.8*nrow(dataset))) train &lt;- dataset[idx,] #훈련용 데이터 test &lt;- dataset[-idx,] #검증용 데이터 str(train) #&gt; &#39;data.frame&#39;: 120 obs. of 5 variables: #&gt; $ Sepal.Length: num 7.7 5.1 6.7 6.4 4.9 5.5 5.6 6.3 7 6.1 ... #&gt; $ Sepal.Width : num 2.6 3.3 3.3 2.9 3.1 2.5 2.5 2.5 3.2 2.6 ... #&gt; $ Petal.Length: num 6.9 1.7 5.7 4.3 1.5 4 3.9 5 4.7 5.6 ... #&gt; $ Petal.Width : num 2.3 0.5 2.5 1.3 0.1 1.3 1.1 1.9 1.4 1.4 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 3 1 3 2 1 2 2 3 2 3 ... 5.5.2 균등분포(unif) 확률분포는 연속확률분포와 이산확률분포로 구분할 수 있습니다. 연속확률분포에는 균등분포, 정규분포, 표준정규분포, 감마분포, 지수분포, 베타분포, t분포, 카이제곱분포, F분포, 웨이블분포, 로그정규분포 등이 있습니다. 이산확률 분포는 베르누이분포, 이항분포, 다항분포, 초기하분포, 기하분포, 음이항분포, 포아송분포 등이 있습니다. 균등분포는 분포가 특정 범위내에서 균등하게 나타나는 경우를 의미합니다. 다른말로 연속균등분포라고 합니다. 영어로는 uniform distribution입니다. 균등분포와 관련된 함수는 다음 4가지 있습니다. runif(n, min = 0, max = 1) dunif(x, min = 0, max = 1, log = FALSE) punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) 위 함수명은 접두어 r, d, p, q와 균등분포를 의미하는 unif가 결합하여 만들어진 것입니다. 접두어의 의미는 다음과 같습니다. r : 난수(random number) 발생 d : 확률밀도함수(density) p : 누적분포함수(distribution function) q : 분위수(quantile function) runif 함수는 난수를 의미하는 r과 균등분포를 의미하는 unif가 결합하여 만들어진 함수명입니다. 따라서 runif(n, min = 0, max = 1) 함수는 최소값(0)부터 최대값(1)사이에 균등분포로 n개의 난수를 생성하여 반환합니다. 다른 확률분포 함수들의 함수명도 이와 같은 규칙으로 만들어졌다고 볼 수 있습니다. runif(10, 2, 5) # 2와 5사이에 균등분포로 10개의 난수 발생 #&gt; [1] 3.91 2.56 2.63 4.89 2.91 3.29 4.71 4.99 4.75 4.51 runif(10) # 0과 1사이에 균등분포로 10개의 난수 발생 #&gt; [1] 0.3551 0.6242 0.9761 0.7250 0.9402 0.3139 0.4869 0.0782 0.4322 0.4665 mean(runif(100000)) # 0~1 균등분포로 추출된 값들의 평균은 0.5에 가까움 #&gt; [1] 0.499 dunif(x, min = 0, max = 1, log = FALSE) 함수는 균등분포의 확률밀도함수입니다. 최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 인자 x의 함수값을 구해 반환합니다. x &lt;- seq(-2, 5, by = 0.01) str(x) #&gt; num [1:701] -2 -1.99 -1.98 -1.97 -1.96 -1.95 -1.94 -1.93 -1.92 -1.91 ... # 균등분포의 확률밀도함수 시각화 (0과 3사이의 분포는 균등함) plot(x, dunif(x, 0, 3), type = &quot;l&quot;, col = &quot;red&quot;) # 0과 1사이의 균등분포에서 x가 0.5일때의 함수값? dunif(0.5, 0, 3) #&gt; [1] 0.333 punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) 함수는 균등분포의 누적분포함수입니다. 최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. x &lt;- seq(-2, 5, by = 0.01) str(x) #&gt; num [1:701] -2 -1.99 -1.98 -1.97 -1.96 -1.95 -1.94 -1.93 -1.92 -1.91 ... # 균등분포의 누적분포함수 시각화 (0과 3사이의 누적분포는 일정하게 상승함) plot(x, punif(x, 0, 3), type = &quot;l&quot;, col = &quot;red&quot;) # 0과 3사이의 균등분포에서 q가 0.5일때의 누적분포함수값은? 즉 확률은? punif(0.5, 0, 3) #&gt; [1] 0.167 qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE) 함수는 균등분포의 분위수를 구하는 함수입니다. 최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 확률이 인자 p일 때의 분위수값을 구해 반환합니다. punif 함수와 반대되는 함수라 할 수 있습니다. # 0~5의 균등분포에서 확률이 0.3일때의 x값은 1.5 qunif(0.3, 0, 5) #&gt; [1] 1.5 # 0~5의 균등분포에서 x가 1.5일때의 확률은 0.3 punif(1.5, 0, 5) #&gt; [1] 0.3 5.5.3 정규분포(norm) 정규분포는 분포가 종 모양의 형태로 평균에 가까울수록 발생확률이 높고 평균에서 멀어질수록 발생할 확률이 낮은 분포입니다. 가우스가 처음 정립해서 가우시안(Gaussian) 분포라고도 합니다. 영어로는 normal distribution입니다. 표준정규분포(standard normal distribution)는 평균이 0이고, 표준편차가 1인 정규분포를 의미합니다. “양 끝의 극단에 있는 것은 드물고 소수인 반면, 중간에 있는 것들은 흔하고 다수임을 알지 못하나?” - 소크라테스, 파이돈 정규분포와 관련된 함수는 다음 4가지 있습니다. rnorm(n, mean = 0, sd = 1) dnorm(x, mean = 0, sd = 1, log = FALSE) pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) rnorm(n, mean = 0, sd = 1) 함수는 주어진 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 n개의 난수를 생성하여 반환합니다. rnorm 함수명은 난수를 의미하는 r과 정규분포를 의미하는 norm이 결합되어진 것입니다. # 평균이 0이고 표준편차기 1인 표준정규분포에서 난수 10개 생성 rnorm(10) #&gt; [1] 0.243 -1.663 0.223 -0.169 0.134 0.366 1.892 -0.386 1.517 2.191 # 평균이 50이고 표준편차기 3인 분포에서 난수 10개 생성 rnorm(10, mean = 50, sd = 3) #&gt; [1] 52.2 52.1 46.4 53.4 50.3 44.8 49.1 53.7 52.3 50.9 x &lt;- rnorm(2000) hist(x) # 히스트그램이 정규분포 모양을 dnorm(x, mean = 0, sd = 1, log = FALSE) 함수는 정규분포의 확률밀도함수입니다. 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 인자 x의 함수값을 구해 반환합니다. x &lt;- seq(-5, 5, by = 0.01) # 정규분포의 확률밀도함수 시각화 plot(x, dnorm(x, 0, 1), type = &quot;l&quot;, col = &quot;red&quot;) # 표준정규분포에서 x가 0.5일때의 함수값? dnorm(0.5, 0, 1) #&gt; [1] 0.352 pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 함수는 정규분포의 누적분포함수입니다. 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. x &lt;- seq(-5, 5, by = 0.01) # 정규분포의 누적분포함수 시각화 plot(x, pnorm(x, mean = 0, sd = 1), type = &quot;l&quot;, col = &quot;red&quot;) # 표준정규분포에서 q가 0.5일때의 누적분포함수값은? 즉 확률은? pnorm(0.5, mean = 0, sd = 1) #&gt; [1] 0.691 # 표준정규분포에서 가로축 1까지의 누적분포함수값(확률))은 0.84(84%) pnorm(1, mean = 0, sd = 1) #&gt; [1] 0.841 # 정규분포 그래프에서 -5에서 1까지의 면적(핑크색)은 전체면적의 84% x &lt;- seq(-5, 5, by = 0.01) plot(x, dnorm(x, 0, 1), type = &quot;l&quot;, lwd = 2, col = &quot;red&quot;) u &lt;- seq(-5, 1, by = 0.01) v &lt;- dnorm(u, mean = 0, sd = 1) polygon(c(-5, u, 1), c(0, v, 0), col = &quot;pink&quot;) qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 함수는 정규분포의 분위수를 구하는 함수입니다. 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. # 확률이 0.8413일때의 x값은 1의 근사값 qnorm(0.8413, mean = 0, sd = 1) #&gt; [1] 1 # 1일때의 확률은 0.8413 pnorm(1, mean = 0, sd = 1) #&gt; [1] 0.841 5.5.4 감마분포(gamma) 감마분포는 α번째 사건이 일어날 때 까지 걸리는 시간에 대한 연속확률분포입니다. 참고로 감마분포는 감마함수를 바탕으로 하고 있는데, 감마함수는 수학자 오일러가 제안한 함수입니다. 감마분포와 관련된 함수는 다음 4가지 있습니다. rgamma(n, shape, rate = 1, scale = 1/rate) dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE) pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) rgamma(n, shape, rate = 1, scale = 1/rate) 함수는 주어진 형태 shape와 척도 scale(기본값 1/rate, rate의 기본값은 1)의 감마분포에서 n개의 난수를 생성하여 반환합니다. rgamma 함수명은 난수를 의미하는 r과 감마분포를 의미하는 gamma가 결합되어진 것입니다. # 형태가 1인 감마분포에서 난수 10개 생성 rgamma(n = 10, shape = 1) #&gt; [1] 1.367 0.370 0.128 1.778 1.192 1.304 0.679 2.363 1.072 0.333 # 평균이 50이고 표준편차기 3인 분포에서 난수 10개 생성 rgamma(10, shape = 1, rate = 0.001) #&gt; [1] 1185.22 922.18 796.91 1091.54 1804.10 957.21 1263.23 2501.09 8.34 #&gt; [10] 126.55 x &lt;- rgamma(n = 2000, shape = 1) hist(x) # 히스트그램이 정규분포 모양을 dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE) 함수는 감마분포의 확률밀도함수입니다. 형태 shape와 척도 scale의 감마분포에서 인자 x의 함수값을 구해 반환합니다. x &lt;- seq(-1, 5, by = 0.01) # 확률밀도함수 시각화 plot(x, dgamma(x, shape = 1), type = &quot;l&quot;, col = &quot;red&quot;) # x가 0.5일때의 함수값? dgamma(0.5, shape = 1) #&gt; [1] 0.607 x &lt;- seq(0, 10, by = 0.01) plot(x, dgamma(x, shape = 1, scale = 2), type = &quot;l&quot;, col = &quot;red&quot;) lines(x, dgamma(x, shape = 2, scale = 2), type = &quot;l&quot;, col = &quot;green&quot;) lines(x, dgamma(x, shape = 3, scale = 2), type = &quot;l&quot;, col = &quot;blue&quot;) lines(x, dgamma(x, shape = 4, scale = 2), type = &quot;l&quot;, col = &quot;purple&quot;) x &lt;- seq(0, 10, by = 0.01) plot(x, dgamma(x, shape = 2, scale = 2), type = &quot;l&quot;, col = &quot;red&quot;) lines(x, dgamma(x, shape = 2, scale = 3), type = &quot;l&quot;, col = &quot;green&quot;) lines(x, dgamma(x, shape = 2, scale = 4), type = &quot;l&quot;, col = &quot;blue&quot;) lines(x, dgamma(x, shape = 2, scale = 5), type = &quot;l&quot;, col = &quot;purple&quot;) pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) 함수는 감마분포의 누적분포함수입니다. 형태 shape와 척도 scale의 감마분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. x &lt;- seq(0, 5, by = 0.01) # 누적분포함수 시각화 plot(x, pgamma(x, shape = 1), type = &quot;l&quot;, col = &quot;red&quot;) # q가 0.5일때의 누적분포함수값은? 즉 확률은? pgamma(0.5, shape = 1) #&gt; [1] 0.393 # 가로축 1까지의 누적분포함수값(확률))은? pgamma(1, shape = 1) #&gt; [1] 0.632 # 0에서 1까지의 면적(핑크색)은 전체면적? x &lt;- seq(0, 5, by = 0.01) plot(x, dgamma(x, shape = 1), type = &quot;l&quot;, lwd = 2, col = &quot;red&quot;) u &lt;- seq(0, 1, by = 0.01) v &lt;- dgamma(u, shape = 1) polygon(c(0, u, 1), c(0, v, 0), col = &quot;pink&quot;) qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE) 함수는 감마분포의 분위수를 구하는 함수입니다. 형태 shape와 척도 scale의 감마분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. # 70% 분위수는? qgamma(0.7, shape = 1) #&gt; [1] 1.2 # 주어진 값의 %는? pgamma(1.2, shape = 1) #&gt; [1] 0.699 5.5.5 지수분포(exp) 지수분포는 감마분포의 특수한 경우라고 볼 수 있습니다. 감마분포가 α번째 사건이 일어날 때 까지 걸리는 시간에 대한 분포라면, 지수분포는 첫번째 사건이 발생할 때 까지 걸리는 시간에 대한 분포라고 할 수 있습니다. 두 분포함수의 인자를 기본값으로 하면 결과는 거의 동일하게 나옵니다. 참고로 지수분포와 포아송분포는 서로 반대되는 과점을 가지고 있습니다. 지수분포가 첫번째 사건이 발생할 때까지의 대기시간인 반면, 포아송분포는 단위 시간 당 발생하는 사건의 횟수입니다. 지수포는 대기시간, 포아송분포는 횟수입니다. 지수분포는 기하분포와도 관련이 있습니다. 지수분포는 사건이 발생할 때까지의 대기시간인 반면, 기하분포는 사건이 발생할 때까지의 시도횟수입니다. 지수분포와 관련된 함수는 다음 4가지 있습니다. rexp(n, rate = 1) dexp(x, rate = 1, log = FALSE) pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE) qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE) rexp(n, rate = 1) 함수는 주어진 감마값 rate(기본값 1)의 지수분포에서 n개의 난수를 생성하여 반환합니다. rexp 함수명은 난수를 의미하는 r과 지수분포를 의미하는 exp가 결합되어진 것입니다. set.seed(123) # 난수 10개 생성 rexp(n = 10, rate = 1) #&gt; [1] 0.8435 0.5766 1.3291 0.0316 0.0562 0.3165 0.3142 0.1453 2.7262 0.0292 set.seed(123) x &lt;- rexp(n = 2000, rate = 1) hist(x) # 히스트그램이 정규분포 모양을 dexp(x, rate = 1, log = FALSE) 함수는 지수분포의 확률밀도함수입니다. 주어진 감마값 rate(기본값 1)의 지수분포에서 인자 x의 함수값을 구해 반환합니다. x &lt;- seq(0, 7, by = 0.01) # 확률밀도함수 시각화 plot(x, dexp(x, rate = 1), type = &quot;l&quot;, col = &quot;red&quot;) # x가 0.5일때의 함수값? dexp(0.5, rate = 1) #&gt; [1] 0.607 pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE) 함수는 지수분포의 누적분포함수입니다. 주어진 rate(기본값 1)의 지수분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. x &lt;- seq(0, 5, by = 0.01) # 누적분포함수 시각화 plot(x, pexp(x, rate = 1), type = &quot;l&quot;, col = &quot;red&quot;) # q가 0.5일때의 누적분포함수값은? 즉 확률은? pexp(0.5, rate = 1) #&gt; [1] 0.393 # 가로축 1까지의 누적분포함수값(확률))은? pexp(1, rate = 1) #&gt; [1] 0.632 # 0에서 1까지의 면적(핑크색)은 전체면적? x &lt;- seq(0, 5, by = 0.01) plot(x, dexp(x, rate = 1), type = &quot;l&quot;, lwd = 2, col = &quot;red&quot;) u &lt;- seq(0, 1, by = 0.01) v &lt;- dexp(u, rate = 1) polygon(c(0, u, 1), c(0, v, 0), col = &quot;pink&quot;) qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE) 함수는 지수분포의 분위수를 구하는 함수입니다. 주어진 rate의 지수분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. qexp(0.7, rate = 1) #&gt; [1] 1.2 pexp(1.204, rate = 1) #&gt; [1] 0.7 5.5.6 베타분포(beta) 5.5.7 t분포(t) 5.5.8 카이제곱분포(chisq) 5.5.9 F분포(f) 5.5.10 웨이블분포(weibull) 5.5.11 로그정규분포(lnorm) 5.5.12 베르누이분포 이산확률분포 베르누이분포, 이항분포, 다항분포, 초기하분포, 기하분포, 음이항분포, 포아송분포 베르누이분포는 이항분포의 특수한 경우입니다. 5.5.13 이항분포(binom) 베르누이 분포 정규분포는 분포가 종 모양의 형태로 평균에 가까울수록 발생확률이 높고 평균에서 멀어질수록 발생할 확률이 낮은 분포입니다. 가우스가 처음 정립해서 가우시안(Gaussian) 분포라고도 합니다. 영어로는 normal distribution입니다. 정규분포와 관련된 함수는 다음 4가지 있습니다. 5.5.14 다항분포(multinom) 5.5.15 초기하분포(hyper) 5.5.16 기하 분포(geom) 5.5.17 음이항 분포(nbinom) 5.5.18 포아송분포(pois) 5.5.19 코시 분포(cauchy) 5.5.20 mean(x) 5.5.21 median(x) 5.5.22 weighted.mean(x, w) 5.5.23 var(x) 5.5.24 sd(x) 5.5.25 max(x) 5.5.26 min(x) 5.5.27 pmin(x,y,…) 5.5.28 pmax(x,y,…) 병렬최대값 5.5.29 range(x) 5.5.30 quantile(x,probs=) 5.5.31 cov(x) 5.5.32 cor(x) 5.5.33 var(x, y) or cov(x, y) 5.5.34 cor(x, y) 5.5.35 rank(x) 5.5.36 Optimization and model fitting 5.5.37 optim(par, fn, method = c(“Nelder-Mead”, “BFGS”, 5.5.38 “CG”, “L-BFGS-B”, “SANN”) 5.5.39 nlm(f,p) 5.5.40 lm(formula) 5.5.41 glm(formula,family=) 5.5.42 nls(formula) 5.5.43 approx(x,y=) 5.5.44 spline(x,y=) 5.5.45 loess(formula) 5.5.46 predict(fit,…) 5.5.47 df.residual(fit) 5.5.48 coef(fit) 5.5.49 residuals(fit) 5.5.50 deviance(fit) 5.5.51 fitted(fit) 5.5.52 logLik(fit) 5.5.53 AIC(fit) 5.5.54 aov(formula) 5.5.55 anova(fit,…) 5.5.56 density(x) 5.5.57 binom.test() 5.5.58 prop.test() 5.5.59 rnorm(n, mean=0, sd=1) 5.5.60 rexp(n, rate=1) 5.5.61 rgamma(n, shape, scale=1) 5.5.62 rpois(n, lambda) 5.5.63 rweibull(n, shape, scale=1) 5.5.64 rcauchy(n, location=0, scale=1) 5.5.65 rbeta(n, shape1, shape2) 5.5.66 rt(n, df) 5.5.67 rf(n, df1, df2) 5.5.68 rchisq(n, df) 5.5.69 rbinom(n, size, prob) 5.5.70 rgeom(n, prob) 5.5.71 rhyper(nn, m, n, k) 5.5.72 rlogis(n, location=0, scale=1) 5.5.73 rlnorm(n, meanlog=0, sdlog=1) 5.5.74 rnbinom(n, size, prob) 5.5.75 rwilcox(nn, m, n), rsignrank(nn, n) 5.5.76 lgamma, gamma, digamma, trigamma "],
["r-날짜와-시간-함수.html", "5.6 R 날짜와 시간 함수", " 5.6 R 날짜와 시간 함수 seq() difftime() as.Date(s) and as.POSIXct(s) format(dt) %a, %A Abbreviated and full weekday name. %b, %B Abbreviated and full month name. %d Day of the month (01–31). %H Hours (00–23). %I Hours (01–12). %j Day of year (001–366). %m Month (01–12). %M Minute (00–59). %p AM/PM indicator. %S Second as decimal number (00–61). %U Week (00–53); the first Sunday as day 1 of week 1. %w Weekday (0–6, Sunday is 0). %W Week (00–53); the first Monday as day 1 of week 1. %y Year without century (00–99). Don’t use. %Y Year with century. %z (output only.) Offset from Greenwich; -0800 is 8 hours west of. %Z (output only.) Time zone as a character string (empty if not available). "],
["r-객체-함수.html", "5.7 R 객체 함수", " 5.7 R 객체 함수 5.7.1 객체 클라스와 타입 조사 typeof() str() class(x) unclass(x) attr(x,which) attributes(obj) 5.7.2 데이터 차원 조사 dim nrow ncol 5.7.3 객체정보 함수 length(x) dimnames(x) is.na(x), is.null(x), is.array(x), is.data.frame(x), is.numeric(x), is.complex(x), is.character(x), 5.7.4 객체변환 함수 as.array(x), as.data.frame(x), as.numeric(x), as.logical(x), as.complex(x), as.character(x), "],
["r-문자열-함수.html", "5.8 R 문자열 함수", " 5.8 R 문자열 함수 paste(…) substr(x,start,stop) strsplit(x,split) grep(pattern,x) gsub(pattern,replacement,x) tolower(x) toupper(x) match(x,table) pmatch(x,table) nchar(x) 5.8.1 정규표현식 "],
["r-데이터-관리-함수.html", "5.9 R 데이터 관리 함수", " 5.9 R 데이터 관리 함수 c(…) seq(from,to) seq(along=x) rep(x,times) rep(c(1,2,3),each=2) all.equal identical data.frame(…) list(…) array(x,dim=) matrix(x,nrow=,ncol=) factor(x,levels=) gl(n,k,length=n*k,labels=1:n) expand.grid() rbind(…) cbind(…) Data selection and manipulation which.max(x) which.min(x) rev(x) sort(x) rev(sort(x)) cut(x,breaks) match(x, y) which(x == a) choose(n, k) na.omit(x) na.fail(x) unique(x) table(x) subset(x, …) sample(x, size) prop.table(x,margin=) by(data,INDEX,FUN) merge(a,b) xtabs(a b,data=x) aggregate(x,by,FUN) stack(x, …) unstack(x, …) reshape(x, …) "],
["r-입출력-함수.html", "5.10 R 입출력 함수", " 5.10 R 입출력 함수 load() data(x) library(x) read.table(file) read.csv(“filename”,header=TRUE) read.delim(“filename”,header=TRUE) read.fwf(file,widths,header=FALSE,sep=\"“,as.is=FALSE)  save.image(file) cat(…, file=”“, sep=” “) print(a, …) format(x,…) write.table(x,file=”“,row.names=TRUE,col.names=TRUE, sep=” \") sink(file) "],
["r-시스템-함수.html", "5.11 R 시스템 함수", " 5.11 R 시스템 함수 "],
["r-사용자-정의-함수.html", "5.12 R 사용자 정의 함수", " 5.12 R 사용자 정의 함수 "],
["r-입출력-read-write.html", "6 R 입출력 Read &amp; Write ", " 6 R 입출력 Read &amp; Write "],
["데이터-불러오기.html", "6.1 데이터 불러오기", " 6.1 데이터 불러오기 "],
["데이터-저장하기.html", "6.2 데이터 저장하기", " 6.2 데이터 저장하기 "],
["백업-및-복원.html", "6.3 백업 및 복원", " 6.3 백업 및 복원 "],
["r-그래프-graphs-charts.html", "7 R 그래프 Graphs &amp; Charts ", " 7 R 그래프 Graphs &amp; Charts "],
["bar-plot.html", "7.1 Bar Plot", " 7.1 Bar Plot "],
["histogram.html", "7.2 Histogram", " 7.2 Histogram "],
["pie-chart.html", "7.3 Pie Chart", " 7.3 Pie Chart "],
["box-plot.html", "7.4 Box Plot", " 7.4 Box Plot "],
["strip-chart.html", "7.5 Strip Chart", " 7.5 Strip Chart "],
["r-객체와-클래스-objects-class.html", "8 R 객체와 클래스 Objects &amp; Class ", " 8 R 객체와 클래스 Objects &amp; Class "],
["object-and-class.html", "8.1 Object and Class", " 8.1 Object and Class "],
["r-s3-class.html", "8.2 R S3 Class", " 8.2 R S3 Class "],
["r-s4-class.html", "8.3 R S4 Class", " 8.3 R S4 Class "],
["r-reference-class.html", "8.4 R Reference Class", " 8.4 R Reference Class "],
["r-inheritance.html", "8.5 R Inheritance", " 8.5 R Inheritance "]
]
