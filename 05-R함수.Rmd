# R 기본 함수

## R 수학 함수

### abs() 

`abs(x)`는 x의 절대값을 반환합니다.

```{r}
abs(-123)
```

### ceiling()

`ceiling(x)`는 x보다 큰 수 중 가장 작은 정수를 반환합니다.

```{r}
ceiling(2.5)
ceiling(-2.5)
```

### floor()

`floor(x)`는 x보다 작은 수 중 가장 큰 정수를 반환합니다.

```{r}
floor(2.5)
floor(-2.5)
```

### trunc()

`trunc(x)`는 0과 x사이의 가장 큰 정수를 반환합니다.

```{r}
trunc(2.5)
trunc(-2.5)
```
### round()

'round(x, digits = n)'는 x를 소수점 n+1 자리에서 반올림하여 소수점 n번째 자리까지 반환합니다. 만일 digits의 값이 음수이면 10^n-1^ 자리에서 반올림하여 0을 10^n^ 자리까지 만들어 반환합니다. digits 인자의 기본값은 0입니다.    
R의 반올림 함수는 국제표준(IEEE 754:2008, ISO/IEC/IEEE 60559:2011)을 따르고 있습니다. 따라서 Excel의 반올림 함수와는 다른 결과 값을 보여줍니다. 예를 들면 Excel에서 `=round(2.5, 0)`을 하면 3이 나오지만, R에서는 `round(2.5, digits = 0)`을 하게 되면 2가 나오게 됩니다.    
이는 위 부동소숫점 실수와 관련된 국제표준에서 반올림의 모드로 제시된 5가지 방법 중 **짝수로 반올림(round to nearest, ties to even)**를 기본모드로 선택하였기 때문입니다. '짝수로 반올림' 모드는 '은행원의 반올림', '오사오입'이라고도 불리우는 방법으로 반올림으로 인한 오류의 기대값을 0으로 하는 효과가 있습니다. 이 방법은 가장 가까운 표현 가능한 숫자로 반올림하되, 원래 값이 가능한 숫자 두 개의 중간에 걸쳐 있으면 둘 중 가수부의 마지막 자리가 짝수인 값으로 반올림합니다. 예를 들면 52.5는 52, 51.5는 52로 반올림합니다.

```{r}
round(.5 + -3:4)
round(2.2579, digits = 2)
round(2578.23, digits = -2)
```

### signif()

`signif(x, digits = n)`는 지정한 유효숫자(significant digits)인 n만큼 자리수를 만들어 반올림 합니다. digits 인자의 기본값은 6입니다. 숫자들의 열을 깔끔하게 맞추고자 할 때 많이 사용합니다.

```{r}
signif(3.141593, digits = 3)
signif(23.593, digits = 3)
```

### sqrt()

`sqrt(x)`는 x의 제곱근을 반환합니다.

```{r}
sqrt(9)
```

### 로그함수

* `log(x)`는 밑이 e인 x의 자연로그값을 반환합니다.
* `log10(x)`은 밑이 10인 x의 상용로그값을 반환합니다.
* `log2(x)`는 밑이 2인 x의 이진로그값을 반환합니다.
* `log(x, base)` 밑이 base인 x의 로그값을 반환합니다.
* `log1p(x)`는 밑이 e인 x+1의 자연로그값을 반환합니다.

```{r}
log(3)
log10(3)
log2(3)
log(3, 5)
log(0)
log1p(0)
```

### exp()

* `exp(x)`는 상수 e를 x만큼 제곱한 값을 반환합니다.
* `expm1(x)`는 상수 e를 x만큼 제곱한 값에서 1을 뺀 값을 반환합니다.

```{r}
exp(3)
exp(log(3))
expm1(3)
```

### 삼각함수

* `cos(x)`는 x 라디안 각도의 코사인 값을 반환한다.
* `sin(x)`는 x 라디안 각도의 사인 값을 반환한다.
* `tan(x)`는 x 라디안 각도의 탄젠트 값을 반환한다.
* `acos(x)`, `asin(x)`, `atan(x)`, `atan2(x)`는 역삼각함수입니다.
* `cospi(x)`, `sinpi(x)`, `tanpi(x)` 는 `pi*x`의 삼각함수입니다. 입력이 pi의 배수일 때 정밀한 계산을 위해 사용합니다.

```{r}
sin(pi)
sin(1)
sinpi(3)
asin(1)
```
```{r}
# 사인 곡선 (Sign Curve)
x <- seq(-10, 10, 0.1)
plot(x, sin(x), type = "l", col = "blue", 
     ylab = "", xlab = "", main = "삼각함수 그래프")
lines(x, cos(x), type = "l", col = "red")
legend("topleft", c("sin(x)", "cos(x)"), fill=c("blue", "red"))
```
```{r}
# 삼각함수 그래프
x <- seq(0, 2*pi, 0.1)
plot(x, sin(x), type = "l", col = "blue", 
     ylab = "", xlab = "", main = "사인 곡선")
```

### 누적함수

* `cumsum(x)` x 벡터의 누적 합 벡터를 반환합니다.
* `cumprod(x)` x 벡터의 누적 곱 벡터를 반환합니다.
* `cummax(x)` x 벡터의 누적 최대값 벡터를 반환합니다.
* `cummin(x)` x 벡터의 누적 최소값 벡터를 반환합니다.

```{r}
cumsum(1:10)
cumprod(1:9)

# 오른쪽으로 숫자를 이동하면서 과거 지나온 숫자를 비교하여 최대 또는 최소값을 반환
(x <- c(3:1, 2:0, 4:2))
cummax(x)
cummin(x)
```

### sum()

`sum(x, na.rm = FALSE)`는 x벡터의 합계를 반환합니다.

```{r}
sum(1:5)
sum(1:5, NA)
sum(1:5, NA, na.rm = TRUE)
```

### diff()

`diff(x, lag = 1, differences = 1)`는 두 수의 차이값을 반환합니다. lag 인수는 두 수의 간격을 나타냅니다. `lag = 2`이면 두 칸 간격의 두 수 차이입니다. differences 인수는 차분의 차수입니다. `differences = 2`이면 차분을 두번한 값을 반환합니다.

```{r}
x <- c(1, 5, 10, 16, 23)
diff(x)   # 5-1, 10-5, ...
diff(x, lag = 2)   # 10-1, 16-5, ...
diff(x, differences = 2)   # diff(diff(x)), (10-5)-(5-1), ...
```

### prod()

`prod(x, na.rm = FALSE)`는 x 벡터의 곱을 반환합니다.

```{r}
prod(2, 3, 5)   # 2*3*5
prod(c(2, 3, 5, NA), na.rm = TRUE)
prod(1:5)     # 1*2*3*4*5
gamma(6)      # 1*2*3*4*5
factorial(5)  # 1*2*3*4*5
```

### gamma(), factorial()

감마함수(gamma function)는 오일러(Leonhard Euler)가 정수만 적용되는 **n!**을  실수로 확장하기 위해 제안한 함수입니다. 

* `gamma(x)`는 x-1의 계승값을 반환합니다. 즉 gamma(x)는 factorial(x-1)과 동일합니다.
* `factorial(x)`는 x의 계승값을 반환합니다.

```{r}
gamma(6)
factorial(5)
gamma(5.32)
factorial(4.32)
```

```{r}
# lgamma()는 gamma()의 결과값에 자연로그를 적용하는 함수
lgamma(6)
log(gamma(6))
```
```{r}
# lfactorial()은 factorial()의 결과값에 자연로그를 적용하는 함수
lfactorial(5)
log(factorial(5))
lgamma(5+1)
```
`gamma()` 함수와 연관된 함수는 `lgamma()` 외에도 `psigamma(x, deriv = 0)`, `digamma(x)`, `trigamma(x)`가 있습니다.

### beta()

베타함수는 감마함수를 만든 오일러가 만든 함수입니다. 감마보다 먼저 만들어진 함수라서 알파, 베타, 감마의 순서에 따라 베타함수로 이름이 지어졌습니다. 베타함수는 이항계수의 일반화라고 할 수 있습니다. 

```{r}
beta(2, 5)
```

### choose()

`choose(n, k)`는 n개에서 순서에 상관없이 k개를 뽑는 경우의 수를 반환합니다.
수식은 $n!/(n-k)!k!$ 입니다.

```{r}
choose(5, 2)

# 로또 확률 (45개 중 순서에 상관없이 6개 뽑기)
choose(45, 6)
```
### 복소수 함수

R에서는 복소수 관련 연산이나 함수를 지원합니다. 

* `Re(x)`는 복소수 x의 실수(Real) 부분을 반환합니다.
* `Im(x)`는 복소수 x의 허수(Imaginary) 부분을 반환합니다.
* `Mod(x)`는 복소수 x의 절대값(modulus)을 반환합니다.
* `Arg(x)`는 복소수 x의 편각(argument)을 반환합니다.
* `Conj(x)`는 복소수 x의 공액 복소수(허수부의 부호만 바뀐 복소수)를 반환합니다.

```{r}
x <- 2 + 3i
Re(x)
Im(x)
Mod(x)
Arg(x)
Conj(x)
```

### 집합 함수

* `union(x, y)`는 x와 y의 합집합을 반환합니다.
* `intersect(x, y)`는 x와 y의 교집합을 반환합니다.
* `setdiff(x, y)`는 x에 있고 y에는 없는 (x-y)차집합을 반환합니다.
* `setequal(x, y)`는 x와 y가 같은지 비교검사 결과를 반환합니다.
* `is.element(el, set)`는 el에 있는 각 원소들이 set집합에 포함되는지를 검사합니다. `x %in% y`와 동일합니다.

```{r}
set.seed(123)
(x <- c(sort(sample(1:20, 9)), NA))
(y <- c(sort(sample(3:23, 7)), NA))

union(x, y)         # 합집합
intersect(x, y)     # 교집합
setdiff(x, y)       # 차집합(x-y)
setdiff(y, x)       # 차집합(y-x)
setequal(x, y)      # 비교

is.element(x, y)    
x %in% y            # is.element(x, y)와 동일

all(is.element(x, y))  # x가 y에 모두 포함되어 있으면 TRUE
```

### 푸리에 함수

* `fft(x, inverse = FALSE)`는 x의 고속 푸리에 변환 값을 반환합니다.
* `mvfft(x, inverse = FALSE)`는 행렬 x의 각 열의 고속 푸리에 변환 값을 반환합니다.
* `filter(x, filter)`는 시계열에 선형 필터를 적용합니다.
* `convolve(x, y)` 

```{r}
(x <- matrix(c(1, 2, 3, 2, 20, 26, 3, 26, 38), nrow = 3))
fft(x)
mvfft(x)
```
```{r}
x <- 1:5
filter(x, rep(1, 3), method="recursive")

```

### 수치해석 함수

* polyroot 근구하기
* uniroot
* D 미분
* integrate 적분



## R 행렬 함수

### t()

`t(x)`는 행렬 x의 전치행렬(행과 열이 서로 바뀜)을 반환합니다.

```{r}
(x <- matrix(1:12, 3, 4))
t(x)
```

### diag()

`diag(x = 1, nrow, ncol, names = TRUE)`는 대각행렬을 반환합니다.

```{r}
# 주대각선의 원소가 모두 1인(단위행렬) 3x3 대각행렬
diag(3)  

# 주대각선의 원소가 모두 10인 3x4 대각행렬
diag(10, 3, 4)

# 주대각선의 원소를 지정한 대각행렬
diag(c(2, 5, 3, 1))

# 행렬 x의 대각행렬
(x = matrix(c(1,3,-2, 5, 7, -3, 1, 0, 1), 3, 3))
diag(x)
```

### %*%   

`x %*% y`는 행렬 x와 행렬 y의 곱셈 결과를 반환합니다.

```{r}
(x <- 1:4)
(y <- diag(x))
(z <- matrix(1:12, ncol = 3, nrow = 4))

x %*% x
y %*% z
y %*% x
x %*% z
```

### outer()

`outer(x, y, FUN = "*", ...)`는 두 벡터 또는 배열의 외적(outer product)를 반환합니다. 외적이란 x에 y의 전치행렬을 곱한 결과입니다.    
`outer(x, y)`는 `x %*% t(y)`와 동일하며, `x%o%y`와 동일합니다.

```{r}
(x <- 1:4)
(y <- 5:8)
outer(x, y)
x %*% t(y)
x%o%y
```

`outer(x, y, FUN = "*", ...)`에서 `FUN = "*"`로 인해 곱셈을 합니다. 만일 기본값인 *을 +로 변경하면 덧셈을 하게 됩니다.

```{r}
outer(x, y, FUN = "+")
```

### solve()

`solve(a, b, ...)`는 수식 a %*% x = b에서 x를 구하여 반환합니다. 
만일 b를 지정하지 않으면 a의 역행렬을 반환합니다.

```{r}
(a <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))
(b <- c(2, -1, 1))

# ax=b에서 x를 구하여 반환
solve(a, b)  

# a의 역행렬을 반환환
solve(a)
```

### rowSums()

`rowSums(x, na.rm = FALSE, dims = 1)`는 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 행 합계를 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))
rowSums(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

rowSums(df)
```

### colSums()

`colSums (x, na.rm = FALSE, dims = 1)`은 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 열 합계를 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))

colSums(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

colSums(df)
```

### rowMeans()

`rowMeans(x, na.rm = FALSE, dims = 1)`는 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 행 평균을 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))
rowMeans(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

rowMeans(df)
```

### colMeans()

`colMeans (x, na.rm = FALSE, dims = 1)`은 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 열 합계를 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))

colMeans(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

colMeans(df)
```

### nrow(), ncol()

* `nrow(x)`는 행의 갯수를 반환합니다.
* `ncol(x)`는 열의 갯수를 반환합니다.
* `NROW(x)`는 행의 갯수를 반환합니다. (벡터 계산 가능)
* `NCOL(x)`는 열의 갯수를 반환합니다. (벡터 계산 가능)

```{r}
x <- matrix(1:12, 3, 4)
nrow(x)
ncol(x)
NROW(x)
NCOL(x)
```
```{r}
(x <- array(1:24, dim = c(3,4,2)))  # 3행*4열의 3차원 배열
nrow(x)
ncol(x)
```

NROW와 NCOL은 행렬이 아닌 벡터도 계산합니다.

```{r}
x <- 1:12
nrow(x)
NROW(x)
ncol(x)
NCOL(x)
```

### det()

`det(x)`는 행렬 x의 행렬식을 구하여 반환합니다. 행렬식은 정방행렬(nxn 행렬)인 경우에만 구할 수 있습니다.
$det \begin{pmatrix}a&b\\c&d\end{pmatrix} = ad-bc$

```{r}
(x <- matrix(1:4, nrow = 2))
det(x)
```

### eigen()

`eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE)`는 행렬 x의 고유값과 고유벡터를 반환합니다.

고유값과 고유벡터는 행렬 A에 대하여 $Av = \lambda v$ 등식을 만족하는 상수와 열벡터입니다. 등식에서 v는 고유벡터이고 $\lambda$는 고유값입니다.
고유값과 고유벡터는 정방행렬(nxn 행렬)인 경우에만 구할 수 있습니다.

```{r}
(x <- matrix(1:4, nrow = 2))
eigen(x)
```

### svd()

`svd(x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)`는 행렬 x의 특이값을 분해하여 그 결과를 반환합니다.

고유값 분해는 정방행렬(nxn 행렬)인 경우에만 가능합니다. 이를 직사각행렬(mxn행렬)에서도 가능하게 만든 것이 특이값 분해(SVD: Singular Value Decomposition)입니다.

$M = UDV^T$

```{r}
x <- matrix(c(0, 0, 0, 1, 1, 0, 0, 0,
              1, 0, 0, 1, 1, 0, 0, 0,
              0, 0, 0, 1, 1, 0, 0, 0,
              1, 1, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1,
              0, 0, 0, 1, 1, 0, 0, 0,
              0, 0, 0, 1, 1, 0, 0, 0,
              0, 0, 0, 1, 1, 0, 0, 0),
            byrow = TRUE, nrow = 10)
x
x_svd <- svd(x)
x_svd

# 특이값 벡터 d의 첫번째와 두번째 값을 이용하여 원래 행렬 구하기
round(x_svd$u[,c(1,2)] %*% diag(x_svd$d[c(1,2)]) %*% t(x_svd$v[,c(1,2)]))
```

### qr()

`qr(x)`은 행렬 x의 QR 분해결과를 반환합니다. 
QR분해는 행렬 A를 $A = QR$로 분해하는 것입니다. Q는 단위 노름 직교 벡터를 갖는 행렬이고, R은 상삼각행렬입니다.

```{r}
x <- matrix(c(1,2,3, 2,4,6, 3,3,3), nrow=3)
x_qr <- qr(x)
x_qr
```

### scale()

`scale(x, center = TRUE, scale = TRUE)`는 행렬이나 벡터 x를 정규화(표준화)한 결과를 반환합니다. 옵션 center는 평균을 의미하며, scale은 표준편차를 의미합니다.
x가 벡터일 경우 $z = (x-u)/\sigma$를 구해서 반환합니다. center가 FALSE이면 값에서 평균을 빼지 않으며, scale이 FALSE이면 표준편차로 나누지 않습니다.

```{r}
# 1~9 벡터를 표준화하기 (평균을 빼고 표준편차로 나눔)
(x <- 1:9)
scale(x)
```

x가 행렬일 경우에는 열을 기준으로 평균과 표준편차를 구한 후, 열 기준으로 표준화를 합니다.

```{r}
(x <- matrix(1:9, ncol = 3))
scale(x)
```

## R 논리 함수

### any()

`any(..., na.rm = FALSE)`는 주어진 논리 벡터 중에 어느 하나라도 TRUE이면 TRUE를 반환합니다.

```{r}
# 어느 하나라도 0미만 이면 TRUE 반환
(x <- seq(-3, 3, by = 1))
any(x < 0)
if (any(x < 0)) cat("x는 음수를 포함하고 있습니다\n")
```

### all()

`all(..., na.rm = FALSE)`는 주어진 논리 벡터 모두가 TRUE이면 TRUE를 반환합니다. 어느 하나라도 FALSE가 있으면 FALSE를 반환합니다.

```{r}
(x <- seq(-3, 3, by = 1))
all(x < 0)

if (all(x >= -3 )) cat("x에 포함된 수는 모두 -3 이상입니다\n")
```

### which()

`which(x, arr.ind = FALSE, useNames = TRUE)`는 벡터(또는 배열) x에서 TRUE인 것의 위치를 반환합니다. x가 배열인 경우 arr.ind = TRUE이면 배열형태의 위치를 반환합니다.

```{r}
# 벡터 위치 반환
(x <- 5:10)
which(x == 7)
x[which(x == 7)]
```

```{r}
# 배열 위치 반환
x <- 5:16
dim(x) <- c(2, 2, 3); x  # x를 2x2 행렬의 3층 배열로 만들기
which(x == 15)                    # 벡터형태의 위치 반환
which(x == 15, arr.ind = TRUE)    # 배열형태의 위치 반환
```


```{r}
# 행렬 위치 반환 (배열과 유사)
x <- matrix(5:16, 3, 4); x
which(x %% 3 == 0)                   # 벡터형태의 위치 반환
which(x %% 3 == 0, arr.ind = TRUE)   # 행렬형태의 위치 반환
```

```{r}
# 데이터 프레임 위치 반환
str(women)   # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드)
which(women$height < 60)
women[which(women$height < 60),]
```

### which.min()

`which.min(x)`는 벡터 x의 최소값 위치를 반환합니다.

```{r}
# 벡터
x <- c(1:4, 0:5, 11); x
which.min(x)
```
```{r}
# 데이터프레임
str(women)   # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드)
which.min(women$weight)
women[which.min(women$weight)]
```

### which.max()

`which.max(x)`는 벡터 x의 최대값 위치를 반환합니다.

```{r}
# 벡터
x <- c(1:4, NA, 11, 0:5); x
which.max(x)
```
```{r}
# 데이터프레임
str(women)   # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드)
which.max(women$weight)
women[which.max(women$weight),]
```

### isTRUE()

`isTRUE(x)`는 x가 TRUE이면 TRUE를 반환합니다. 유사한 것으로 `isFALSE(x)`가 있습니다.

```{r}
x <- TRUE
isTRUE(x)
isFALSE(x)
```


## R 반복 함수

### apply()

`apply(X, MARGIN, FUN, …)`는 X를 입력받아 행 또는 열 방향으로 함수를 적용하여 결과값을 반환합니다. MARGIN 인수가 1이면 행 방향으로, 2이면 열 방향으로 연산이 됩니다.
apply 함수에 입력하는 데이터(X)는 배열, 매트릭스만 가능하고, 만일 데이터프레임이 모두 같은 데이터 타입이면 가능합니다. 반환되는 값은 벡터나 행렬입니다.

```{r}
(x <- matrix(1:12, c(3,4)))
apply(x, 1, mean)   # 행 방향으로 평균
apply(x, 2, mean, na.rm = TRUE)   # 열 방향으로 평균, mean함수 옵션 추가
```
벡터는 apply에 입력데이터로 사용할 수 없습니다(에러 발생). 만일 벡터를 사용하고자 한다면 배열로 변환하여 사용하여야 합니다.

```{r}
x <- 1:12
dim(x) <- c(1, length(x)); x     # 벡터를 배열로 변환
apply(x, 1, mean)
```
함수는 사용자 정의 함수를 만들어서 사용할 수 있습니다.
```{r}
(x <- matrix(1:12, c(3,4)))
apply(x, 2, function(x) {x*2})

# 행방향으로 하면 행과 열이 바뀝니다.
apply(x, 1, function(x) {x})
apply(x, 1, function(x) {x*2})
```

데이터프레임도 데이터가 모두 같은 타입이라면 apply를 적용할 수 있습니다. R의 기본 데이터셋인 iris에서 Factor 타입인 Species를 제거한 후 apply에 사용하도록 하겠습니다.

```{r}
str(iris)
x <- iris[, -5]; str(x)
apply(x, 2, mean, na.rm = TRUE)
apply(x, 2, function(x) {median(x*2-1, na.rm = TRUE)})
```

### lapply()

`lapply(X, FUN, …)`는 X를 입력받아 함수를 적용하여 결과값을 반환합니다. 
lapply 함수에 입력하는 데이터(X)는 벡터, 리스트 등도 가능하고, 반환되는 값은 리스트입니다. 

apply는  X의 행이나 열 방향의 데이터가 한꺼번에 함수로 전달되는 반면에, lapply는 X의 데이터 요소가 하나 하나 함수로 전달됩니다. 행렬이나 배열의 요소는 기본적으로 벡터의 요소와 같은 방식이기 때문에 값이 하나 하나 전달됩니다. 

```{r}
# 아래와 같이 코드를 실행하면 x의 평균이 반환되지 않습니다.
# x값이 하나 하나 mean 함수에 전달되어 각각 계산되기 때문입니다.
x <- matrix(1:6, c(2,3))
lapply(x, mean, na.rm = TRUE)
```

lapply는 리스트로 반환이 됩니다. 이를 벡터로 변환하고자 한다면 unlist 함수를 적용합니다.

```{r}
x <- 1:3
lapply(x, function(x) {x*2+1})          # 리스트 형태로 반환
unlist(lapply(x, function(x) {x*2+1}))  # 리스트를 벡터로 변환하여 반환
```
데이터프레임도 lapply 함수에 입력데이터로 사용 가능합니다. 데이터프레임의 각 요소 즉 각 변수별로 한꺼번에 함수에 전달됩니다.

```{r}
str(iris)
lapply(iris, mean, na.rm = TRUE)
```

리스트가 입력되면 리스트의 각 요소가 한꺼번에 함수에 전달됩니다. 예를 들어 mean함수를 사용하면 리스트 각 요소별 평균값을 반환합니다.

```{r}
x <- list(a = 1:10, 
          beta = exp(-3:3), 
          logic = c(TRUE,FALSE,FALSE,TRUE))
x
lapply(x, mean)
lapply(x, quantile, probs = (1:3)/4)
```

### sapply() 

`sapply(X, FUN, …, simplify = TRUE, USE.NAMES = TRUE)`는 단순화된(simplify) lapply 함수라 할 수 있습니다. lapply는 리스트 형태로 반환되기 때문에 사용하기 불편한 점이 있는데 sapply는 기본적으로 벡터나 행렬 형태로 반환합니다. 만일 옵션 simplify = FALSE이면 lapply와 동일하게 리스트 형태로 반환됩니다. 

```{r}
x <- 1:3
sapply(x, function(x) {x*2+1})    
```
```{r}
str(iris)
sapply(iris, mean, na.rm = TRUE)
```
```{r}
x <- list(a = 1:10, 
          beta = exp(-3:3), 
          logic = c(TRUE,FALSE,FALSE,TRUE))
x
sapply(x, mean)
sapply(x, quantile, probs = (1:3)/4)
```

### vapply()

`vapply(X, FUN, FUN.VALUE, …, USE.NAMES = TRUE)`는 sapply와 유사합니다. 차이점은 반환되는 결과의 양식을 지정할 수 있습니다.

```{r}
str(iris)
# sapply로 fivenum 출력
sapply(iris[, 1:4], fivenum, na.rm = TRUE)

# vapply로 fivenum 출력, 출력양식 지정
vapply(iris[, 1:4], fivenum, 
       c("최소값" = 0, "1사분위수" = 0, "중위수" = 0, 
         "3사분위수" = 0, "최대값" = 0),
       na.rm = TRUE)

```

### tapply()

`tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)`는 요인(factor) 변수를 기준으로 그룹별로 나누어서 함수를 적용합니다. X는 벡터입니다. INDEX는 요인 또는 요인 리스트가 들어가는 인수입니다. 만일 X에 데이터프레임을 넣고 싶으면 `by()`함수를 쓰면 됩니다.

```{r}
# iris 데이터의 요인변수 Species 별로 평균 구하기
str(iris)
tapply(iris$Sepal.Length, iris$Species, mean, na.rm = TRUE)
```

```{r}
# 팩터변수가 2개가 되면 교차표가 만들어짐
# x[, -1]은 wool과 tension으로 구성된 데이터프레임
str(x <- warpbreaks)
tapply(x$breaks, x[, -1], sum)
```

```{r}
# 데이터 무작위 30개 만들어 x에 할당
set.seed(234)
x <- c(rnorm(10), runif(10), rnorm(10, 1))
str(x)

# 팩터 변수 생성(값 30개)
# gl(n, k)는 1부터 n까지 정수로된 팩터 레벨을 k만큼 반복해서 만듬 
fac <- gl(3, 10)   # factor(rep(1:3, each = 10), levels = 1:3)와 동일
fac
  
tapply(x, fac, mean)
tapply(x, fac, range)
```

### mapply() 

`mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)`는 
sapply의 다변량 버전이라 할 수 있습니다. 여러 개의 인자를 입력할 수 있고, 
반환하는 값은 리스트, 벡터, 배열 등이 가능합니다.
MoreArgs는 함수에 들어갈 또다른 인수 리스트입니다.

```{r}
# rep(1, 4), rep(2, 3), ..., rep(x = 4, times = 1)  => 리스트 반환
mapply(rep, 1:4, 4:1) 

# rep(1, 3), rep(2, 3), ..., rep(x = 4, times = 3)  => 행렬 반환
mapply(rep, 1:4, 3)

# rep(times = 1, x = 4), rep(times = 2, x = 3), ... 
mapply(rep, times = 1:4, x = 4:1)

# rep(x = 23, times = 1), rep(x = 23, times = 2), ...  
mapply(rep, 1:4, MoreArgs = list(x = 23))
```

```{r}
# sprintf(" %d%s ", 1, "a"), ....
mapply(function(i, s) { 
  sprintf(" %d%s ", i, s) 
  }, 
  i = 1:3, s = c("a", "b", "c"))
```

MoreArgs 인수는 여러 개의 데이터를 한꺼번에 함수에 넣어줍니다. 
이 것을 사용하지 않으면 데이터가 하나씩 함수에 들어갑니다.

```{r}
sumsq <- function(x, mean = 0, sd = 1) {
  sum(((x - mean) / sd)^2)
}

set.seed(123)
x <- rnorm(10000)

# sumsq(x, mean = 1, sd = 1), sumsq(x, mean = 2, sd = 2), ...
mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x))

# 만일 이렇게 mapply(sumsq, mean = 1:100, sd = 1:100, x = x) 하면
# sumsq(x = x[1], mean = 1, sd = 1), ... 이런식으로 계산되어
# 원하는 결과가 나오지 않음. 여기서 x[1]은 -0.560475647임
```


### eapply()

`eapply(env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE)`는 환경(Environment)에 있는 변수나 함수들을 반복 계산해 줍니다.

```{r}
# 새로운 환경 만들기; R에서 전역환경은 .GlobalEnv 임
env <- new.env()
env$a <- 10
env$b <- 20:23
env$c <- 30:35

# 전역변수 자료형 확인하기
eapply(env, typeof)

# env 환경변수의 각 요소에 2를 곱하기
eapply(env, function(x) {x * 2})
```

### by()

`by(data, INDICES, FUN, …, simplify = TRUE)`는 데이터프레임을 위한 tapply라 할 수 있다. 요인(factor) 변수를 기준으로 그룹별로 나누어서 함수를 적용합니다. data는 데이터프레임이나 행렬입니다. INDEX는 요인 또는 요인 리스트가 들어가는 인수입니다.

```{r}
str(iris)
by(iris, iris$Species, summary)
```

```{r}
# 팩터변수가 2개가 되면 그만큼 그룹으로 더 나뉘어짐
# x[, -1]은 wool과 tension으로 구성된 데이터프레임
str(warpbreaks)
by(warpbreaks[, 1], warpbreaks[, -1], summary)
```

### split()

* `split(x, f, drop = FALSE, ...)`은 f에 정의된 그룹(보통 팩터 또는 리스트)에 따라 벡터 x를 분리합니다. 반환되는 값은 리스트입니다.
* `unsplit(value, f, drop = FALSE)`은 분리된 벡터 리스트 또는 데이터프레임인 value를 f에 정의된 그룹기준으로 원상태로 되돌립니다. 반환되는 값은 벡터나 데이터프레임입니다.

```{r}
str(iris)

# iris 데이터프레임을 Species 기준으로 분리합니다. (결과 리스트 형태) 
x <- split(iris, iris$Species)
str(x)

# 분리된 것을 다시 원상태로 돌립니다. (결과 데이터프레임)
y <- unsplit(x, iris$Species)
str(y)
```

두 개 칼럼을 기준으로 분리할 수 있습니다. 2개 이상의 칼럼을 기준으로 할 때에는 리스트 구조로 묶어줍니다.

```{r}
str(infert)  # R 내장 데이터 infert

x <- split(infert, list(infert$spontaneous, infert$education))
str(x, max.level = 1)
```

행의 갯수를 지정해서 데이터를 분리할 수 있습니다. 인수 f에 데이터를 나눌 기준이 될 벡터을 만들면 됩니다. 그러면 같은 수를 가진 행끼리 하나의 그룹으로 만들어집니다. 단, 이 기준 벡터의 수와 데이터의 갯수가 같아야 오류가 나지 않습니다.

```{r}
# infert 데이터의 전체 행을 10개씩 구분하는 기준 벡터를 만듭니다. 
df <- iris     # 데이터
gnum <- 10     # 그룹의 갯수
f <- c(rep(1:floor((nrow(df)/gnum)), each = gnum),
       rep(ceiling(nrow(df)/gnum), each = nrow(df)%%gnum))

x <- split(df, f)
print(x[1:2]); cat("... 이하 생략 ...")
```

```{r}
# 위 예제에서 분리된 것을 같은 기준으로 하나로 묶습니다.
y <- unsplit(x, f)
str(y)
```

### Vectorize()

`Vectorize(FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, USE.NAMES = TRUE)`
함수는 인자 FUN에 들어간 함수가 벡터 방식으로 작동하도록 만드는 함수입니다. 함수 중에는 함수의 인자가 단 하나의 값만 들어가야 하는 경우가 있어 인자에 여러 개의 값 즉 벡터형식으로 넣을 수 없는 함수들이 있습니다. Vectorize() 함수는 이 문제를 해결하여 줍니다. 이때 벡터형식으로 들어갈 인자를 vectorize.args에 지정합니다. 반환되는 결과는 벡터로 들어간 인자들이 각각 투입된 만큼의 결과들이 행렬이나 배열로 묶여서 나옵니다. 

아래 예제는 iris$Species에서 vi나 se로 시작하는 행을 추출하고자 하는 것입니다.

```{r}
# grepl함수는 pattern 인수에 단 하나의 값만 넣을 수 있습니다. 
# 만일 아래 같이 벡터형식으로 값을 여러 개 넣으면 첫번째 요소만 사용되어
# 원하는 결과를 얻을 수없습니다.
x <- grepl(pattern = c("^vi", "^se"), x = iris$Species)
head(x)

# grepl 함수를 벡터작업이 가능한 함수 vgrepl로 만듭니다. 
# 벡터로 들어갈 인수는 pattern으로 지정합니다.
vgrepl <- Vectorize(grepl, vectorize.args = "pattern")
x <- vgrepl(pattern = c("^vi", "^se"), x = iris$Species)
head(x)

# 조건에 맞는 행들을 추출합니다.
str(iris[rowSums(x) > 0, ])
```
물론 Vectorize() 함수를 사용하지 않고 sapply() 함수를 사용하여 같은 결과를 얻을 수 있습니다.

```{r}
x <- sapply(c("^vi", "^se"),
            function(pattern) {grepl(pattern = pattern, x = iris$Species)})
head(x)
```

```{r}
sumsq <- function(x, mean = 0, sd = 1) {
  sum(((x - mean) / sd)^2)}

set.seed(123)
x <- rnorm(10000)

# mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x))와 같은 결과
vsumsq <- Vectorize(sumsq, c("mean", "sd"))
vsumsq(x, 1:100, 1:100)
```

```{r}
sumsq <- function(x, mean = 0, sd = 1) {
  sum(((x - mean) / sd)^2)
}

set.seed(123)
x <- rnorm(10000)

# sumsq(x, mean = 1, sd = 1), sumsq(x, mean = 2, sd = 2), ...
mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x))

# 만일 이렇게 mapply(sumsq, mean = 1:100, sd = 1:100, x = x) 하면
# sumsq(x = x[1], mean = 1, sd = 1), ... 이런식으로 계산되어
# 원하는 결과가 나오지 않음. 여기서 x[1]은 -0.560475647임
```

### replicate()

`replicate(n, expr, simplify = "array")` 함수는 `sapply()` 함수의 간소화 버전이라 할 수 있습니다. expr 인자를 n번 만큼 반복수행합니다. expr 인자에는 주로 함수들이 많이 들어갑니다. 반환되는 결과는 기본적으로 배열입니다. 만일 반환되는 값을 리스트 형태로 받고자 한다면 `simplify = FALSE`로 지정합니다.

아래 예제는 `rnorm(5, mean = 0, sd = 1)`을 3번 반복하여 그 결과를 행렬형태로 얻는 것입니다.

```{r}
set.seed(123)
replicate(n = 3, rnorm(5, mean = 0, sd = 1))
```


### rep()

`rep(x, ...)` 함수는 특정값을 반복해서 만들어 반환해주는 함수입니다. `...`에는 인자로 times, length.out, each가 들어갈 수 있습니다. times는 x를 몇 번 반복할지를 정해주는 인수입니다. length.out은 최종 반환되는 값들의 길이를 정해주는 인수입니다. each는 x가 여러개의 값으로 구성된 벡터일 경우 각각 몇 번 반복할지를 정해주는 인수 입니다.

`rep.int(x, times)`와 `rep_len(x, length.out)`는 `rep()` 함수와 기능이 거의 같으나 인수가 제한됩니다. 이 함수들은 `rep()` 함수보다 더 빠릅니다.

```{r}
rep(1:5, 2)   # rep(x = 1:4, times = 2)와 동일
rep(1:5, each = 2)    
rep(1:5, c(2, 3, 2, 1, 2))  # rep(1:5, times = c(2, 3, 2, 1, 2)) 동일

rep(1:5, each = 2, len = 5)
rep(1:2, each = 2, len = 7)  # 길이를 채우기 위해 다시 반복
rep(1:3, each = 2, times =3)

rep(2, 5.9)  # 소수점 이하는 버리고 반복

rep(c("abc", "123"), times = 3)
rep(c("abc", "123"), each = 3)

rep.int(c("abc", "123"), 3)  # 기본인자는 times임. each 인자는 사용할 수 없음
rep_len(c("abc", "123"), 5)  # 기본인자는 length.out임
```

### seq()

`seq(...)` 함수는 일련번호 숫자를 생성하여 반환합니다. `...`에는 인자로 from, to, by, length.out, along.with가 들어갈 수 있습니다.

* from : 시작 숫자
* to : 끝 숫자
* by : 증가 간격
* length.out : 생성되는 일련번호의 길이
* along.with : 인자에 들어가는 값들의 길이만큼 일련번호 생성

`seq.int()`는 seq() 함수와 거의 동일하고, `seq_along(along.with)`와 `seq_len(length.out)`는 무조건 시작이 1이고, 각각 하나의 인자를 받아 일련번호를 생성합니다. 이 함수들은 1부터 시작하는 일련번호를 `seq()` 함수보다 약간 더 빠르게 만들어 줍니다. 

가장 많이 사용하는 형태는 다음과 같습니다.

* seq(from, to)
* seq(from, to, by = )
* seq(from, to, length.out = )
* seq(along.with = )
* seq(from)
* seq(length.out = )

```{r}
seq(2, 7)  # seq(from = 2, to = 7과 동일)
seq(7, 2)
seq(2, 10, by = 2)
seq(2, 10, by = pi)
seq(2, 10, length.out = 3)
seq(along.with = c(2:7))   # c(2:7)의 길이는 6이므로 6개 생성
seq(2, 10, along.with = c(2:7))
seq(7)   # 1부터 7까지 생성
seq(length.out = 12)
```

```{r}
seq.int(2, 10, by = pi)
seq_len(12)    # seq(length.out = 12)와 동일하나 약간 더 빠름
seq_along(c(2:7))
```

```{r}
n <- 999999999999999

start <- proc.time()
x <- seq(length.out = n)
end <- proc.time()
end - start

start <- proc.time()
x <- seq_len(n)
end <- proc.time()
end - start

```

일련 날짜를 생성할 수 있습니다.

```{r}
# 1년 간격
seq(as.Date("2001/1/1"), as.Date("2020/1/1"), "years")

# 월 간격
seq(as.Date("2001/1/1"), by = "month", length.out = 12)

# 분기 간격
seq(as.Date("2015/1/1"), as.Date("2020/1/1"), by = "quarter")

# 월 간격 반대로
seq(as.Date("2020-1-7"), as.Date("2019-1-17"), by = "-1 month")
```

```{r}
seq(ISOdate(2015,1,1), ISOdate(2020,1,1), "years")

seq(c(ISOdate(2020,3,20)), by = "DSTday", length.out = 10)

seq(c(ISOdate(2020,3,20)), by = "7 DSTdays", length.out = 5)
```

```{r}
seq(as.POSIXct("2015-3-14 17:22:15"), as.POSIXct("2015-3-15 9:12:25"),
    by = "hours")
```


### sequence()

`sequence(nvec, ...)` 함수는 연속적인 숫자를 만들어 내는 함수입니다. 
인자 nvec에 들어간 숫자 벡터들 만큼 `seq()` 함수가 수행되어 연속적인 숫자가 만들어집니다. 예를 들면 `nvec = c(3, 2)`이면 `seq(3)`, `seq(2)`가 수행됩니다.

```{r}
sequence(nvec = c(3, 2))   # c(seq(3), seq(2)) 또는 c(1:3, 1:2)와 동일
sequence(nvec = c(3, 2, 5))
sequence(c(3, 2), from = 2)  # 시작숫자 지정
sequence(c(3, 2), from = 2, by = -2)  # 시작숫자, 간격 지정
sequence(c(3, 2), by = c(2, -2))
```

### gl()

`gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE)` 함수는
요인 수준을 반복적으로 생성하여 반환합니다. gl은 generate levels의 약자로 생각됩니다.

* n : 수준을 나태내는 숫자. n = 2이면 label을 따로 지정하지 않은 경우 수준이 1, 2로 표현됩니다.
* k : 수준을 반복할 숫자. k = 8이면 8번 반복합니다.
* length : 생성되는 총 데이터의 갯수
* labels : 수준에 대한 이름
* ordered : TRUE이면 요인의 순서가 정해집니다. (순서형 데이터)

```{r}
gl(n = 2, k = 8)  # 수준 1, 2를 각각 8번 반복
gl(n = 2, k = 8, labels = c("Contol", "Treat"))  # 수준 이름 지정
gl(n = 2, k = 1, length = 10)  # 수준 1, 2가 각각 1번씩 반복되며 10개 생성
gl(n = 2, k = 2, length = 10)  # 수준 1, 2가 각각 2번씩 반복되며 10개 생성

# 수준 1, 2가 M과 F로 순서있게 네이밍 되고, 각각 3번씩 반복되며 10개 생성
gl(2, 3, 10, labels = c("M", "F"), ordered = TRUE)
```

### sweep()

`sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)` 함수는
행렬, 데이터프레임 등에 통계량과 함수를 적용하여 그 결과를 반환하는 함수입니다.
데이터 x에 일률적으로 특정 숫자만큼 더하거나 빼기를 할 때 많이 사용합니다.

* x : 입력 데이터로서 배열, 행렬, 데이터프레임
* MARGIN : 행과 열 방향 지정. 1이면 열방향, 2이면 행방향 
* STATS : 적용할 요약 통계량 또는 수치
* FUN : 적용할 함수 (기본값은 "-" 임)


```{r}
x <- matrix(1:12, ncol = 3); x

# 행렬 x를 행방향(2)으로 1씩 빼줌
sweep(x, MARGIN = 2, STATS = 1, FUN = "-")  

# 행렬 x를 열방향(1)으로 각각 1, 2, 3, 4를 더해줌
sweep(x, 1, c(1,2,3,4), FUN = "+")  

# 행 기준 비율 계산
round(sweep(x, 1, apply(x, 1, sum), FUN = "/") * 100, 1)

# 열 기준 비율 계산
round(sweep(x, 2, apply(x, 2, sum), FUN = "/") * 100, 1)

# 전체 기준 비율 계산
round(sweep(x, 2, sum(x), FUN = "/") * 100, 1)
```
```{r}
# 데이터프레임의 숫자 열에 각각 1씩 빼기
str(iris)
y <- sweep(iris[1:4], MARGIN = 2, STATS = 1, FUN = "-") 
str(y)
```

### aggregate()

`aggregate(x, ...)` 함수는 데이터 x의 그룹별로 함수를 적용하여 그 결과를 반환합니다. 

* x : 입력 데이터
* by : 그룹핑 변수(열)로서 리스트 형식이어야 함
* FUN : 적용할 함수

```{r}
str(iris)
# 종류별로 평균을 구함
aggregate(iris[1:4], by = list(iris$Species), mean, na.rm = TRUE)

# 그룹핑 그룹에 이름을 지정할 수 있음(종류)
aggregate(iris[1:4], by = list(종류 = iris$Species), mean, na.rm = TRUE)

# 적용할 함수에 인자들을 지정할 수 있음
aggregate(iris[1:4], by = list(종류 = iris$Species), mean, na.rm = TRUE, trim = 0.1)
```


```{r}
str(infert)  # R 내장 데이터 infert

# 2개 변수로 그룹핑
aggregate(infert[2:3], by = list(infert$education, infert$spontaneous), 
          mean, na.rm = TRUE)
```


## R 통계 함수

### sample()

`sample(x, size, replace = FALSE, prob = NULL)` 함수는 데이터 x에서 무작위로 데이터를 size만큼 추출하여 반환합니다. 

* x : 1개 이상의 요소를 가진 벡터(모집단)
* size : 추출할 갯수(표본의 크기)
* replace : 기본값은 FALSE로 비복원 추출, TRUE이면 복원 추출
* prob : 표본이 추출될 가중치

간소화 버전 함수로 `sample.int(n, size = n, replace = FALSE, prob = NULL)`가 있습니다. 1부터 n 사이의 값에서 기본적으로 n만큼 데이터를 추출합니다. 만일 size를 지정하면 size 숫자만큼 추출합니다.

```{r}
set.seed(5)  # 아래 무작위 추출 결과가 항상 동일하게 나오게 함
x <- 1:12
sample(x, size = 5)
sample(x, size = 5, replace = TRUE)

# 1은 20%, 2는 30%, 3은 50% 확률로 추출됨 (가중표본추출)
sample(1:3, size = 5, replace = TRUE, prob = c(2, 3, 5))
```

```{r}
# 베루누이 실험 - 100회
sample(0:1, 100, replace = TRUE)
```

```{r}
# sample.int
sample.int(10)
sample.int(10, size = 5)

```

```{r}
# 데이터 프레임에서 무작위로 표본을 추출합니다. 
# 예제는 iris(150개 행)에서 30개를 무작위로 추출합니다.
str(iris)
set.seed(357)
idx <- sample(nrow(iris), 30)  # sample(1:150, size = 30)과 동일
idx  # 추출된 번호 확인(생략 가능)
sam <- iris[idx,]
str(sam)
```

데이터를 80:20으로 나누어 추출하겠습니다.

```{r}
dataset <- iris
str(dataset)
set.seed(357)
idx <- sample(1:nrow(dataset), size = round(0.8*nrow(dataset)))
train <- dataset[idx,] #훈련용 데이터
test <- dataset[-idx,] #검증용 데이터
str(train)
```

### 균등분포(unif)

> 확률분포는 **연속확률분포**와 **이산확률분포**로 구분할 수 있습니다. 
연속확률분포에는 균등분포, 정규분포, 표준정규분포, 감마분포, 지수분포, 베타분포, t분포, 카이제곱분포, F분포, 웨이블분포, 로그정규분포 등이 있습니다.
이산확률 분포는 베르누이분포, 이항분포, 다항분포, 초기하분포, 기하분포, 음이항분포, 포아송분포 등이 있습니다. 

균등분포는 분포가 특정 범위내에서 균등하게 나타나는 경우를 의미합니다. 다른말로 연속균등분포라고 합니다. 영어로는 uniform distribution입니다.

균등분포와 관련된 함수는 다음 4가지 있습니다. 

* `runif(n, min = 0, max = 1)` 
* `dunif(x, min = 0, max = 1, log = FALSE)`
* `punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)`
* `qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)`

위 함수명은 접두어 r, d, p, q와 균등분포를 의미하는 unif가 결합하여 만들어진 것입니다. 접두어의 의미는 다음과 같습니다.

* r : 난수(random number) 발생
* d : 확률밀도함수(density)
* p : 누적분포함수(distribution function)
* q : 분위수(quantile function)

runif 함수는 난수를 의미하는 r과 균등분포를 의미하는 unif가 결합하여 만들어진 함수명입니다. 따라서 `runif(n, min = 0, max = 1)` 함수는 최소값(0)부터 최대값(1)사이에 균등분포로 n개의 난수를 생성하여 반환합니다. 다른 확률분포 함수들의 함수명도 이와 같은 규칙으로 만들어졌다고 볼 수 있습니다. 

```{r}
runif(10, 2, 5)  # 2와 5사이에 균등분포로 10개의 난수 발생
runif(10)   # 0과 1사이에 균등분포로 10개의 난수 발생

mean(runif(100000))  # 0~1 균등분포로 추출된 값들의 평균은 0.5에 가까움
```

`dunif(x, min = 0, max = 1, log = FALSE)` 함수는 균등분포의 확률밀도함수입니다.
최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-2, 5, by = 0.01)
str(x)

# 균등분포의 확률밀도함수 시각화 (0과 3사이의 분포는 균등함)
plot(x, dunif(x, 0, 3), type = "l", col = "red")

# 0과 1사이의 균등분포에서 x가 0.5일때의 함수값?
dunif(0.5, 0, 3)
```

`punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 균등분포의 누적분포함수입니다.
최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-2, 5, by = 0.01)
str(x)

# 균등분포의 누적분포함수 시각화 (0과 3사이의 누적분포는 일정하게 상승함)
plot(x, punif(x, 0, 3), type = "l", col = "red")

# 0과 3사이의 균등분포에서 q가 0.5일때의 누적분포함수값은? 즉 확률은?
punif(0.5, 0, 3)
```

`qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)` 함수는  균등분포의 분위수를 구하는 함수입니다.
최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 확률이 인자 p일 때의 분위수값을 구해 반환합니다. punif 함수와 반대되는 함수라 할 수 있습니다.

```{r}
# 0~5의 균등분포에서 확률이 0.3일때의 x값은 1.5
qunif(0.3, 0, 5)
# 0~5의 균등분포에서 x가 1.5일때의 확률은 0.3
punif(1.5, 0, 5)
```


### 정규분포(norm)

정규분포는 분포가 종 모양의 형태로 평균에 가까울수록 발생확률이 높고 평균에서 멀어질수록 발생할 확률이 낮은 분포입니다. 가우스가 처음 정립해서 가우시안(Gaussian) 분포라고도 합니다. 영어로는 normal distribution입니다.

표준정규분포(standard normal distribution)는 평균이 0이고, 표준편차가 1인 정규분포를 의미합니다.

> "양 끝의 극단에 있는 것은 드물고 소수인 반면, 중간에 있는 것들은 흔하고 다수임을 알지 못하나?" - 소크라테스, 파이돈

정규분포와 관련된 함수는 다음 4가지 있습니다. 

* `rnorm(n, mean = 0, sd = 1)`
* `dnorm(x, mean = 0, sd = 1, log = FALSE)`
* `pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)`
* `qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)`

`rnorm(n, mean = 0, sd = 1)` 함수는 주어진 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 n개의 난수를 생성하여 반환합니다. rnorm 함수명은 난수를 의미하는 r과 정규분포를 의미하는 norm이 결합되어진 것입니다.

```{r}
# 평균이 0이고 표준편차기 1인 표준정규분포에서 난수 10개 생성
rnorm(10)

# 평균이 50이고 표준편차기 3인 분포에서 난수 10개 생성
rnorm(10, mean = 50, sd = 3)
```

```{r}
x <- rnorm(2000)
hist(x)  
```

`dnorm(x, mean = 0, sd = 1, log = FALSE)` 함수는 정규분포의 확률밀도함수입니다.
평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 정규분포의 확률밀도함수 시각화
plot(x, dnorm(x, 0, 1), type = "l", col = "red")

# 표준정규분포에서 x가 0.5일때의 함수값?
dnorm(0.5, 0, 1)
```

```{r}
# 정규분포 그래프에서 -5에서 1까지의 면적(핑크색)은 전체면적의 84%
# pnorm(1, mean = 0, sd = 1)
x <- seq(-5, 5, by = 0.01)
plot(x, dnorm(x, 0, 1), type = "l", lwd = 2, col = "red")

u <- seq(-5, 1, by = 0.01)
v <- dnorm(u, mean = 0, sd = 1)
polygon(c(-5, u, 1), c(0, v, 0), col = "pink")
```

`pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 정규분포의 누적분포함수입니다. 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 정규분포의 누적분포함수 시각화
plot(x, pnorm(x, mean = 0, sd = 1), type = "l", col = "red")

# 표준정규분포에서 q가 0.5일때의 누적분포함수값은? 즉 확률은?
pnorm(0.5, mean = 0, sd = 1)

# 표준정규분포에서 가로축 1까지의 누적분포함수값(확률))은 0.84(84%)
pnorm(1, mean = 0, sd = 1)
```

`qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)` 함수는  정규분포의 분위수를 구하는 함수입니다. 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
# 확률이 0.8413일때의 x값은 1의 근사값
qnorm(0.8413, mean = 0, sd = 1)
# 1일때의 확률은 0.8413
pnorm(1, mean = 0, sd = 1)
```


### 감마분포(gamma)

감마분포는 α번째 사건이 일어날 때 까지 걸리는 시간에 대한 연속확률분포입니다. 참고로 감마분포는 감마함수를 바탕으로 하고 있는데, 감마함수는 수학자 오일러가 제안한 함수입니다. 

감마분포와 관련된 함수는 다음 4가지 있습니다. 

* rgamma(n, shape, rate = 1, scale = 1/rate)
* dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)
* pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)
* qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)

`rgamma(n, shape, rate = 1, scale = 1/rate)` 함수는 주어진 형태 shape와 척도 scale(기본값 1/rate, rate의 기본값은 1)의 감마분포에서 n개의 난수를 생성하여 반환합니다. rgamma 함수명은 난수를 의미하는 r과 감마분포를 의미하는 gamma가 결합되어진 것입니다.

```{r}
# 형태가 1인 감마분포에서 난수 10개 생성
rgamma(n = 10, shape = 1)

# 평균이 50이고 표준편차기 3인 분포에서 난수 10개 생성
rgamma(10, shape = 1, rate = 0.001)
```

```{r}
x <- rgamma(n = 2000, shape = 1)
hist(x)  
```

`dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)` 함수는 감마분포의 확률밀도함수입니다. 형태 shape와 척도 scale의 감마분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-1, 5, by = 0.01)

# 확률밀도함수 시각화
plot(x, dgamma(x, shape = 1), type = "l", col = "red")

# x가 0.5일때의 함수값?
dgamma(0.5, shape = 1)
```

```{r}
x <- seq(0, 10, by = 0.01)

plot(x, dgamma(x, shape = 1, scale = 2), type = "l", col = "red")
lines(x, dgamma(x, shape = 2, scale = 2), type = "l", col = "green")
lines(x, dgamma(x, shape = 3, scale = 2), type = "l", col = "blue")
lines(x, dgamma(x, shape = 4, scale = 2), type = "l", col = "purple")
```

```{r}
x <- seq(0, 10, by = 0.01)

plot(x, dgamma(x, shape = 2, scale = 2), type = "l", col = "red")
lines(x, dgamma(x, shape = 2, scale = 3), type = "l", col = "green")
lines(x, dgamma(x, shape = 2, scale = 4), type = "l", col = "blue")
lines(x, dgamma(x, shape = 2, scale = 5), type = "l", col = "purple")
```

```{r}
# 0에서 1까지의 면적(핑크색)은?  pgamma(1, shape = 1)
x <- seq(0, 5, by = 0.01)
plot(x, dgamma(x, shape = 1), type = "l", lwd = 2, col = "red")

u <- seq(0, 1, by = 0.01)
v <- dgamma(u, shape = 1)
polygon(c(0, u, 1), c(0, v, 0), col = "pink")
```

`pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)` 함수는 감마분포의 누적분포함수입니다. 형태 shape와 척도 scale의 감마분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pgamma(x, shape = 1), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은? 
pgamma(0.5, shape = 1)

# 가로축 1까지의 누적분포함수값(확률))은?
pgamma(1, shape = 1)
```

`qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)` 함수는  감마분포의 분위수를 구하는 함수입니다. 형태 shape와 척도 scale의 감마분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
# 70% 분위수는?
qgamma(0.7, shape = 1)

# 주어진 값의 %는?
pgamma(1.2, shape = 1)
```


### 지수분포(exp)

지수분포는 감마분포의 특수한 경우라고 볼 수 있습니다. 감마분포가 α번째 사건이 일어날 때 까지 걸리는 시간에 대한 분포라면, 지수분포는 첫번째 사건이 발생할 때 까지 걸리는 시간에 대한 분포라고 할 수 있습니다. 두 분포함수의 인자를 기본값으로 하면 결과는 거의 동일하게 나옵니다.

참고로 지수분포와 포아송분포는 서로 반대되는 과점을 가지고 있습니다. 지수분포가 첫번째 사건이 발생할 때까지의 대기시간인 반면, 포아송분포는 단위 시간 당 발생하는 사건의 횟수입니다. 지수포는 대기시간, 포아송분포는 횟수입니다.

지수분포는 기하분포와도 관련이 있습니다. 지수분포는 사건이 발생할 때까지의 대기시간인 반면, 기하분포는 사건이 발생할 때까지의 시도횟수입니다.


지수분포와 관련된 함수는 다음 4가지 있습니다. 

* rexp(n, rate = 1)
* dexp(x, rate = 1, log = FALSE)
* pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE)
* qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE)

`rexp(n, rate = 1)` 함수는 주어진 감마값 rate(기본값 1)의 지수분포에서 n개의 난수를 생성하여 반환합니다. rexp 함수명은 난수를 의미하는 r과 지수분포를 의미하는 exp가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rexp(n = 10, rate = 1)
```

```{r}
set.seed(123)
x <- rexp(n = 2000, rate = 1)
hist(x)  
```

`dexp(x, rate = 1, log = FALSE)` 함수는 지수분포의 확률밀도함수입니다. 주어진 감마값 rate(기본값 1)의 지수분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 7, by = 0.01)

# 확률밀도함수 시각화
plot(x, dexp(x, rate = 1), type = "l", col = "red")

# x가 0.5일때의 함수값?
dexp(0.5, rate = 1)
```

```{r}
# 0에서 1까지의 면적(핑크색)은? pexp(1, rate = 1)
x <- seq(0, 5, by = 0.01)
plot(x, dexp(x, rate = 1), type = "l", lwd = 2, col = "red")

u <- seq(0, 1, by = 0.01)
v <- dexp(u, rate = 1)
polygon(c(0, u, 1), c(0, v, 0), col = "pink")
```

`pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 지수분포의 누적분포함수입니다. 주어진 rate(기본값 1)의 지수분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pexp(x, rate = 1), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은?
pexp(0.5, rate = 1)

# 0~1까지의 면적 비율
pexp(1, rate = 1)
```

`qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 지수분포의 분위수를 구하는 함수입니다. 주어진 rate의 지수분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qexp(0.7, rate = 1)

pexp(1.204, rate = 1)
```


### 베타분포(beta)

베타분포는 두 매개변수 α와 β에 따라 [0, 1] 구간에서 정의되는 분포입니다. 베타분포는 주로 베이지안 추정에서 많이 다루어지는 분포입니다. 모수가 α와 β 두 개이므로 다양한 형태의 분포가 만들어질 수 있습니다. 베타분포를 계산하는 데 사용되는 베타함수는 감마함수를 만든 오일러가 23세(1730년)에 만든 함수입니다. 

베타분포와 관련된 함수는 다음 4가지 있습니다. 

* rbeta(n, shape1, shape2, ncp = 0)
* dbeta(x, shape1, shape2, ncp = 0, log = FALSE)
* pbeta(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)
* qbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)

위 함수에서 인자 shape1과 shape2는 각각 베타분포의 매개변수 α와 β라 할 수 있습니다.

`rbeta(n, shape1, shape2, ncp = 0)` 함수는 매개변수 shape1과 shape2의 베타분포에서 n개의 난수를 생성하여 반환합니다. rbeta 함수명은 난수를 의미하는 r과 베타분포를 의미하는 beta가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rbeta(n = 10, shape1 = 1, shape2 = 1)
```

```{r}
set.seed(123)
x <- rbeta(n = 2000, shape1 = 1, shape2 = 2)
hist(x) 
```

`dbeta(x, shape1, shape2, ncp = 0, log = FALSE)` 함수는 베타분포의 확률밀도함수입니다. 매개변수 shape1과 shape2의 베타분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 1, by = 0.01)

# 확률밀도함수 시각화
plot(x, dbeta(x, shape1 = 2, shape2 = 5), type = "l", col = "red")

# x가 0.5일때의 함수값?
dbeta(0.5, shape1 = 2, shape2 = 5)
```

매개변수 shape1과 shape2의 값에 따라 다양한 형태의 분포가 나옵니다.

```{r}
x <- seq(0, 1, by = 0.01)

plot(x, dbeta(x, shape1 = 1, shape2 = 2), type = "l", col = "red")
lines(x, dbeta(x, shape1 = 2, shape2 = 2), type = "l", col = "green")
lines(x, dbeta(x, shape1 = 3, shape2 = 2), type = "l", col = "blue")
lines(x, dbeta(x, shape1 = 4, shape2 = 2), type = "l", col = "purple")
```

```{r}
x <- seq(0, 1, by = 0.01)

plot(x, dbeta(x, shape1 = 2, shape2 = 1), type = "l", col = "red")
lines(x, dbeta(x, shape1 = 2, shape2 = 2), type = "l", col = "green")
lines(x, dbeta(x, shape1 = 2, shape2 = 3), type = "l", col = "blue")
lines(x, dbeta(x, shape1 = 2, shape2 = 4), type = "l", col = "purple")
```

```{r}
# 0에서 0.5까지의 면적(핑크색)은? pbeta(0.5, shape1 = 2, shape2 = 3)
x <- seq(0, 1, by = 0.01)
plot(x, dbeta(x, shape1 = 2, shape2 = 3), type = "l", lwd = 2, col = "red")

u <- seq(0, 0.5, by = 0.01)
v <- dbeta(u, shape1 = 2, shape2 = 3)
polygon(c(0, u, 0.5), c(0, v, 0), col = "pink")
```

`pbeta(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 베타분포의 누적분포함수입니다. 매개변수 shape1과 shape2의 베타분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 1, by = 0.01)

# 누적분포함수 시각화
plot(x, pbeta(x, shape1 = 2, shape2 = 3), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은?
pbeta(0.5, shape1 = 2, shape2 = 3)
```

`qbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 베타분포의 분위수를 구하는 함수입니다. 매개변수 shape1과 shape2의 베타분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qbeta(0.7, shape1 = 2, shape2 = 3)
pbeta(0.5084, shape1 = 2, shape2 = 3)
```


### t분포(t)

t분포는 '스튜던트 t분포(Student's t-distribution)'를 간단하게 부르는 말입니다. t분포는 프리드리히 로베르트 헬메르트(1875)와 야코프 뤼로트(1876)가 발견하였는데 학계에 널리 알려지지 않다가, 1908년에 기네스 양조 공장에서 일하는 윌리엄 고셋이 '스튜던트'라는 필명으로 맥주에 사용되는 보리의 질을 시험하기 위해 이 분포를 도입하였습니다. 저명한 통계학자인 로널드 피셔가 이 분포를 '스튜던트 t분포'로 소개하면서 널리 알려지게 되었습니다.

t 분포는 종모양으로서 좌우대칭을 이룹니다. 정규분포와 비슷한 모양이지만 정규분포보다는 옆으로 넓게 더 퍼진 모양이라고 볼 수 있습니다. t 분포의 모양을 결정하는 것은 자유도이며, 자유도가 커질수록 표준정규분포에 가깝게 됩니다. 통계학자들은 보통 표본수가 30이상이면 정규분포에 가깝다고 합니다. 이를 뒤집어 해석하면 표본의 크기가 30보다 작으면 t분포를 사용할 필요가 있다고 볼 수 있습니다. 또한 t분포는 정규분포의 평균을 측정할 때 주로 사용되는 확률분포입니다. 통계학에서 가설검정과 회귀분석에 많이 사용됩니다.

t분포와 관련된 함수는 4가지가 있습니다.

* rt(n, df, ncp)
* dt(x, df, ncp, log = FALSE)
* pt(q, df, ncp, lower.tail = TRUE, log.p = FALSE)
* qt(p, df, ncp, lower.tail = TRUE, log.p = FALSE)


위 함수에서 인자 df는 자유도를 의미합니다. t분포에서 자유도는 표본의 갯수인 n에서 1을 뺀 값입니다. ncp는 비중심모수(non-centrally parameter)입니다.

`rt(n, df, ncp)` 함수는 자유도 df의 t분포에서 n개의 난수를 생성하여 반환합니다. rt 함수명은 난수를 의미하는 r과 t분포를 의미하는 t가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rt(n = 10, df = 3)
```

```{r}
set.seed(123)
x <- rt(n = 2000, df = 3)
hist(x) 
```

`dt(x, df, ncp, log = FALSE)` 함수는 t분포의 확률밀도함수입니다. 자유도 df의 t분포에서에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 확률밀도함수 시각화
plot(x, dt(x, df = 2), type = "l", col = "red")

# x가 0.5일때의 함수값?
dt(0.5, df = 2)
```

자유도 df의 값에 따라 다양한 형태의 분포가 나옵니다. df가 커질수록 정규분포에 가까워집니다. 검은색 선은 표준정규분포선입니다. 자유도가 30에 가까워질수록 t분포는 정규분포에 가까워지는 것을 볼 수 있습니다.

```{r}
x <- seq(-5, 5, by = 0.01)

plot(x, dt(x, df = 28), type = "l", col = "red")
lines(x, dt(x, df = 10), type = "l", col = "green")
lines(x, dt(x, df = 5), type = "l", col = "blue")
lines(x, dt(x, df = 2), type = "l", col = "purple")
lines(x, dnorm(x), type = "l", lwd =2, col = "black")
```

```{r}
x <- seq(-5, 8, by = 0.01)

plot(x, dt(x, df = 15), type = "l", col = "red")
lines(x, dt(x, df = 15, ncp = 1), type = "l", col = "green")
lines(x, dt(x, df = 15, ncp = 2), type = "l", col = "blue")
lines(x, dt(x, df = 15, ncp = 3), type = "l", col = "purple")
```

```{r}
# 0.5이하의 면적(핑크색)은? pt(0.5, df = 10)
x <- seq(-5, 5, by = 0.01)
plot(x, dt(x, df = 10), type = "l", lwd = 2, col = "red")

u <- seq(-5, 0.5, by = 0.01)
v <- dt(u, df = 10)
polygon(c(-5, u, 0.5), c(0, v, 0), col = "pink")
```

`pt(q, df, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 t분포의 누적분포함수입니다. 자유도 df의 t분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pt(x, df = 10), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은?
pt(0.5, df = 10)
```

`qt(p, df, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 t분포의 분위수를 구하는 함수입니다. 자유도 df의 t분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qt(0.7, df = 10)
pt(0.5415, df = 10)
```


### 카이제곱분포(chisq)

카이제곱분포($χ^2$분포)는 k개의 서로 독립적인 표준정규분포의 확률변수를 각각 제곱한 다음 합해서 얻어지는 분포입니다. 이때 k는 자유도(df)로서 카이제곱분포의 매개변수가 됩니다. 카이제곱분포는 감마분포의 특수한 형태라고 할 수 있습니다.

카이제곱분포는 오른쪽으로 긴 꼬리를 가진 비대칭 분포모양을 가지고 있습니다. 카이제곱분포의 모양을 결정하는 것은 자유도이며, 자유도가 커질수록 정규분포에 가깝게 됩니다. 카이제곱분포는 모분산에 대한 추정과 검정에 사용되며, 범주형 자료의 적합도 검정, 동질성 검정, 독립성 검정 등에 사용됩니다.

카이제곱분포와 관련된 함수는 4가지가 있습니다.

* rchisq(n, df, ncp = 0)
* dchisq(x, df, ncp = 0, log = FALSE)
* pchisq(q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)
* qchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)

위 함수에서 인자 df는 자유도를 의미합니다. 

`rchisq(n, df, ncp = 0)` 함수는 자유도 df의 카이제곱분포에서 n개의 난수를 생성하여 반환합니다. rchisq 함수명은 난수를 의미하는 r과 카이제곱분포를 의미하는 chisq가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rchisq(n = 10, df = 3)
```

```{r}
set.seed(123)
x <- rchisq(n = 5000, df = 5)
hist(x, breaks = 100, main = "") 
```

`dchisq(x, df, ncp = 0, log = FALSE)` 함수는 카이제곱분포의 확률밀도함수입니다. 자유도 df의 카이제곱분포에서에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10, by = 0.01)

# 확률밀도함수 시각화
plot(x, dchisq(x, df = 2), type = "l", col = "red")

# x가 0.5일때의 함수값?
dchisq(0.5, df = 2)
```

자유도 df의 값에 따라 다양한 형태의 분포가 나옵니다. df가 커질수록 정규분포에 가까워집니다.

```{r}
x <- seq(0, 15, by = 0.01)

plot(x, dchisq(x, df = 2), type = "l", col = "red")
lines(x, dchisq(x, df = 4), type = "l", col = "green")
lines(x, dchisq(x, df = 6), type = "l", col = "blue")
lines(x, dchisq(x, df = 8), type = "l", col = "purple")
```

```{r}
x <- seq(0, 15, by = 0.01)

plot(x, dchisq(x, df = 5), type = "l", col = "red")
lines(x, dchisq(x, df = 5, ncp = 1), type = "l", col = "green")
lines(x, dchisq(x, df = 5, ncp = 2), type = "l", col = "blue")
lines(x, dchisq(x, df = 5, ncp = 3), type = "l", col = "purple")
```

```{r}
# 0에서 5까지의 면적(핑크색)은? pchisq(5, df = 3)
x <- seq(0, 15, by = 0.01)
plot(x, dchisq(x, df = 3), type = "l", lwd = 2, col = "red")

u <- seq(0, 5, by = 0.01)
v <- dchisq(u, df = 3)
polygon(c(0, u, 5), c(0, v, 0), col = "pink")
```

`pchisq(q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 카이제곱분포의 누적분포함수입니다. 자유도 df의 카이제곱분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 15, by = 0.01)

# 누적분포함수 시각화
plot(x, pchisq(x, df = 3), type = "l", col = "red")

# q가 5일때의 누적분포함수값은? 즉 확률은?
pchisq(5, df = 3)
```

`qchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 카이제곱분포의 분위수를 구하는 함수입니다. 자유도 df의 카이제곱분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qchisq(0.7, df = 3)
pchisq(3.6648, df = 3)
```


### F분포(f)

F분포는 두개의 독립적인 카이제곱분포의 확률변수의 비(ratio)로 얻어지는 연속확률분포입니다. 

F분포는 카이제곱분포처럼 오른쪽으로 긴 꼬리를 가진 비대칭 분포모양을 가지고 있습니다. F분포의 모양을 결정하는 것은 분자와 분모의 자유도이며, 두 자유도가 커질수록 정규분포에 가깝게 됩니다. F분포는 분산의 비교, 분산분석, 회귀분석 등에 많이 사용됩니다.

F분포와 관련된 함수는 4가지가 있습니다.

* rf(n, df1, df2, ncp)
* df(x, df1, df2, ncp, log = FALSE)
* pf(q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)
* qf(p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)


위 함수에서 인자 df1과 df2는 자유도를 의미합니다. 

`rf(n, df1, df2, ncp)` 함수는 자유도 df1과 df2의 F분포에서 n개의 난수를 생성하여 반환합니다. rf 함수명은 난수를 의미하는 r과 F분포를 의미하는 f가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rf(n = 10, df1 = 2, df2 = 2)
```

```{r}
set.seed(123)
x <- rf(n = 5000, df1 = 5, df2 = 8)
hist(x, breaks = 100,  main = "") 
```

`df(x, df1, df2, ncp, log = FALSE)` 함수는 F분포의 확률밀도함수입니다. 자유도 df1과 df2의 F분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10, by = 0.01)

# 확률밀도함수 시각화
plot(x, df(x, df1 = 5, df2 = 2), type = "l", col = "red")

# x가 0.5일때의 함수값?
df(0.5, df1 = 5, df2 = 2)
```

자유도 df1과 df2의 값에 따라 다양한 형태의 분포가 나옵니다. df1과 df2가 커질수록 정규분포에 가까워집니다.

```{r}
x <- seq(0, 5, by = 0.01)

plot(x, df(x, df1 = 2, df2 = 1), type = "l", col = "red")
lines(x, df(x, df1 = 5, df2 = 1), type = "l", col = "green")
lines(x, df(x, df1 = 10, df2 = 1), type = "l", col = "blue")
lines(x, df(x, df1 = 20, df2 = 20), type = "l", col = "purple")
```

```{r}
x <- seq(0, 5, by = 0.01)

plot(x,  df(x, df1 = 20, df2 = 20), type = "l", col = "red")
lines(x, df(x, df1 = 3, df2 = 5), type = "l", col = "green")
lines(x, df(x, df1 = 3, df2 = 10), type = "l", col = "blue")
lines(x, df(x, df1 = 3, df2 = 15), type = "l", col = "purple")
```

```{r}
# 0에서 2까지의 면적(핑크색)은? pf(2, df1 = 3, df2 =3)
x <- seq(0, 5, by = 0.01)
plot(x, df(x, df1 = 3, df2 = 3), type = "l", lwd = 2, col = "red")

u <- seq(0, 2, by = 0.01)
v <- df(u, df1 = 3, df2 = 3)
polygon(c(0, u, 2), c(0, v, 0), col = "pink")
```

`pf(q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 F분포의 누적분포함수입니다. 자유도 df1과 df2의 F분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pf(x, df1 = 3, df2 = 3), type = "l", col = "red")

# q가 2일때의 누적분포함수값은? 즉 확률은?
pf(2, df1 = 3, df2 =3)
```

`qf(p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 F분포의 분위수를 구하는 함수입니다. 자유도 df1과 df2의 F분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qf(0.7, df1 = 3, df2 = 3)
pf(1.9398, df1 = 3, df2 =3)
```


### 웨이블분포(weibull)



### 로그정규분포(lnorm)




### 베르누이분포
이산확률분포
베르누이분포, 이항분포, 다항분포, 초기하분포, 기하분포, 음이항분포, 포아송분포 

베르누이분포는 이항분포의 특수한 경우입니다. 

### 이항분포(binom)


베르누이 분포


정규분포는 분포가 종 모양의 형태로 평균에 가까울수록 발생확률이 높고 평균에서 멀어질수록 발생할 확률이 낮은 분포입니다. 가우스가 처음 정립해서 가우시안(Gaussian) 분포라고도 합니다. 영어로는 normal distribution입니다.

정규분포와 관련된 함수는 다음 4가지 있습니다. 

### 다항분포(multinom)

### 초기하분포(hyper)

### 기하 분포(geom)
### 음이항 분포(nbinom)

### 포아송분포(pois)


### 코시 분포(cauchy)











### mean(x) 
### median(x) 
### weighted.mean(x, w) 

### var(x)  
### sd(x) 

### max(x)
### min(x) 
### pmin(x,y,...) 
### pmax(x,y,...) 병렬최대값

### range(x)
### quantile(x,probs=) 
### cov(x) 
### cor(x) 
### var(x, y) or cov(x, y) 
### cor(x, y) 

### rank(x) 


### Optimization and model fitting
### optim(par, fn, method = c("Nelder-Mead", "BFGS",
### "CG", "L-BFGS-B", "SANN") 
### nlm(f,p) 
### lm(formula)
### glm(formula,family=)
### nls(formula) 
### approx(x,y=) 
### spline(x,y=) 
### loess(formula) 

### predict(fit,...) 
### df.residual(fit) 
### coef(fit) 
### residuals(fit) 
### deviance(fit) 
### fitted(fit) 
### logLik(fit)
### AIC(fit) 
### aov(formula) 
### anova(fit,...) 
### density(x) 

### binom.test()
### prop.test()
### rnorm(n, mean=0, sd=1) 
### rexp(n, rate=1) 
### rgamma(n, shape, scale=1)
### rpois(n, lambda)
### rweibull(n, shape, scale=1)
### rcauchy(n, location=0, scale=1) 
### rbeta(n, shape1, shape2)
### rt(n, df)
### rf(n, df1, df2) 
### rchisq(n, df) 
### rbinom(n, size, prob)
### rgeom(n, prob) 
### rhyper(nn, m, n, k) 
### rlogis(n, location=0, scale=1) 
### rlnorm(n, meanlog=0, sdlog=1) 
### rnbinom(n, size, prob) 
### rwilcox(nn, m, n), rsignrank(nn, n) 

### lgamma, gamma, digamma, trigamma
 
## R 날짜와 시간 함수

seq()
difftime()
as.Date(s) and as.POSIXct(s)
format(dt)

%a, %A Abbreviated and full weekday name.
%b, %B Abbreviated and full month name.
%d Day of the month (01–31).
%H Hours (00–23).
%I Hours (01–12).
%j Day of year (001–366).
%m Month (01–12).
%M Minute (00–59).
%p AM/PM indicator.
%S Second as decimal number (00–61).
%U Week (00–53); the first Sunday as day 1 of week 1.
%w Weekday (0–6, Sunday is 0).
%W Week (00–53); the first Monday as day 1 of week 1.
%y Year without century (00–99). Don’t use.
%Y Year with century.
%z (output only.) Offset from Greenwich; -0800 is 8 hours west of.
%Z (output only.) Time zone as a character string (empty if not available).

## R 객체 함수

### 객체 클라스와 타입 조사
typeof()
str()
class(x) 
unclass(x) 
attr(x,which) 
attributes(obj)

### 데이터 차원 조사
dim
nrow
ncol

### 객체정보 함수
length(x) 
dimnames(x) 


is.na(x), is.null(x), is.array(x), is.data.frame(x),
is.numeric(x), is.complex(x), is.character(x),


### 객체변환 함수
as.array(x), as.data.frame(x), as.numeric(x),
as.logical(x), as.complex(x), as.character(x),





## R 문자열 함수

paste(...) 
substr(x,start,stop) 
strsplit(x,split) 
grep(pattern,x) 
gsub(pattern,replacement,x) 
tolower(x) 
toupper(x) 
match(x,table) 
pmatch(x,table) 
nchar(x) 

### 정규표현식




## R 데이터 관리 함수

c(...) 
seq(from,to) 
seq(along=x) 
rep(x,times) 
rep(c(1,2,3),each=2) 

all.equal
identical

data.frame(...)
list(...) 
array(x,dim=) 
matrix(x,nrow=,ncol=) 
factor(x,levels=) 
gl(n,k,length=n*k,labels=1:n) 
expand.grid() 
rbind(...) 
cbind(...) 

Data selection and manipulation
which.max(x) 
which.min(x) 
rev(x) 
sort(x) rev(sort(x))
cut(x,breaks) 
match(x, y) 
which(x == a) 
choose(n, k) 
na.omit(x) 
na.fail(x) 
unique(x) 
table(x) 
subset(x, ...) 
sample(x, size) 
prop.table(x,margin=) 

by(data,INDEX,FUN) 
merge(a,b) 
xtabs(a b,data=x) 
aggregate(x,by,FUN) 
stack(x, ...) 
unstack(x, ...) 
reshape(x, ...) 


## R 입출력 함수

load() 
data(x) 
library(x) 
read.table(file) 
read.csv("filename",header=TRUE) 
read.delim("filename",header=TRUE) 
read.fwf(file,widths,header=FALSE,sep="",as.is=FALSE) 
save.image(file) 
cat(..., file="", sep=" ") 
print(a, ...) 
format(x,...) 
write.table(x,file="",row.names=TRUE,col.names=TRUE, sep=" ")
sink(file) 


## R 시스템 함수


 


## R 사용자 정의 함수



