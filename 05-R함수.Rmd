# R 기본 함수

## R 수학 함수

### abs() 

`abs(x)`는 x의 절대값을 반환합니다.

```{r}
abs(-123)
```

### ceiling()

`ceiling(x)`는 x보다 큰 수 중 가장 작은 정수를 반환합니다.

```{r}
ceiling(2.5)
ceiling(-2.5)
```

### floor()

`floor(x)`는 x보다 작은 수 중 가장 큰 정수를 반환합니다.

```{r}
floor(2.5)
floor(-2.5)
```

### trunc()

`trunc(x)`는 0과 x사이의 가장 큰 정수를 반환합니다.

```{r}
trunc(2.5)
trunc(-2.5)
```
### round()

'round(x, digits = n)'는 x를 소수점 n+1 자리에서 반올림하여 소수점 n번째 자리까지 반환합니다. 만일 digits의 값이 음수이면 10^n-1^ 자리에서 반올림하여 0을 10^n^ 자리까지 만들어 반환합니다. digits 인자의 기본값은 0입니다.    
R의 반올림 함수는 국제표준(IEEE 754:2008, ISO/IEC/IEEE 60559:2011)을 따르고 있습니다. 따라서 Excel의 반올림 함수와는 다른 결과 값을 보여줍니다. 예를 들면 Excel에서 `=round(2.5, 0)`을 하면 3이 나오지만, R에서는 `round(2.5, digits = 0)`을 하게 되면 2가 나오게 됩니다.    
이는 위 부동소숫점 실수와 관련된 국제표준에서 반올림의 모드로 제시된 5가지 방법 중 **짝수로 반올림(round to nearest, ties to even)**를 기본모드로 선택하였기 때문입니다. '짝수로 반올림' 모드는 '은행원의 반올림', '오사오입'이라고도 불리우는 방법으로 반올림으로 인한 오류의 기대값을 0으로 하는 효과가 있습니다. 이 방법은 가장 가까운 표현 가능한 숫자로 반올림하되, 원래 값이 가능한 숫자 두 개의 중간에 걸쳐 있으면 둘 중 가수부의 마지막 자리가 짝수인 값으로 반올림합니다. 예를 들면 52.5는 52, 51.5는 52로 반올림합니다.

```{r}
round(.5 + -3:4)
round(2.2579, digits = 2)
round(2578.23, digits = -2)
```

### signif()

`signif(x, digits = n)`는 지정한 유효숫자(significant digits)인 n만큼 자리수를 만들어 반올림 합니다. digits 인자의 기본값은 6입니다. 숫자들의 열을 깔끔하게 맞추고자 할 때 많이 사용합니다.

```{r}
signif(3.141593, digits = 3)
signif(23.593, digits = 3)
```

### sqrt()

`sqrt(x)`는 x의 제곱근을 반환합니다.

```{r}
sqrt(9)
```

### 로그함수

* `log(x)`는 밑이 e인 x의 자연로그값을 반환합니다.
* `log10(x)`은 밑이 10인 x의 상용로그값을 반환합니다.
* `log2(x)`는 밑이 2인 x의 이진로그값을 반환합니다.
* `log(x, base)` 밑이 base인 x의 로그값을 반환합니다.
* `log1p(x)`는 밑이 e인 x+1의 자연로그값을 반환합니다.

```{r}
log(3)
log10(3)
log2(3)
log(3, 5)
log(0)
log1p(0)
```

### exp()

* `exp(x)`는 상수 e를 x만큼 제곱한 값을 반환합니다.
* `expm1(x)`는 상수 e를 x만큼 제곱한 값에서 1을 뺀 값을 반환합니다.

```{r}
exp(3)
exp(log(3))
expm1(3)
```

### 삼각함수

* `cos(x)`는 x 라디안 각도의 코사인 값을 반환한다.
* `sin(x)`는 x 라디안 각도의 사인 값을 반환한다.
* `tan(x)`는 x 라디안 각도의 탄젠트 값을 반환한다.
* `acos(x)`, `asin(x)`, `atan(x)`, `atan2(x)`는 역삼각함수입니다.
* `cospi(x)`, `sinpi(x)`, `tanpi(x)` 는 `pi*x`의 삼각함수입니다. 입력이 pi의 배수일 때 정밀한 계산을 위해 사용합니다.

```{r}
sin(pi)
sin(1)
sinpi(3)
asin(1)
```
```{r}
# 사인 곡선 (Sign Curve)
x <- seq(-10, 10, 0.1)
plot(x, sin(x), type = "l", col = "blue", 
     ylab = "", xlab = "", main = "삼각함수 그래프")
lines(x, cos(x), type = "l", col = "red")
legend("topleft", c("sin(x)", "cos(x)"), fill=c("blue", "red"))
```
```{r}
# 삼각함수 그래프
x <- seq(0, 2*pi, 0.1)
plot(x, sin(x), type = "l", col = "blue", 
     ylab = "", xlab = "", main = "사인 곡선")
```

### 누적함수

* `cumsum(x)` x 벡터의 누적 합 벡터를 반환합니다.
* `cumprod(x)` x 벡터의 누적 곱 벡터를 반환합니다.
* `cummax(x)` x 벡터의 누적 최대값 벡터를 반환합니다.
* `cummin(x)` x 벡터의 누적 최소값 벡터를 반환합니다.

```{r}
cumsum(1:10)
cumprod(1:9)

# 오른쪽으로 숫자를 이동하면서 과거 지나온 숫자를 비교하여 최대 또는 최소값을 반환
(x <- c(3:1, 2:0, 4:2))
cummax(x)
cummin(x)
```

### sum()

`sum(x, na.rm = FALSE)`는 x벡터의 합계를 반환합니다.

```{r}
sum(1:5)
sum(1:5, NA)
sum(1:5, NA, na.rm = TRUE)
```

### diff()

`diff(x, lag = 1, differences = 1)`는 두 수의 차이값을 반환합니다. lag 인수는 두 수의 간격을 나타냅니다. `lag = 2`이면 두 칸 간격의 두 수 차이입니다. differences 인수는 차분의 차수입니다. `differences = 2`이면 차분을 두번한 값을 반환합니다.

```{r}
x <- c(1, 5, 10, 16, 23)
diff(x)   # 5-1, 10-5, ...
diff(x, lag = 2)   # 10-1, 16-5, ...
diff(x, differences = 2)   # diff(diff(x)), (10-5)-(5-1), ...
```

### prod()

`prod(x, na.rm = FALSE)`는 x 벡터의 곱을 반환합니다.

```{r}
prod(2, 3, 5)   # 2*3*5
prod(c(2, 3, 5, NA), na.rm = TRUE)
prod(1:5)     # 1*2*3*4*5
gamma(6)      # 1*2*3*4*5
factorial(5)  # 1*2*3*4*5
```

### gamma(), factorial()

감마함수(gamma function)는 오일러(Leonhard Euler)가 정수만 적용되는 **n!**을  실수로 확장하기 위해 제안한 함수입니다. 

* `gamma(x)`는 x-1의 계승값을 반환합니다. 즉 gamma(x)는 factorial(x-1)과 동일합니다.
* `factorial(x)`는 x의 계승값을 반환합니다.

```{r}
gamma(6)
factorial(5)
gamma(5.32)
factorial(4.32)
```

```{r}
# lgamma()는 gamma()의 결과값에 자연로그를 적용하는 함수
lgamma(6)
log(gamma(6))
```
```{r}
# lfactorial()은 factorial()의 결과값에 자연로그를 적용하는 함수
lfactorial(5)
log(factorial(5))
lgamma(5+1)
```
`gamma()` 함수와 연관된 함수는 `lgamma()` 외에도 `psigamma(x, deriv = 0)`, `digamma(x)`, `trigamma(x)`가 있습니다.

### beta()

베타함수는 감마함수를 만든 오일러가 만든 함수입니다. 감마보다 먼저 만들어진 함수라서 알파, 베타, 감마의 순서에 따라 베타함수로 이름이 지어졌습니다. 베타함수는 이항계수의 일반화라고 할 수 있습니다. 

```{r}
beta(2, 5)
```

### choose()

`choose(n, k)`는 n개에서 순서에 상관없이 k개를 뽑는 경우의 수를 반환합니다.
수식은 $n!/(n-k)!k!$ 입니다.

```{r}
choose(5, 2)

# 로또 확률 (45개 중 순서에 상관없이 6개 뽑기)
choose(45, 6)
```
### 복소수 함수

R에서는 복소수 관련 연산이나 함수를 지원합니다. 

* `Re(x)`는 복소수 x의 실수(Real) 부분을 반환합니다.
* `Im(x)`는 복소수 x의 허수(Imaginary) 부분을 반환합니다.
* `Mod(x)`는 복소수 x의 절대값(modulus)을 반환합니다.
* `Arg(x)`는 복소수 x의 편각(argument)을 반환합니다.
* `Conj(x)`는 복소수 x의 공액 복소수(허수부의 부호만 바뀐 복소수)를 반환합니다.

```{r}
x <- 2 + 3i
Re(x)
Im(x)
Mod(x)
Arg(x)
Conj(x)
```

### 집합 함수

* `union(x, y)`는 x와 y의 합집합을 반환합니다.
* `intersect(x, y)`는 x와 y의 교집합을 반환합니다.
* `setdiff(x, y)`는 x에 있고 y에는 없는 (x-y)차집합을 반환합니다.
* `setequal(x, y)`는 x와 y가 같은지 비교검사 결과를 반환합니다.
* `is.element(el, set)`는 el에 있는 각 원소들이 set집합에 포함되는지를 검사합니다. `x %in% y`와 동일합니다.

```{r}
set.seed(123)
(x <- c(sort(sample(1:20, 9)), NA))
(y <- c(sort(sample(3:23, 7)), NA))

union(x, y)         # 합집합
intersect(x, y)     # 교집합
setdiff(x, y)       # 차집합(x-y)
setdiff(y, x)       # 차집합(y-x)
setequal(x, y)      # 비교

is.element(x, y)    
x %in% y            # is.element(x, y)와 동일

all(is.element(x, y))  # x가 y에 모두 포함되어 있으면 TRUE
```

### 푸리에 함수

* `fft(x, inverse = FALSE)`는 x의 고속 푸리에 변환 값을 반환합니다.
* `mvfft(x, inverse = FALSE)`는 행렬 x의 각 열의 고속 푸리에 변환 값을 반환합니다.
* `filter(x, filter)`는 시계열에 선형 필터를 적용합니다.
* `convolve(x, y)` 

```{r}
(x <- matrix(c(1, 2, 3, 2, 20, 26, 3, 26, 38), nrow = 3))
fft(x)
mvfft(x)
```
```{r}
x <- 1:5
filter(x, rep(1, 3), method="recursive")

```

### 수치해석 함수

* polyroot 근구하기
* uniroot
* D 미분
* integrate 적분



## R 행렬 함수

### t()

`t(x)`는 행렬 x의 전치행렬(행과 열이 서로 바뀜)을 반환합니다.

```{r}
(x <- matrix(1:12, 3, 4))
t(x)
```

### diag()

`diag(x = 1, nrow, ncol, names = TRUE)`는 대각행렬을 반환합니다.

```{r}
# 주대각선의 원소가 모두 1인(단위행렬) 3x3 대각행렬
diag(3)  

# 주대각선의 원소가 모두 10인 3x4 대각행렬
diag(10, 3, 4)

# 주대각선의 원소를 지정한 대각행렬
diag(c(2, 5, 3, 1))

# 행렬 x의 대각행렬
(x = matrix(c(1,3,-2, 5, 7, -3, 1, 0, 1), 3, 3))
diag(x)
```

### %*%   

`x %*% y`는 행렬 x와 행렬 y의 곱셈 결과를 반환합니다.

```{r}
(x <- 1:4)
(y <- diag(x))
(z <- matrix(1:12, ncol = 3, nrow = 4))

x %*% x
y %*% z
y %*% x
x %*% z
```

### outer()

`outer(x, y, FUN = "*", ...)`는 두 벡터 또는 배열의 외적(outer product)를 반환합니다. 외적이란 x에 y의 전치행렬을 곱한 결과입니다.    
`outer(x, y)`는 `x %*% t(y)`와 동일하며, `x%o%y`와 동일합니다.

```{r}
(x <- 1:4)
(y <- 5:8)
outer(x, y)
x %*% t(y)
x%o%y
```

`outer(x, y, FUN = "*", ...)`에서 `FUN = "*"`로 인해 곱셈을 합니다. 만일 기본값인 *을 +로 변경하면 덧셈을 하게 됩니다.

```{r}
outer(x, y, FUN = "+")
```

### solve()

`solve(a, b, ...)`는 수식 a %*% x = b에서 x를 구하여 반환합니다. 
만일 b를 지정하지 않으면 a의 역행렬을 반환합니다.

```{r}
(a <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))
(b <- c(2, -1, 1))

# ax=b에서 x를 구하여 반환
solve(a, b)  

# a의 역행렬을 반환환
solve(a)
```

### rowSums()

`rowSums(x, na.rm = FALSE, dims = 1)`는 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 행 합계를 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))
rowSums(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

rowSums(df)
```

### colSums()

`colSums (x, na.rm = FALSE, dims = 1)`은 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 열 합계를 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))

colSums(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

colSums(df)
```

### rowMeans()

`rowMeans(x, na.rm = FALSE, dims = 1)`는 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 행 평균을 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))
rowMeans(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

rowMeans(df)
```

### colMeans()

`colMeans (x, na.rm = FALSE, dims = 1)`은 숫자를 담고 있는 2차원 이상의 배열 또는 데이터프레임 x의 열 합계를 반환합니다.


```{r}
(x <- matrix(c(1, 3, -2, 5, 7, -3, 1, 0, 1), 3, 3))

colMeans(x)
```

```{r}
a <- 1:5
b <- 1:5*2
c <- 1:5*3
df <- data.frame(a, b, c)
df

colMeans(df)
```

### nrow(), ncol()

* `nrow(x)`는 행의 갯수를 반환합니다.
* `ncol(x)`는 열의 갯수를 반환합니다.
* `NROW(x)`는 행의 갯수를 반환합니다. (벡터 계산 가능)
* `NCOL(x)`는 열의 갯수를 반환합니다. (벡터 계산 가능)

```{r}
x <- matrix(1:12, 3, 4)
nrow(x)
ncol(x)
NROW(x)
NCOL(x)
```
```{r}
(x <- array(1:24, dim = c(3,4,2)))  # 3행*4열의 3차원 배열
nrow(x)
ncol(x)
```

NROW와 NCOL은 행렬이 아닌 벡터도 계산합니다.

```{r}
x <- 1:12
nrow(x)
NROW(x)
ncol(x)
NCOL(x)
```

### det()

`det(x)`는 행렬 x의 행렬식을 구하여 반환합니다. 행렬식은 정방행렬(nxn 행렬)인 경우에만 구할 수 있습니다.
$det \begin{pmatrix}a&b\\c&d\end{pmatrix} = ad-bc$

```{r}
(x <- matrix(1:4, nrow = 2))
det(x)
```

### eigen()

`eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE)`는 행렬 x의 고유값과 고유벡터를 반환합니다.

고유값과 고유벡터는 행렬 A에 대하여 $Av = \lambda v$ 등식을 만족하는 상수와 열벡터입니다. 등식에서 v는 고유벡터이고 $\lambda$는 고유값입니다.
고유값과 고유벡터는 정방행렬(nxn 행렬)인 경우에만 구할 수 있습니다.

```{r}
(x <- matrix(1:4, nrow = 2))
eigen(x)
```

### svd()

`svd(x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)`는 행렬 x의 특이값을 분해하여 그 결과를 반환합니다.

고유값 분해는 정방행렬(nxn 행렬)인 경우에만 가능합니다. 이를 직사각행렬(mxn행렬)에서도 가능하게 만든 것이 특이값 분해(SVD: Singular Value Decomposition)입니다.

$M = UDV^T$

```{r}
x <- matrix(c(0, 0, 0, 1, 1, 0, 0, 0,
              1, 0, 0, 1, 1, 0, 0, 0,
              0, 0, 0, 1, 1, 0, 0, 0,
              1, 1, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1,
              0, 0, 0, 1, 1, 0, 0, 0,
              0, 0, 0, 1, 1, 0, 0, 0,
              0, 0, 0, 1, 1, 0, 0, 0),
            byrow = TRUE, nrow = 10)
x
x_svd <- svd(x)
x_svd

# 특이값 벡터 d의 첫번째와 두번째 값을 이용하여 원래 행렬 구하기
round(x_svd$u[,c(1,2)] %*% diag(x_svd$d[c(1,2)]) %*% t(x_svd$v[,c(1,2)]))
```

### qr()

`qr(x)`은 행렬 x의 QR 분해결과를 반환합니다. 
QR분해는 행렬 A를 $A = QR$로 분해하는 것입니다. Q는 단위 노름 직교 벡터를 갖는 행렬이고, R은 상삼각행렬입니다.

```{r}
x <- matrix(c(1,2,3, 2,4,6, 3,3,3), nrow=3)
x_qr <- qr(x)
x_qr
```

### scale()

`scale(x, center = TRUE, scale = TRUE)`는 행렬이나 벡터 x를 정규화(표준화)한 결과를 반환합니다. 옵션 center는 평균을 의미하며, scale은 표준편차를 의미합니다.
x가 벡터일 경우 $z = (x-u)/\sigma$를 구해서 반환합니다. center가 FALSE이면 값에서 평균을 빼지 않으며, scale이 FALSE이면 표준편차로 나누지 않습니다.

```{r}
# 1~9 벡터를 표준화하기 (평균을 빼고 표준편차로 나눔)
(x <- 1:9)
scale(x)
```

x가 행렬일 경우에는 열을 기준으로 평균과 표준편차를 구한 후, 열 기준으로 표준화를 합니다.

```{r}
(x <- matrix(1:9, ncol = 3))
scale(x)
```

## R 논리 함수

### any()

`any(..., na.rm = FALSE)`는 주어진 논리 벡터 중에 어느 하나라도 TRUE이면 TRUE를 반환합니다.

```{r}
# 어느 하나라도 0미만 이면 TRUE 반환
(x <- seq(-3, 3, by = 1))
any(x < 0)
if (any(x < 0)) cat("x는 음수를 포함하고 있습니다\n")
```

### all()

`all(..., na.rm = FALSE)`는 주어진 논리 벡터 모두가 TRUE이면 TRUE를 반환합니다. 어느 하나라도 FALSE가 있으면 FALSE를 반환합니다.

```{r}
(x <- seq(-3, 3, by = 1))
all(x < 0)

if (all(x >= -3 )) cat("x에 포함된 수는 모두 -3 이상입니다\n")
```

### which()

`which(x, arr.ind = FALSE, useNames = TRUE)`는 벡터(또는 배열) x에서 TRUE인 것의 위치를 반환합니다. x가 배열인 경우 arr.ind = TRUE이면 배열형태의 위치를 반환합니다.

```{r}
# 벡터 위치 반환
(x <- 5:10)
which(x == 7)
x[which(x == 7)]
```

```{r}
# 배열 위치 반환
x <- 5:16
dim(x) <- c(2, 2, 3); x  # x를 2x2 행렬의 3층 배열로 만들기
which(x == 15)                    # 벡터형태의 위치 반환
which(x == 15, arr.ind = TRUE)    # 배열형태의 위치 반환
```


```{r}
# 행렬 위치 반환 (배열과 유사)
x <- matrix(5:16, 3, 4); x
which(x %% 3 == 0)                   # 벡터형태의 위치 반환
which(x %% 3 == 0, arr.ind = TRUE)   # 행렬형태의 위치 반환
```

```{r}
# 데이터 프레임 위치 반환
str(women)   # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드)
which(women$height < 60)
women[which(women$height < 60),]
```

### which.min()

`which.min(x)`는 벡터 x의 최소값 위치를 반환합니다.

```{r}
# 벡터
x <- c(1:4, 0:5, 11); x
which.min(x)
```
```{r}
# 데이터프레임
str(women)   # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드)
which.min(women$weight)
women[which.min(women$weight)]
```

### which.max()

`which.max(x)`는 벡터 x의 최대값 위치를 반환합니다.

```{r}
# 벡터
x <- c(1:4, NA, 11, 0:5); x
which.max(x)
```
```{r}
# 데이터프레임
str(women)   # R 내장 데이터셋 women - 미국 여성 키(인치)와 몸무게(파운드)
which.max(women$weight)
women[which.max(women$weight),]
```

### isTRUE()

`isTRUE(x)`는 x가 TRUE이면 TRUE를 반환합니다. 유사한 것으로 `isFALSE(x)`가 있습니다.

```{r}
x <- TRUE
isTRUE(x)
isFALSE(x)
```


## R 반복 함수

### apply()

`apply(X, MARGIN, FUN, …)`는 X를 입력받아 행 또는 열 방향으로 함수를 적용하여 결과값을 반환합니다. MARGIN 인수가 1이면 행 방향으로, 2이면 열 방향으로 연산이 됩니다.
apply 함수에 입력하는 데이터(X)는 배열, 매트릭스만 가능하고, 만일 데이터프레임이 모두 같은 데이터 타입이면 가능합니다. 반환되는 값은 벡터나 행렬입니다.

```{r}
(x <- matrix(1:12, c(3,4)))
apply(x, 1, mean)   # 행 방향으로 평균
apply(x, 2, mean, na.rm = TRUE)   # 열 방향으로 평균, mean함수 옵션 추가
```
벡터는 apply에 입력데이터로 사용할 수 없습니다(에러 발생). 만일 벡터를 사용하고자 한다면 배열로 변환하여 사용하여야 합니다.

```{r}
x <- 1:12
dim(x) <- c(1, length(x)); x     # 벡터를 배열로 변환
apply(x, 1, mean)
```
함수는 사용자 정의 함수를 만들어서 사용할 수 있습니다.
```{r}
(x <- matrix(1:12, c(3,4)))
apply(x, 2, function(x) {x*2})

# 행방향으로 하면 행과 열이 바뀝니다.
apply(x, 1, function(x) {x})
apply(x, 1, function(x) {x*2})
```

데이터프레임도 데이터가 모두 같은 타입이라면 apply를 적용할 수 있습니다. R의 기본 데이터셋인 iris에서 Factor 타입인 Species를 제거한 후 apply에 사용하도록 하겠습니다.

```{r}
str(iris)
x <- iris[, -5]; str(x)
apply(x, 2, mean, na.rm = TRUE)
apply(x, 2, function(x) {median(x*2-1, na.rm = TRUE)})
```

### lapply()

`lapply(X, FUN, …)`는 X를 입력받아 함수를 적용하여 결과값을 반환합니다. 
lapply 함수에 입력하는 데이터(X)는 벡터, 리스트 등도 가능하고, 반환되는 값은 리스트입니다. 

apply는  X의 행이나 열 방향의 데이터가 한꺼번에 함수로 전달되는 반면에, lapply는 X의 데이터 요소가 하나 하나 함수로 전달됩니다. 행렬이나 배열의 요소는 기본적으로 벡터의 요소와 같은 방식이기 때문에 값이 하나 하나 전달됩니다. 

```{r}
# 아래와 같이 코드를 실행하면 x의 평균이 반환되지 않습니다.
# x값이 하나 하나 mean 함수에 전달되어 각각 계산되기 때문입니다.
x <- matrix(1:6, c(2,3))
lapply(x, mean, na.rm = TRUE)
```

lapply는 리스트로 반환이 됩니다. 이를 벡터로 변환하고자 한다면 unlist 함수를 적용합니다.

```{r}
x <- 1:3
lapply(x, function(x) {x*2+1})          # 리스트 형태로 반환
unlist(lapply(x, function(x) {x*2+1}))  # 리스트를 벡터로 변환하여 반환
```
데이터프레임도 lapply 함수에 입력데이터로 사용 가능합니다. 데이터프레임의 각 요소 즉 각 변수별로 한꺼번에 함수에 전달됩니다.

```{r}
str(iris)
lapply(iris, mean, na.rm = TRUE)
```

리스트가 입력되면 리스트의 각 요소가 한꺼번에 함수에 전달됩니다. 예를 들어 mean함수를 사용하면 리스트 각 요소별 평균값을 반환합니다.

```{r}
x <- list(a = 1:10, 
          beta = exp(-3:3), 
          logic = c(TRUE,FALSE,FALSE,TRUE))
x
lapply(x, mean)
lapply(x, quantile, probs = (1:3)/4)
```

### sapply() 

`sapply(X, FUN, …, simplify = TRUE, USE.NAMES = TRUE)`는 단순화된(simplify) lapply 함수라 할 수 있습니다. lapply는 리스트 형태로 반환되기 때문에 사용하기 불편한 점이 있는데 sapply는 기본적으로 벡터나 행렬 형태로 반환합니다. 만일 옵션 simplify = FALSE이면 lapply와 동일하게 리스트 형태로 반환됩니다. 

```{r}
x <- 1:3
sapply(x, function(x) {x*2+1})    
```
```{r}
str(iris)
sapply(iris, mean, na.rm = TRUE)
```
```{r}
x <- list(a = 1:10, 
          beta = exp(-3:3), 
          logic = c(TRUE,FALSE,FALSE,TRUE))
x
sapply(x, mean)
sapply(x, quantile, probs = (1:3)/4)
```

### vapply()

`vapply(X, FUN, FUN.VALUE, …, USE.NAMES = TRUE)`는 sapply와 유사합니다. 차이점은 반환되는 결과의 양식을 지정할 수 있습니다.

```{r}
str(iris)
# sapply로 fivenum 출력
sapply(iris[, 1:4], fivenum, na.rm = TRUE)

# vapply로 fivenum 출력, 출력양식 지정
vapply(iris[, 1:4], fivenum, 
       c("최소값" = 0, "1사분위수" = 0, "중위수" = 0, 
         "3사분위수" = 0, "최대값" = 0),
       na.rm = TRUE)

```

### tapply()

`tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)`는 요인(factor) 변수를 기준으로 그룹별로 나누어서 함수를 적용합니다. X는 벡터입니다. INDEX는 요인 또는 요인 리스트가 들어가는 인수입니다. 만일 X에 데이터프레임을 넣고 싶으면 `by()`함수를 쓰면 됩니다.

```{r}
# iris 데이터의 요인변수 Species 별로 평균 구하기
str(iris)
tapply(iris$Sepal.Length, iris$Species, mean, na.rm = TRUE)
```

```{r}
# 팩터변수가 2개가 되면 교차표가 만들어짐
# x[, -1]은 wool과 tension으로 구성된 데이터프레임
str(x <- warpbreaks)
tapply(x$breaks, x[, -1], sum)
```

```{r}
# 데이터 무작위 30개 만들어 x에 할당
set.seed(234)
x <- c(rnorm(10), runif(10), rnorm(10, 1))
str(x)

# 팩터 변수 생성(값 30개)
# gl(n, k)는 1부터 n까지 정수로된 팩터 레벨을 k만큼 반복해서 만듬 
fac <- gl(3, 10)   # factor(rep(1:3, each = 10), levels = 1:3)와 동일
fac
  
tapply(x, fac, mean)
tapply(x, fac, range)
```

### mapply() 

`mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)`는 
sapply의 다변량 버전이라 할 수 있습니다. 여러 개의 인자를 입력할 수 있고, 
반환하는 값은 리스트, 벡터, 배열 등이 가능합니다.
MoreArgs는 함수에 들어갈 또다른 인수 리스트입니다.

```{r}
# rep(1, 4), rep(2, 3), ..., rep(x = 4, times = 1)  => 리스트 반환
mapply(rep, 1:4, 4:1) 

# rep(1, 3), rep(2, 3), ..., rep(x = 4, times = 3)  => 행렬 반환
mapply(rep, 1:4, 3)

# rep(times = 1, x = 4), rep(times = 2, x = 3), ... 
mapply(rep, times = 1:4, x = 4:1)

# rep(x = 23, times = 1), rep(x = 23, times = 2), ...  
mapply(rep, 1:4, MoreArgs = list(x = 23))
```

```{r}
# sprintf(" %d%s ", 1, "a"), ....
mapply(function(i, s) { 
  sprintf(" %d%s ", i, s) 
  }, 
  i = 1:3, s = c("a", "b", "c"))
```

MoreArgs 인수는 여러 개의 데이터를 한꺼번에 함수에 넣어줍니다. 
이 것을 사용하지 않으면 데이터가 하나씩 함수에 들어갑니다.

```{r}
sumsq <- function(x, mean = 0, sd = 1) {
  sum(((x - mean) / sd)^2)
}

set.seed(123)
x <- rnorm(10000)

# sumsq(x, mean = 1, sd = 1), sumsq(x, mean = 2, sd = 2), ...
mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x))

# 만일 이렇게 mapply(sumsq, mean = 1:100, sd = 1:100, x = x) 하면
# sumsq(x = x[1], mean = 1, sd = 1), ... 이런식으로 계산되어
# 원하는 결과가 나오지 않음. 여기서 x[1]은 -0.560475647임
```


### eapply()

`eapply(env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE)`는 환경(Environment)에 있는 변수나 함수들을 반복 계산해 줍니다.

```{r}
# 새로운 환경 만들기; R에서 전역환경은 .GlobalEnv 임
env <- new.env()
env$a <- 10
env$b <- 20:23
env$c <- 30:35

# 전역변수 자료형 확인하기
eapply(env, typeof)

# env 환경변수의 각 요소에 2를 곱하기
eapply(env, function(x) {x * 2})
```

### by()

`by(data, INDICES, FUN, …, simplify = TRUE)`는 데이터프레임을 위한 tapply라 할 수 있다. 요인(factor) 변수를 기준으로 그룹별로 나누어서 함수를 적용합니다. data는 데이터프레임이나 행렬입니다. INDEX는 요인 또는 요인 리스트가 들어가는 인수입니다.

```{r}
str(iris)
by(iris, iris$Species, summary)
```

```{r}
# 팩터변수가 2개가 되면 그만큼 그룹으로 더 나뉘어짐
# x[, -1]은 wool과 tension으로 구성된 데이터프레임
str(warpbreaks)
by(warpbreaks[, 1], warpbreaks[, -1], summary)
```

### split()

* `split(x, f, drop = FALSE, ...)`은 f에 정의된 그룹(보통 팩터 또는 리스트)에 따라 벡터 x를 분리합니다. 반환되는 값은 리스트입니다.
* `unsplit(value, f, drop = FALSE)`은 분리된 벡터 리스트 또는 데이터프레임인 value를 f에 정의된 그룹기준으로 원상태로 되돌립니다. 반환되는 값은 벡터나 데이터프레임입니다.

```{r}
str(iris)

# iris 데이터프레임을 Species 기준으로 분리합니다. (결과 리스트 형태) 
x <- split(iris, iris$Species)
str(x)

# 분리된 것을 다시 원상태로 돌립니다. (결과 데이터프레임)
y <- unsplit(x, iris$Species)
str(y)
```

두 개 칼럼을 기준으로 분리할 수 있습니다. 2개 이상의 칼럼을 기준으로 할 때에는 리스트 구조로 묶어줍니다.

```{r}
str(infert)  # R 내장 데이터 infert

x <- split(infert, list(infert$spontaneous, infert$education))
str(x, max.level = 1)
```

행의 갯수를 지정해서 데이터를 분리할 수 있습니다. 인수 f에 데이터를 나눌 기준이 될 벡터을 만들면 됩니다. 그러면 같은 수를 가진 행끼리 하나의 그룹으로 만들어집니다. 단, 이 기준 벡터의 수와 데이터의 갯수가 같아야 오류가 나지 않습니다.

```{r}
# infert 데이터의 전체 행을 10개씩 구분하는 기준 벡터를 만듭니다. 
df <- iris     # 데이터
gnum <- 10     # 그룹의 갯수
f <- c(rep(1:floor((nrow(df)/gnum)), each = gnum),
       rep(ceiling(nrow(df)/gnum), each = nrow(df)%%gnum))

x <- split(df, f)
print(x[1:2]); cat("... 이하 생략 ...")
```

```{r}
# 위 예제에서 분리된 것을 같은 기준으로 하나로 묶습니다.
y <- unsplit(x, f)
str(y)
```

### Vectorize()

`Vectorize(FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, USE.NAMES = TRUE)`
함수는 인자 FUN에 들어간 함수가 벡터 방식으로 작동하도록 만드는 함수입니다. 함수 중에는 함수의 인자가 단 하나의 값만 들어가야 하는 경우가 있어 인자에 여러 개의 값 즉 벡터형식으로 넣을 수 없는 함수들이 있습니다. Vectorize() 함수는 이 문제를 해결하여 줍니다. 이때 벡터형식으로 들어갈 인자를 vectorize.args에 지정합니다. 반환되는 결과는 벡터로 들어간 인자들이 각각 투입된 만큼의 결과들이 행렬이나 배열로 묶여서 나옵니다. 

아래 예제는 iris$Species에서 vi나 se로 시작하는 행을 추출하고자 하는 것입니다.

```{r}
# grepl함수는 pattern 인수에 단 하나의 값만 넣을 수 있습니다. 
# 만일 아래 같이 벡터형식으로 값을 여러 개 넣으면 첫번째 요소만 사용되어
# 원하는 결과를 얻을 수없습니다.
x <- grepl(pattern = c("^vi", "^se"), x = iris$Species)
head(x)

# grepl 함수를 벡터작업이 가능한 함수 vgrepl로 만듭니다. 
# 벡터로 들어갈 인수는 pattern으로 지정합니다.
vgrepl <- Vectorize(grepl, vectorize.args = "pattern")
x <- vgrepl(pattern = c("^vi", "^se"), x = iris$Species)
head(x)

# 조건에 맞는 행들을 추출합니다.
str(iris[rowSums(x) > 0, ])
```
물론 Vectorize() 함수를 사용하지 않고 sapply() 함수를 사용하여 같은 결과를 얻을 수 있습니다.

```{r}
x <- sapply(c("^vi", "^se"),
            function(pattern) {grepl(pattern = pattern, x = iris$Species)})
head(x)
```

```{r}
sumsq <- function(x, mean = 0, sd = 1) {
  sum(((x - mean) / sd)^2)}

set.seed(123)
x <- rnorm(10000)

# mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x))와 같은 결과
vsumsq <- Vectorize(sumsq, c("mean", "sd"))
vsumsq(x, 1:100, 1:100)
```

```{r}
sumsq <- function(x, mean = 0, sd = 1) {
  sum(((x - mean) / sd)^2)
}

set.seed(123)
x <- rnorm(10000)

# sumsq(x, mean = 1, sd = 1), sumsq(x, mean = 2, sd = 2), ...
mapply(sumsq, mean = 1:100, sd = 1:100, MoreArgs = list(x = x))

# 만일 이렇게 mapply(sumsq, mean = 1:100, sd = 1:100, x = x) 하면
# sumsq(x = x[1], mean = 1, sd = 1), ... 이런식으로 계산되어
# 원하는 결과가 나오지 않음. 여기서 x[1]은 -0.560475647임
```

### replicate()

`replicate(n, expr, simplify = "array")` 함수는 `sapply()` 함수의 간소화 버전이라 할 수 있습니다. expr 인자를 n번 만큼 반복수행합니다. expr 인자에는 주로 함수들이 많이 들어갑니다. 반환되는 결과는 기본적으로 배열입니다. 만일 반환되는 값을 리스트 형태로 받고자 한다면 `simplify = FALSE`로 지정합니다.

아래 예제는 `rnorm(5, mean = 0, sd = 1)`을 3번 반복하여 그 결과를 행렬형태로 얻는 것입니다.

```{r}
set.seed(123)
replicate(n = 3, rnorm(5, mean = 0, sd = 1))
```


### rep()

`rep(x, ...)` 함수는 특정값을 반복해서 만들어 반환해주는 함수입니다. `...`에는 인자로 times, length.out, each가 들어갈 수 있습니다. times는 x를 몇 번 반복할지를 정해주는 인수입니다. length.out은 최종 반환되는 값들의 길이를 정해주는 인수입니다. each는 x가 여러개의 값으로 구성된 벡터일 경우 각각 몇 번 반복할지를 정해주는 인수 입니다.

`rep.int(x, times)`와 `rep_len(x, length.out)`는 `rep()` 함수와 기능이 거의 같으나 인수가 제한됩니다. 이 함수들은 `rep()` 함수보다 더 빠릅니다.

```{r}
rep(1:5, 2)   # rep(x = 1:4, times = 2)와 동일
rep(1:5, each = 2)    
rep(1:5, c(2, 3, 2, 1, 2))  # rep(1:5, times = c(2, 3, 2, 1, 2)) 동일

rep(1:5, each = 2, len = 5)
rep(1:2, each = 2, len = 7)  # 길이를 채우기 위해 다시 반복
rep(1:3, each = 2, times =3)

rep(2, 5.9)  # 소수점 이하는 버리고 반복

rep(c("abc", "123"), times = 3)
rep(c("abc", "123"), each = 3)

rep.int(c("abc", "123"), 3)  # 기본인자는 times임. each 인자는 사용할 수 없음
rep_len(c("abc", "123"), 5)  # 기본인자는 length.out임
```

### seq()

`seq(...)` 함수는 일련번호 숫자를 생성하여 반환합니다. `...`에는 인자로 from, to, by, length.out, along.with가 들어갈 수 있습니다.

* from : 시작 숫자
* to : 끝 숫자
* by : 증가 간격
* length.out : 생성되는 일련번호의 길이
* along.with : 인자에 들어가는 값들의 길이만큼 일련번호 생성

`seq.int()`는 seq() 함수와 거의 동일하고, `seq_along(along.with)`와 `seq_len(length.out)`는 무조건 시작이 1이고, 각각 하나의 인자를 받아 일련번호를 생성합니다. 이 함수들은 1부터 시작하는 일련번호를 `seq()` 함수보다 약간 더 빠르게 만들어 줍니다. 

가장 많이 사용하는 형태는 다음과 같습니다.

* seq(from, to)
* seq(from, to, by = )
* seq(from, to, length.out = )
* seq(along.with = )
* seq(from)
* seq(length.out = )

```{r}
seq(2, 7)  # seq(from = 2, to = 7과 동일)
seq(7, 2)
seq(2, 10, by = 2)
seq(2, 10, by = pi)
seq(2, 10, length.out = 3)
seq(along.with = c(2:7))   # c(2:7)의 길이는 6이므로 6개 생성
seq(2, 10, along.with = c(2:7))
seq(7)   # 1부터 7까지 생성
seq(length.out = 12)
```

```{r}
seq.int(2, 10, by = pi)
seq_len(12)    # seq(length.out = 12)와 동일하나 약간 더 빠름
seq_along(c(2:7))
```

```{r}
n <- 999999999999999

start <- proc.time()
x <- seq(length.out = n)
end <- proc.time()
end - start

start <- proc.time()
x <- seq_len(n)
end <- proc.time()
end - start

```

일련 날짜를 생성할 수 있습니다.

```{r}
# 1년 간격
seq(as.Date("2001/1/1"), as.Date("2020/1/1"), "years")

# 월 간격
seq(as.Date("2001/1/1"), by = "month", length.out = 12)

# 분기 간격
seq(as.Date("2015/1/1"), as.Date("2020/1/1"), by = "quarter")

# 월 간격 반대로
seq(as.Date("2020-1-7"), as.Date("2019-1-17"), by = "-1 month")
```

```{r}
seq(ISOdate(2015,1,1), ISOdate(2020,1,1), "years")

seq(c(ISOdate(2020,3,20)), by = "DSTday", length.out = 10)

seq(c(ISOdate(2020,3,20)), by = "7 DSTdays", length.out = 5)
```

```{r}
seq(as.POSIXct("2015-3-14 17:22:15"), as.POSIXct("2015-3-15 9:12:25"),
    by = "hours")
```


### sequence()

`sequence(nvec, ...)` 함수는 연속적인 숫자를 만들어 내는 함수입니다. 
인자 nvec에 들어간 숫자 벡터들 만큼 `seq()` 함수가 수행되어 연속적인 숫자가 만들어집니다. 예를 들면 `nvec = c(3, 2)`이면 `seq(3)`, `seq(2)`가 수행됩니다.

```{r}
sequence(nvec = c(3, 2))   # c(seq(3), seq(2)) 또는 c(1:3, 1:2)와 동일
sequence(nvec = c(3, 2, 5))
sequence(c(3, 2), from = 2)  # 시작숫자 지정
sequence(c(3, 2), from = 2, by = -2)  # 시작숫자, 간격 지정
sequence(c(3, 2), by = c(2, -2))
```

### gl()

`gl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE)` 함수는
요인 수준을 반복적으로 생성하여 반환합니다. gl은 generate levels의 약자로 생각됩니다.

* n : 수준을 나태내는 숫자. n = 2이면 label을 따로 지정하지 않은 경우 수준이 1, 2로 표현됩니다.
* k : 수준을 반복할 숫자. k = 8이면 8번 반복합니다.
* length : 생성되는 총 데이터의 갯수
* labels : 수준에 대한 이름
* ordered : TRUE이면 요인의 순서가 정해집니다. (순서형 데이터)

```{r}
gl(n = 2, k = 8)  # 수준 1, 2를 각각 8번 반복
gl(n = 2, k = 8, labels = c("Contol", "Treat"))  # 수준 이름 지정
gl(n = 2, k = 1, length = 10)  # 수준 1, 2가 각각 1번씩 반복되며 10개 생성
gl(n = 2, k = 2, length = 10)  # 수준 1, 2가 각각 2번씩 반복되며 10개 생성

# 수준 1, 2가 M과 F로 순서있게 네이밍 되고, 각각 3번씩 반복되며 10개 생성
gl(2, 3, 10, labels = c("M", "F"), ordered = TRUE)
```

### sweep()

`sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)` 함수는
행렬, 데이터프레임 등에 통계량과 함수를 적용하여 그 결과를 반환하는 함수입니다.
데이터 x에 일률적으로 특정 숫자만큼 더하거나 빼기를 할 때 많이 사용합니다.

* x : 입력 데이터로서 배열, 행렬, 데이터프레임
* MARGIN : 행과 열 방향 지정. 1이면 열방향, 2이면 행방향 
* STATS : 적용할 요약 통계량 또는 수치
* FUN : 적용할 함수 (기본값은 "-" 임)


```{r}
x <- matrix(1:12, ncol = 3); x

# 행렬 x를 행방향(2)으로 1씩 빼줌
sweep(x, MARGIN = 2, STATS = 1, FUN = "-")  

# 행렬 x를 열방향(1)으로 각각 1, 2, 3, 4를 더해줌
sweep(x, 1, c(1,2,3,4), FUN = "+")  

# 행 기준 비율 계산
round(sweep(x, 1, apply(x, 1, sum), FUN = "/") * 100, 1)

# 열 기준 비율 계산
round(sweep(x, 2, apply(x, 2, sum), FUN = "/") * 100, 1)

# 전체 기준 비율 계산
round(sweep(x, 2, sum(x), FUN = "/") * 100, 1)
```
```{r}
# 데이터프레임의 숫자 열에 각각 1씩 빼기
str(iris)
y <- sweep(iris[1:4], MARGIN = 2, STATS = 1, FUN = "-") 
str(y)
```

### aggregate()

`aggregate(x, ...)` 함수는 데이터 x의 그룹별로 함수를 적용하여 그 결과를 반환합니다. 

* x : 입력 데이터
* by : 그룹핑 변수(열)로서 리스트 형식이어야 함
* FUN : 적용할 함수

```{r}
str(iris)
# 종류별로 평균을 구함
aggregate(iris[1:4], by = list(iris$Species), mean, na.rm = TRUE)

# 그룹핑 그룹에 이름을 지정할 수 있음(종류)
aggregate(iris[1:4], by = list(종류 = iris$Species), mean, na.rm = TRUE)

# 적용할 함수에 인자들을 지정할 수 있음
aggregate(iris[1:4], by = list(종류 = iris$Species), mean, na.rm = TRUE, trim = 0.1)
```


```{r}
str(infert)  # R 내장 데이터 infert

# 2개 변수로 그룹핑
aggregate(infert[2:3], by = list(infert$education, infert$spontaneous), 
          mean, na.rm = TRUE)
```


## R 통계 함수

### sample()

`sample(x, size, replace = FALSE, prob = NULL)` 함수는 데이터 x에서 무작위로 데이터를 size만큼 추출하여 반환합니다. 

* x : 1개 이상의 요소를 가진 벡터(모집단)
* size : 추출할 갯수(표본의 크기)
* replace : 기본값은 FALSE로 비복원 추출, TRUE이면 복원 추출
* prob : 표본이 추출될 가중치

간소화 버전 함수로 `sample.int(n, size = n, replace = FALSE, prob = NULL)`가 있습니다. 1부터 n 사이의 값에서 기본적으로 n만큼 데이터를 추출합니다. 만일 size를 지정하면 size 숫자만큼 추출합니다.

```{r}
set.seed(5)  # 아래 무작위 추출 결과가 항상 동일하게 나오게 함
x <- 1:12
sample(x, size = 5)
sample(x, size = 5, replace = TRUE)

# 1은 20%, 2는 30%, 3은 50% 확률로 추출됨 (가중표본추출)
sample(1:3, size = 5, replace = TRUE, prob = c(2, 3, 5))
```

```{r}
# 베루누이 실험 - 100회
sample(0:1, 100, replace = TRUE)
```

```{r}
# sample.int
sample.int(10)
sample.int(10, size = 5)

```

```{r}
# 데이터 프레임에서 무작위로 표본을 추출합니다. 
# 예제는 iris(150개 행)에서 30개를 무작위로 추출합니다.
str(iris)
set.seed(357)
idx <- sample(nrow(iris), 30)  # sample(1:150, size = 30)과 동일
idx  # 추출된 번호 확인(생략 가능)
sam <- iris[idx,]
str(sam)
```

데이터를 80:20으로 나누어 추출하겠습니다.

```{r}
dataset <- iris
str(dataset)
set.seed(357)
idx <- sample(1:nrow(dataset), size = round(0.8*nrow(dataset)))
train <- dataset[idx,] #훈련용 데이터
test <- dataset[-idx,] #검증용 데이터
str(train)
```

### 균등분포(unif)

> 확률분포는 **연속확률분포**와 **이산확률분포**로 구분할 수 있습니다. 
연속확률분포에는 균등분포, 정규분포, 표준정규분포, 감마분포, 지수분포, 베타분포, t분포, 카이제곱분포, F분포, 웨이블분포, 로그정규분포 등이 있습니다.
이산확률 분포는 베르누이분포, 이항분포, 다항분포, 초기하분포, 기하분포, 음이항분포, 포아송분포 등이 있습니다. 

균등분포는 분포가 특정 범위내에서 균등하게 나타나는 경우를 의미합니다. 다른말로 연속균등분포라고 합니다. 영어로는 uniform distribution입니다.

균등분포와 관련된 함수는 다음 4가지 있습니다. 

* `runif(n, min = 0, max = 1)` 
* `dunif(x, min = 0, max = 1, log = FALSE)`
* `punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)`
* `qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)`

위 함수명은 접두어 r, d, p, q와 균등분포를 의미하는 unif가 결합하여 만들어진 것입니다. 접두어의 의미는 다음과 같습니다.

* r : 난수(random number) 발생
* d : 확률밀도함수(density)
* p : 누적분포함수(distribution function)
* q : 분위수(quantile function)

runif 함수는 난수를 의미하는 r과 균등분포를 의미하는 unif가 결합하여 만들어진 함수명입니다. 따라서 `runif(n, min = 0, max = 1)` 함수는 최소값(0)부터 최대값(1)사이에 균등분포로 n개의 난수를 생성하여 반환합니다. 다른 확률분포 함수들의 함수명도 이와 같은 규칙으로 만들어졌다고 볼 수 있습니다. 

```{r}
runif(10, 2, 5)  # 2와 5사이에 균등분포로 10개의 난수 발생
runif(10)   # 0과 1사이에 균등분포로 10개의 난수 발생

mean(runif(100000))  # 0~1 균등분포로 추출된 값들의 평균은 0.5에 가까움
```

`dunif(x, min = 0, max = 1, log = FALSE)` 함수는 균등분포의 확률밀도함수입니다.
최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-2, 5, by = 0.01)
str(x)

# 균등분포의 확률밀도함수 시각화 (0과 3사이의 분포는 균등함)
plot(x, dunif(x, 0, 3), type = "l", col = "red")

# 0과 1사이의 균등분포에서 x가 0.5일때의 함수값?
dunif(0.5, 0, 3)
```

`punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 균등분포의 누적분포함수입니다.
최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-2, 5, by = 0.01)
str(x)

# 균등분포의 누적분포함수 시각화 (0과 3사이의 누적분포는 일정하게 상승함)
plot(x, punif(x, 0, 3), type = "l", col = "red")

# 0과 3사이의 균등분포에서 q가 0.5일때의 누적분포함수값은? 즉 확률은?
punif(0.5, 0, 3)
```

`qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)` 함수는  균등분포의 분위수를 구하는 함수입니다.
최소값(기본값 0)부터 최대값(기본값 1)사이의 균등분포함수에서 확률이 인자 p일 때의 분위수값을 구해 반환합니다. punif 함수와 반대되는 함수라 할 수 있습니다.

```{r}
# 0~5의 균등분포에서 확률이 0.3일때의 x값은 1.5
qunif(0.3, 0, 5)
# 0~5의 균등분포에서 x가 1.5일때의 확률은 0.3
punif(1.5, 0, 5)
```


### 정규분포(norm)

정규분포는 분포가 종 모양의 형태로 평균에 가까울수록 발생확률이 높고 평균에서 멀어질수록 발생할 확률이 낮은 분포입니다. 가우스가 처음 정립해서 가우시안(Gaussian) 분포라고도 합니다. 영어로는 normal distribution입니다.

표준정규분포(standard normal distribution)는 평균이 0이고, 표준편차가 1인 정규분포를 의미합니다.

> "양 끝의 극단에 있는 것은 드물고 소수인 반면, 중간에 있는 것들은 흔하고 다수임을 알지 못하나?" - 소크라테스, 파이돈

정규분포와 관련된 함수는 다음 4가지 있습니다. 

* `rnorm(n, mean = 0, sd = 1)`
* `dnorm(x, mean = 0, sd = 1, log = FALSE)`
* `pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)`
* `qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)`

`rnorm(n, mean = 0, sd = 1)` 함수는 주어진 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 n개의 난수를 생성하여 반환합니다. rnorm 함수명은 난수를 의미하는 r과 정규분포를 의미하는 norm이 결합되어진 것입니다.

```{r}
# 평균이 0이고 표준편차기 1인 표준정규분포에서 난수 10개 생성
rnorm(10)

# 평균이 50이고 표준편차기 3인 분포에서 난수 10개 생성
rnorm(10, mean = 50, sd = 3)
```

```{r}
x <- rnorm(2000)
hist(x)  
```

`dnorm(x, mean = 0, sd = 1, log = FALSE)` 함수는 정규분포의 확률밀도함수입니다.
평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 정규분포의 확률밀도함수 시각화
plot(x, dnorm(x, 0, 1), type = "l", col = "red")

# 표준정규분포에서 x가 0.5일때의 함수값?
dnorm(0.5, 0, 1)
```

```{r}
# 정규분포 그래프에서 -5에서 1까지의 면적(핑크색)은 전체면적의 84%
# pnorm(1, mean = 0, sd = 1)
x <- seq(-5, 5, by = 0.01)
plot(x, dnorm(x, 0, 1), type = "l", lwd = 2, col = "red")

u <- seq(-5, 1, by = 0.01)
v <- dnorm(u, mean = 0, sd = 1)
polygon(c(-5, u, 1), c(0, v, 0), col = "pink")
```

`pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 정규분포의 누적분포함수입니다. 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 정규분포의 누적분포함수 시각화
plot(x, pnorm(x, mean = 0, sd = 1), type = "l", col = "red")

# 표준정규분포에서 q가 0.5일때의 누적분포함수값은? 즉 확률은?
pnorm(0.5, mean = 0, sd = 1)

# 표준정규분포에서 가로축 1까지의 누적분포함수값(확률))은 0.84(84%)
pnorm(1, mean = 0, sd = 1)
```

`qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)` 함수는  정규분포의 분위수를 구하는 함수입니다. 평균 mean(기본값 0)과 표준편차 sd(기본값 1)의 정규분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
# 확률이 0.8413일때의 x값은 1의 근사값
qnorm(0.8413, mean = 0, sd = 1)
# 1일때의 확률은 0.8413
pnorm(1, mean = 0, sd = 1)
```


### 감마분포(gamma)

감마분포는 α번째 사건이 일어날 때 까지 걸리는 시간에 대한 연속확률분포입니다. 참고로 감마분포는 감마함수를 바탕으로 하고 있는데, 감마함수는 수학자 오일러가 제안한 함수입니다. 

감마분포와 관련된 함수는 다음 4가지 있습니다. 

* rgamma(n, shape, rate = 1, scale = 1/rate)
* dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)
* pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)
* qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)

`rgamma(n, shape, rate = 1, scale = 1/rate)` 함수는 주어진 형태 shape와 척도 scale(기본값 1/rate, rate의 기본값은 1)의 감마분포에서 n개의 난수를 생성하여 반환합니다. rgamma 함수명은 난수를 의미하는 r과 감마분포를 의미하는 gamma가 결합되어진 것입니다.

```{r}
# 형태가 1인 감마분포에서 난수 10개 생성
rgamma(n = 10, shape = 1)

# 평균이 50이고 표준편차기 3인 분포에서 난수 10개 생성
rgamma(10, shape = 1, rate = 0.001)
```

```{r}
x <- rgamma(n = 2000, shape = 1)
hist(x)  
```

`dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)` 함수는 감마분포의 확률밀도함수입니다. 형태 shape와 척도 scale의 감마분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-1, 5, by = 0.01)

# 확률밀도함수 시각화
plot(x, dgamma(x, shape = 1), type = "l", col = "red")

# x가 0.5일때의 함수값?
dgamma(0.5, shape = 1)
```

```{r}
x <- seq(0, 10, by = 0.01)

plot(x, dgamma(x, shape = 1, scale = 2), type = "l", col = "red")
lines(x, dgamma(x, shape = 2, scale = 2), type = "l", col = "green")
lines(x, dgamma(x, shape = 3, scale = 2), type = "l", col = "blue")
lines(x, dgamma(x, shape = 4, scale = 2), type = "l", col = "purple")
```

```{r}
x <- seq(0, 10, by = 0.01)

plot(x, dgamma(x, shape = 2, scale = 2), type = "l", col = "red")
lines(x, dgamma(x, shape = 2, scale = 3), type = "l", col = "green")
lines(x, dgamma(x, shape = 2, scale = 4), type = "l", col = "blue")
lines(x, dgamma(x, shape = 2, scale = 5), type = "l", col = "purple")
```

```{r}
# 0에서 1까지의 면적(핑크색)은?  pgamma(1, shape = 1)
x <- seq(0, 5, by = 0.01)
plot(x, dgamma(x, shape = 1), type = "l", lwd = 2, col = "red")

u <- seq(0, 1, by = 0.01)
v <- dgamma(u, shape = 1)
polygon(c(0, u, 1), c(0, v, 0), col = "pink")
```

`pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)` 함수는 감마분포의 누적분포함수입니다. 형태 shape와 척도 scale의 감마분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pgamma(x, shape = 1), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은? 
pgamma(0.5, shape = 1)

# 가로축 1까지의 누적분포함수값(확률))은?
pgamma(1, shape = 1)
```

`qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)` 함수는  감마분포의 분위수를 구하는 함수입니다. 형태 shape와 척도 scale의 감마분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
# 70% 분위수는?
qgamma(0.7, shape = 1)

# 주어진 값의 %는?
pgamma(1.2, shape = 1)
```


### 지수분포(exp)

지수분포는 감마분포의 특수한 경우라고 볼 수 있습니다. 감마분포가 α번째 사건이 일어날 때 까지 걸리는 시간에 대한 분포라면, 지수분포는 첫번째 사건이 발생할 때 까지 걸리는 시간에 대한 분포라고 할 수 있습니다. 두 분포함수의 인자를 기본값으로 하면 결과는 거의 동일하게 나옵니다.

참고로 지수분포와 포아송분포는 서로 반대되는 과점을 가지고 있습니다. 지수분포가 첫번째 사건이 발생할 때까지의 대기시간인 반면, 포아송분포는 단위 시간 당 발생하는 사건의 횟수입니다. 지수포는 대기시간, 포아송분포는 횟수입니다.

지수분포는 기하분포와도 관련이 있습니다. 지수분포는 사건이 발생할 때까지의 대기시간인 반면, 기하분포는 사건이 발생할 때까지의 시도횟수입니다.


지수분포와 관련된 함수는 다음 4가지 있습니다. 

* rexp(n, rate = 1)
* dexp(x, rate = 1, log = FALSE)
* pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE)
* qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE)

`rexp(n, rate = 1)` 함수는 주어진 감마값 rate(기본값 1)의 지수분포에서 n개의 난수를 생성하여 반환합니다. rexp 함수명은 난수를 의미하는 r과 지수분포를 의미하는 exp가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rexp(n = 10, rate = 1)
```

```{r}
set.seed(123)
x <- rexp(n = 2000, rate = 1)
hist(x)  
```

`dexp(x, rate = 1, log = FALSE)` 함수는 지수분포의 확률밀도함수입니다. 주어진 감마값 rate(기본값 1)의 지수분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 7, by = 0.01)

# 확률밀도함수 시각화
plot(x, dexp(x, rate = 1), type = "l", col = "red")

# x가 0.5일때의 함수값?
dexp(0.5, rate = 1)
```

```{r}
# 0에서 1까지의 면적(핑크색)은? pexp(1, rate = 1)
x <- seq(0, 5, by = 0.01)
plot(x, dexp(x, rate = 1), type = "l", lwd = 2, col = "red")

u <- seq(0, 1, by = 0.01)
v <- dexp(u, rate = 1)
polygon(c(0, u, 1), c(0, v, 0), col = "pink")
```

`pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 지수분포의 누적분포함수입니다. 주어진 rate(기본값 1)의 지수분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pexp(x, rate = 1), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은?
pexp(0.5, rate = 1)

# 0~1까지의 면적 비율
pexp(1, rate = 1)
```

`qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 지수분포의 분위수를 구하는 함수입니다. 주어진 rate의 지수분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qexp(0.7, rate = 1)

pexp(1.204, rate = 1)
```


### 베타분포(beta)

베타분포는 두 매개변수 α와 β에 따라 [0, 1] 구간에서 정의되는 분포입니다. 베타분포는 주로 베이지안 추정에서 많이 다루어지는 분포입니다. 모수가 α와 β 두 개이므로 다양한 형태의 분포가 만들어질 수 있습니다. 베타분포를 계산하는 데 사용되는 베타함수는 감마함수를 만든 오일러가 23세(1730년)에 만든 함수입니다. 

베타분포와 관련된 함수는 다음 4가지 있습니다. 

* rbeta(n, shape1, shape2, ncp = 0)
* dbeta(x, shape1, shape2, ncp = 0, log = FALSE)
* pbeta(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)
* qbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)

위 함수에서 인자 shape1과 shape2는 각각 베타분포의 매개변수 α와 β라 할 수 있습니다.

`rbeta(n, shape1, shape2, ncp = 0)` 함수는 매개변수 shape1과 shape2의 베타분포에서 n개의 난수를 생성하여 반환합니다. rbeta 함수명은 난수를 의미하는 r과 베타분포를 의미하는 beta가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rbeta(n = 10, shape1 = 1, shape2 = 1)
```

```{r}
set.seed(123)
x <- rbeta(n = 2000, shape1 = 1, shape2 = 2)
hist(x) 
```

`dbeta(x, shape1, shape2, ncp = 0, log = FALSE)` 함수는 베타분포의 확률밀도함수입니다. 매개변수 shape1과 shape2의 베타분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 1, by = 0.01)

# 확률밀도함수 시각화
plot(x, dbeta(x, shape1 = 2, shape2 = 5), type = "l", col = "red")

# x가 0.5일때의 함수값?
dbeta(0.5, shape1 = 2, shape2 = 5)
```

매개변수 shape1과 shape2의 값에 따라 다양한 형태의 분포가 나옵니다.

```{r}
x <- seq(0, 1, by = 0.01)

plot(x, dbeta(x, shape1 = 1, shape2 = 2), type = "l", col = "red")
lines(x, dbeta(x, shape1 = 2, shape2 = 2), type = "l", col = "green")
lines(x, dbeta(x, shape1 = 3, shape2 = 2), type = "l", col = "blue")
lines(x, dbeta(x, shape1 = 4, shape2 = 2), type = "l", col = "purple")
```

```{r}
x <- seq(0, 1, by = 0.01)

plot(x, dbeta(x, shape1 = 2, shape2 = 1), type = "l", col = "red")
lines(x, dbeta(x, shape1 = 2, shape2 = 2), type = "l", col = "green")
lines(x, dbeta(x, shape1 = 2, shape2 = 3), type = "l", col = "blue")
lines(x, dbeta(x, shape1 = 2, shape2 = 4), type = "l", col = "purple")
```

```{r}
# 0에서 0.5까지의 면적(핑크색)은? pbeta(0.5, shape1 = 2, shape2 = 3)
x <- seq(0, 1, by = 0.01)
plot(x, dbeta(x, shape1 = 2, shape2 = 3), type = "l", lwd = 2, col = "red")

u <- seq(0, 0.5, by = 0.01)
v <- dbeta(u, shape1 = 2, shape2 = 3)
polygon(c(0, u, 0.5), c(0, v, 0), col = "pink")
```

`pbeta(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 베타분포의 누적분포함수입니다. 매개변수 shape1과 shape2의 베타분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 1, by = 0.01)

# 누적분포함수 시각화
plot(x, pbeta(x, shape1 = 2, shape2 = 3), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은?
pbeta(0.5, shape1 = 2, shape2 = 3)
```

`qbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 베타분포의 분위수를 구하는 함수입니다. 매개변수 shape1과 shape2의 베타분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qbeta(0.7, shape1 = 2, shape2 = 3)
pbeta(0.5084, shape1 = 2, shape2 = 3)
```


### t분포(t)

t분포는 '스튜던트 t분포(Student's t-distribution)'를 간단하게 부르는 말입니다. t분포는 프리드리히 로베르트 헬메르트(1875)와 야코프 뤼로트(1876)가 발견하였는데 학계에 널리 알려지지 않다가, 1908년에 기네스 양조 공장에서 일하는 윌리엄 고셋이 '스튜던트'라는 필명으로 맥주에 사용되는 보리의 질을 시험하기 위해 이 분포를 도입하였습니다. 저명한 통계학자인 로널드 피셔가 이 분포를 '스튜던트 t분포'로 소개하면서 널리 알려지게 되었습니다.

t 분포는 종모양으로서 좌우대칭을 이룹니다. 정규분포와 비슷한 모양이지만 정규분포보다는 옆으로 넓게 더 퍼진 모양이라고 볼 수 있습니다. t 분포의 모양을 결정하는 것은 자유도이며, 자유도가 커질수록 표준정규분포에 가깝게 됩니다. 통계학자들은 보통 표본수가 30이상이면 정규분포에 가깝다고 합니다. 이를 뒤집어 해석하면 표본의 크기가 30보다 작으면 t분포를 사용할 필요가 있다고 볼 수 있습니다. 또한 t분포는 정규분포의 평균을 측정할 때 주로 사용되는 확률분포입니다. 통계학에서 가설검정과 회귀분석에 많이 사용됩니다.

t분포와 관련된 함수는 4가지가 있습니다.

* rt(n, df, ncp)
* dt(x, df, ncp, log = FALSE)
* pt(q, df, ncp, lower.tail = TRUE, log.p = FALSE)
* qt(p, df, ncp, lower.tail = TRUE, log.p = FALSE)


위 함수에서 인자 df는 자유도를 의미합니다. t분포에서 자유도는 표본의 갯수인 n에서 1을 뺀 값입니다. ncp는 비중심모수(non-centrally parameter)입니다.

`rt(n, df, ncp)` 함수는 자유도 df의 t분포에서 n개의 난수를 생성하여 반환합니다. rt 함수명은 난수를 의미하는 r과 t분포를 의미하는 t가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rt(n = 10, df = 3)
```

```{r}
set.seed(123)
x <- rt(n = 2000, df = 3)
hist(x) 
```

`dt(x, df, ncp, log = FALSE)` 함수는 t분포의 확률밀도함수입니다. 자유도 df의 t분포에서에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 확률밀도함수 시각화
plot(x, dt(x, df = 2), type = "l", col = "red")

# x가 0.5일때의 함수값?
dt(0.5, df = 2)
```

자유도 df의 값에 따라 다양한 형태의 분포가 나옵니다. df가 커질수록 정규분포에 가까워집니다. 검은색 선은 표준정규분포선입니다. 자유도가 30에 가까워질수록 t분포는 정규분포에 가까워지는 것을 볼 수 있습니다.

```{r}
x <- seq(-5, 5, by = 0.01)

plot(x, dt(x, df = 28), type = "l", col = "red")
lines(x, dt(x, df = 10), type = "l", col = "green")
lines(x, dt(x, df = 5), type = "l", col = "blue")
lines(x, dt(x, df = 2), type = "l", col = "purple")
lines(x, dnorm(x), type = "l", lwd =2, col = "black")
```

```{r}
x <- seq(-5, 8, by = 0.01)

plot(x, dt(x, df = 15), type = "l", col = "red")
lines(x, dt(x, df = 15, ncp = 1), type = "l", col = "green")
lines(x, dt(x, df = 15, ncp = 2), type = "l", col = "blue")
lines(x, dt(x, df = 15, ncp = 3), type = "l", col = "purple")
```

```{r}
# 0.5이하의 면적(핑크색)은? pt(0.5, df = 10)
x <- seq(-5, 5, by = 0.01)
plot(x, dt(x, df = 10), type = "l", lwd = 2, col = "red")

u <- seq(-5, 0.5, by = 0.01)
v <- dt(u, df = 10)
polygon(c(-5, u, 0.5), c(0, v, 0), col = "pink")
```

`pt(q, df, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 t분포의 누적분포함수입니다. 자유도 df의 t분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-5, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pt(x, df = 10), type = "l", col = "red")

# q가 0.5일때의 누적분포함수값은? 즉 확률은?
pt(0.5, df = 10)
```

`qt(p, df, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 t분포의 분위수를 구하는 함수입니다. 자유도 df의 t분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qt(0.7, df = 10)
pt(0.5415, df = 10)
```


### 카이제곱분포(chisq)

카이제곱분포($χ^2$분포)는 k개의 서로 독립적인 표준정규분포의 확률변수를 각각 제곱한 다음 합해서 얻어지는 분포입니다. 이때 k는 자유도(df)로서 카이제곱분포의 매개변수가 됩니다. 카이제곱분포는 감마분포의 특수한 형태라고 할 수 있습니다.

카이제곱분포는 오른쪽으로 긴 꼬리를 가진 비대칭 분포모양을 가지고 있습니다. 카이제곱분포의 모양을 결정하는 것은 자유도이며, 자유도가 커질수록 정규분포에 가깝게 됩니다. 카이제곱분포는 모분산에 대한 추정과 검정에 사용되며, 범주형 자료의 적합도 검정, 동질성 검정, 독립성 검정 등에 사용됩니다.

카이제곱분포와 관련된 함수는 4가지가 있습니다.

* rchisq(n, df, ncp = 0)
* dchisq(x, df, ncp = 0, log = FALSE)
* pchisq(q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)
* qchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)

위 함수에서 인자 df는 자유도를 의미합니다. 

`rchisq(n, df, ncp = 0)` 함수는 자유도 df의 카이제곱분포에서 n개의 난수를 생성하여 반환합니다. rchisq 함수명은 난수를 의미하는 r과 카이제곱분포를 의미하는 chisq가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rchisq(n = 10, df = 3)
```

```{r}
set.seed(123)
x <- rchisq(n = 5000, df = 5)
hist(x, breaks = 100, main = "") 
```

`dchisq(x, df, ncp = 0, log = FALSE)` 함수는 카이제곱분포의 확률밀도함수입니다. 자유도 df의 카이제곱분포에서에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10, by = 0.01)

# 확률밀도함수 시각화
plot(x, dchisq(x, df = 2), type = "l", col = "red")

# x가 0.5일때의 함수값?
dchisq(0.5, df = 2)
```

자유도 df의 값에 따라 다양한 형태의 분포가 나옵니다. df가 커질수록 정규분포에 가까워집니다.

```{r}
x <- seq(0, 15, by = 0.01)

plot(x, dchisq(x, df = 2), type = "l", col = "red")
lines(x, dchisq(x, df = 4), type = "l", col = "green")
lines(x, dchisq(x, df = 6), type = "l", col = "blue")
lines(x, dchisq(x, df = 8), type = "l", col = "purple")
```

```{r}
x <- seq(0, 15, by = 0.01)

plot(x, dchisq(x, df = 5), type = "l", col = "red")
lines(x, dchisq(x, df = 5, ncp = 1), type = "l", col = "green")
lines(x, dchisq(x, df = 5, ncp = 2), type = "l", col = "blue")
lines(x, dchisq(x, df = 5, ncp = 3), type = "l", col = "purple")
```

```{r}
# 0에서 5까지의 면적(핑크색)은? pchisq(5, df = 3)
x <- seq(0, 15, by = 0.01)
plot(x, dchisq(x, df = 3), type = "l", lwd = 2, col = "red")

u <- seq(0, 5, by = 0.01)
v <- dchisq(u, df = 3)
polygon(c(0, u, 5), c(0, v, 0), col = "pink")
```

`pchisq(q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 카이제곱분포의 누적분포함수입니다. 자유도 df의 카이제곱분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 15, by = 0.01)

# 누적분포함수 시각화
plot(x, pchisq(x, df = 3), type = "l", col = "red")

# q가 5일때의 누적분포함수값은? 즉 확률은?
pchisq(5, df = 3)
```

`qchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)` 함수는 카이제곱분포의 분위수를 구하는 함수입니다. 자유도 df의 카이제곱분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qchisq(0.7, df = 3)
pchisq(3.6648, df = 3)
```


### F분포(f)

F분포는 두개의 독립적인 카이제곱분포의 확률변수의 비(ratio)로 얻어지는 연속확률분포입니다. 

F분포는 카이제곱분포처럼 오른쪽으로 긴 꼬리를 가진 비대칭 분포모양을 가지고 있습니다. F분포의 모양을 결정하는 것은 분자와 분모의 자유도이며, 두 자유도가 커질수록 정규분포에 가깝게 됩니다. F분포는 분산의 비교, 분산분석, 회귀분석 등에 많이 사용됩니다.

F분포와 관련된 함수는 4가지가 있습니다.

* rf(n, df1, df2, ncp)
* df(x, df1, df2, ncp, log = FALSE)
* pf(q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)
* qf(p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)


위 함수에서 인자 df1과 df2는 자유도를 의미합니다. 

`rf(n, df1, df2, ncp)` 함수는 자유도 df1과 df2의 F분포에서 n개의 난수를 생성하여 반환합니다. rf 함수명은 난수를 의미하는 r과 F분포를 의미하는 f가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rf(n = 10, df1 = 2, df2 = 2)
```

```{r}
set.seed(123)
x <- rf(n = 5000, df1 = 5, df2 = 8)
hist(x, breaks = 100,  main = "") 
```

`df(x, df1, df2, ncp, log = FALSE)` 함수는 F분포의 확률밀도함수입니다. 자유도 df1과 df2의 F분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10, by = 0.01)

# 확률밀도함수 시각화
plot(x, df(x, df1 = 5, df2 = 2), type = "l", col = "red")

# x가 0.5일때의 함수값?
df(0.5, df1 = 5, df2 = 2)
```

자유도 df1과 df2의 값에 따라 다양한 형태의 분포가 나옵니다. df1과 df2가 커질수록 정규분포에 가까워집니다.

```{r}
x <- seq(0, 5, by = 0.01)

plot(x, df(x, df1 = 2, df2 = 1), type = "l", col = "red")
lines(x, df(x, df1 = 5, df2 = 1), type = "l", col = "green")
lines(x, df(x, df1 = 10, df2 = 1), type = "l", col = "blue")
lines(x, df(x, df1 = 20, df2 = 20), type = "l", col = "purple")
```

```{r}
x <- seq(0, 5, by = 0.01)

plot(x,  df(x, df1 = 20, df2 = 20), type = "l", col = "red")
lines(x, df(x, df1 = 3, df2 = 5), type = "l", col = "green")
lines(x, df(x, df1 = 3, df2 = 10), type = "l", col = "blue")
lines(x, df(x, df1 = 3, df2 = 15), type = "l", col = "purple")
```

```{r}
# 0에서 2까지의 면적(핑크색)은? pf(2, df1 = 3, df2 =3)
x <- seq(0, 5, by = 0.01)
plot(x, df(x, df1 = 3, df2 = 3), type = "l", lwd = 2, col = "red")

u <- seq(0, 2, by = 0.01)
v <- df(u, df1 = 3, df2 = 3)
polygon(c(0, u, 2), c(0, v, 0), col = "pink")
```

`pf(q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 F분포의 누적분포함수입니다. 자유도 df1과 df2의 F분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pf(x, df1 = 3, df2 = 3), type = "l", col = "red")

# q가 2일때의 누적분포함수값은? 즉 확률은?
pf(2, df1 = 3, df2 =3)
```

`qf(p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)` 함수는 F분포의 분위수를 구하는 함수입니다. 자유도 df1과 df2의 F분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qf(0.7, df1 = 3, df2 = 3)
pf(1.9398, df1 = 3, df2 =3)
```


### 와이블분포(weibull)

Weibull분포는 국내 번역용어로는 와이블분포, 베이블분포 등이 있습니다. Weibull분포는 지수분포를 보다 일반화시켜 여러 다양한 확률분포 형태를 나타낼 수 있도록 고안된 확률분포입니다. 스웨덴의 물리학자 와이블(W. Weibull)이 1939년 재료의 파괴강도에 대한 분포를 표시하기 위해 이 분포를 발표하였습니다. 주로 산업현장에서 부품의 수명을 추정하는 데 많이 사용되는 분포입니다. 또한 날씨예보, 신뢰성 공학에서의 실패분석 등에 사용되기도 합니다.

Weibull분포의 모양을 결정하는 것은 형상 모수(shape parameter)와 척도 모수(scale parameter)입니다. 형상모수의 값이 낮으면 오른쪽으로 치우친 곡선을, 높으면 왼쪽으로 치우친 곡선을 나타내며, 값이 3이면 정규분포에 가까운 곡선을 나타냅니다. 척도모수의 값이 크면 분포가 좁아지고, 반대로 값이 크면 분포가 넓어집니다.

Weibull분포와 관련된 함수는 4가지가 있습니다.

* rweibull(n, shape, scale = 1)
* dweibull(x, shape, scale = 1, log = FALSE)
* pweibull(q, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)
* qweibull(p, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)

위 함수에서 인자 shape는 형상모수, scale은 척도모수를 의미합니다. 

`rweibull(n, shape, scale = 1)` 함수는 형상모수 shape와 척도모수 scale의 Weibull분포에서 n개의 난수를 생성하여 반환합니다. rweibull 함수명은 난수를 의미하는 r과 Weibull분포를 의미하는 weibull이 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rweibull(n = 10, shape = 2, scale = 2)
```

```{r}
set.seed(123)
x <- rweibull(n = 5000, shape = 2, scale = 2)
hist(x, breaks = 100,  main = "") 
```

`dweibull(x, shape, scale = 1, log = FALSE)` 함수는 Weibull분포의 확률밀도함수입니다. 형상모수 shape와 척도모수 scale의 Weibull분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 7, by = 0.01)

# 확률밀도함수 시각화
plot(x, dweibull(x, shape = 2, scale = 2), type = "l", col = "red")

# x가 0.5일때의 함수값?
dweibull(0.5, shape = 2, scale = 2)
```

형상모수 shape와 척도모수 scale의 값에 따라 다양한 형태의 분포가 나옵니다. 
형상모수의 값이 낮으면 오른쪽으로 치우친 곡선을, 높으면 왼쪽으로 치우친 곡선을 나타내며, 값이 3이면 정규분포에 가까운 곡선을 나타냅니다. 척도모수의 값이 크면 분포가 좁아지고, 반대로 값이 크면 분포가 넓어집니다.

```{r}
x <- seq(0, 5, by = 0.01)

plot(x,  dweibull(x, shape = 5, scale = 2), type = "l", col = "red")
lines(x, dweibull(x, shape = 3, scale = 2), type = "l", col = "green")
lines(x, dweibull(x, shape = 2, scale = 2), type = "l", col = "blue")
lines(x, dweibull(x, shape = 1, scale = 2), type = "l", col = "purple")
```

```{r}
x <- seq(0, 5, by = 0.01)

plot(x,  dweibull(x, shape = 3, scale = 1), type = "l", col = "red")
lines(x, dweibull(x, shape = 3, scale = 2), type = "l", col = "green")
lines(x, dweibull(x, shape = 3, scale = 3), type = "l", col = "blue")
lines(x, dweibull(x, shape = 3, scale = 4), type = "l", col = "purple")
```

```{r}
# 0에서 2까지의 면적(핑크색)은? pweibull(2, shape = 2, scale = 2)
x <- seq(0, 5, by = 0.01)
plot(x, dweibull(x, shape = 2, scale = 2), type = "l", lwd = 2, col = "red")

u <- seq(0, 2, by = 0.01)
v <- dweibull(u, shape = 2, scale = 2)
polygon(c(0, u, 2), c(0, v, 0), col = "pink")
```

`pweibull(q, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 Weibull분포의 누적분포함수입니다. 형상모수 shape와 척도모수 scale의 Weibull분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, pweibull(x, shape = 2, scale = 2), type = "l", col = "red")

# q가 2일때의 누적분포함수값은? 즉 확률은?
pweibull(2, shape = 2, scale = 2)
```

`qweibull(p, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 Weibull분포의 분위수를 구하는 함수입니다. 형상모수 shape와 척도모수 scale의 Weibull분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qweibull(0.7, shape = 2, scale = 2)
pweibull(2.1945, shape = 2, scale = 2)
```


### 로그정규분포(lnorm)

로그정규뷴포는 확률변수에 로그를 취하게 되면 그 값이 정규분포를 따르는 확률분포입니다. 모양은 Weibull분포와 유사하게 왼쪽이 볼록한 형태입니다. 우리나라의 소득분포는 로그정규분포에 가깝습니다. 즉 왼쪽 소득이 낮은 층의 비율이 높다고 볼 수 있습니다. 로그 정규 분포는 신뢰도 분석, 주식 변동의 모형화 등에 사용됩니다.
로그정규분포의 모양을 결정하는 것은 평균과 표준편차입니다. 

로그정규분포와 관련된 함수는 4가지가 있습니다.

* rlnorm(n, meanlog = 0, sdlog = 1)
* dlnorm(x, meanlog = 0, sdlog = 1, log = FALSE)
* plnorm(q, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)
* qlnorm(p, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)


위 함수에서 인자 meanlog는 평균, sdlog는 표준편차를 의미합니다. 

`rlnorm(n, meanlog = 0, sdlog = 1)` 함수는 주어진 평균 meanlog(기본값 0)과 표준편차 sdlog(기본값 1)의 로그정규분포에서 n개의 난수를 생성하여 반환합니다. rlnorm 함수명은 난수를 의미하는 r과 로그정규분포를 의미하는 lnorm이 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rlnorm(n = 10, meanlog = 0, sdlog = 1)
```

```{r}
set.seed(123)
x <- rlnorm(n = 5000, meanlog = 0, sdlog = 1)
hist(x, breaks = 100,  main = "") 
```

`dlnorm(x, meanlog = 0, sdlog = 1, log = FALSE)` 함수는 로그정규분포의 확률밀도함수입니다. 평균 meanlog(기본값 0)과 표준편차 sdlog(기본값 1)의 로그정규분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10, by = 0.01)

# 확률밀도함수 시각화
plot(x, dlnorm(x, meanlog = 0, sdlog = 1), type = "l", col = "red")

# x가 0.5일때의 함수값?
dlnorm(0.5, meanlog = 0, sdlog = 1)
```

```{r}
x <- seq(0, 5, by = 0.01)

plot(x,  dlnorm(x, meanlog = 0, sdlog = 1), type = "l", col = "red")
lines(x, dlnorm(x, meanlog = 0.3, sdlog = 1), type = "l", col = "green")
lines(x, dlnorm(x, meanlog = 0.6, sdlog = 1), type = "l", col = "blue")
lines(x, dlnorm(x, meanlog = 1, sdlog = 1), type = "l", col = "purple")
```

```{r}
x <- seq(0, 5, by = 0.01)

plot(x,  dlnorm(x, meanlog = 0, sdlog = 2), type = "l", col = "red")
lines(x, dlnorm(x, meanlog = 0, sdlog = 1.7), type = "l", col = "green")
lines(x, dlnorm(x, meanlog = 0, sdlog = 1.4), type = "l", col = "blue")
lines(x, dlnorm(x, meanlog = 0, sdlog = 1), type = "l", col = "purple")
```

```{r}
# 0에서 2까지의 면적(핑크색)은? plnorm(2, meanlog = 0, sdlog = 1)
x <- seq(0, 5, by = 0.01)
plot(x, dlnorm(x, meanlog = 0, sdlog = 1), type = "l", lwd = 2, col = "red")

u <- seq(0, 2, by = 0.01)
v <- dlnorm(u, meanlog = 0, sdlog = 1)
polygon(c(0, u, 2), c(0, v, 0), col = "pink")
```

`plnorm(q, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 로그정규분포의 누적분포함수입니다. 평균 meanlog(기본값 0)과 표준편차 sdlog(기본값 1)의 로그정규분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 5, by = 0.01)

# 누적분포함수 시각화
plot(x, plnorm(x, meanlog = 0, sdlog = 1), type = "l", col = "red")

# q가 2일때의 누적분포함수값은? 즉 확률은?
plnorm(2, meanlog = 0, sdlog = 1)
```

`qlnorm(p, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 로그정규분포의 분위수를 구하는 함수입니다. 평균 meanlog(기본값 0)과 표준편차 sdlog(기본값 1)의 로그정규분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qlnorm(0.7, meanlog = 0, sdlog = 1)
plnorm(1.6894, meanlog = 0, sdlog = 1)
```


### 코시분포(cauchy)

코시분포는 기대값과 분산이 모두 정의되지 않은 연속확률분포입니다. 로렌즈(Lorentz) 분포로 불리우기도 합니다. 코시분포는 정규분포와 유사하게 종 모양입니다. 그러나 코시분포는 정규분포보다 꼬리가 0에 더 느리게 접근합니다. 코시분포의 이름은 프랑스 수학자 Augustin Cauchy에게서 유래합니다.

코시분포의 모양은 위치(location)와 척도(scale)라는 두 모수에 의해 결정이 됩니다. 
코시분포와 관련된 함수는 4가지가 있습니다.

* rcauchy(n, location = 0, scale = 1)
* dcauchy(x, location = 0, scale = 1, log = FALSE)
* pcauchy(q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)
* qcauchy(p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* location : 위치
* scale : 척도
* n : 난수를 발생할 개수
* x, q : 확률밀도함수나 누적분포함수를 계산할 값(벡터)
* p : 분위수를 계산할 확률값

`rcauchy(n, location = 0, scale = 1)` 함수는 위치 location과 척도 scale로 구성된 코시분포에서 n개의 난수를 생성하여 반환합니다. rcauchy 함수명은 난수를 의미하는 r과 코시분포를 의미하는 cauchy가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rcauchy(10, location = 0, scale = 1)
```

```{r}
set.seed(123)
x <- rcauchy(n = 5000, location = 0, scale = 1)
hist(x, main = "") 
```

`dcauchy(x, location = 0, scale = 1, log = FALSE)` 함수는 코시분포의 확률밀도함수입니다. 위치 location과 척도 scale로 구성된 코시분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(-10, 10)

# 확률밀도함수 시각화
plot(x, dcauchy(x, location = 0, scale = 1), type = "l", col = "red")

# x가 2일때의 함수값?
dcauchy(2, location = 0, scale = 1)
```

```{r}
x <- seq(-10, 10)

plot(x,  dcauchy(x, location = 0, scale = 0.5), type = "l", col = "red")
lines(x, dcauchy(x, location = 0, scale = 1), type = "l", col = "green")
lines(x, dcauchy(x, location = 0, scale = 1.5), type = "l", col = "blue")
lines(x, dcauchy(x, location = 0, scale = 2), type = "l", col = "purple")
```

```{r}
x <- seq(-10, 10)

plot(x,  dcauchy(x, location = -2, scale = 1), type = "l", col = "red")
lines(x, dcauchy(x, location = 0, scale = 1), type = "l", col = "green")
lines(x, dcauchy(x, location = 2, scale = 1), type = "l", col = "blue")
lines(x, dcauchy(x, location = 4, scale = 1), type = "l", col = "purple")
```

```{r}
# 0에서 3까지의 면적(핑크색)은? pcauchy(3, location = 0, scale = 1)
x <- seq(-10, 10)
plot(x, dcauchy(x, location = 0, scale = 1), type = "l", lwd = 2, col = "red")

u <- seq(-10, 3)
v <- dcauchy(u, location = 0, scale = 1)
polygon(c(-10, u, 3), c(0, v, 0), col = "pink")
```

`pcauchy(q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 코시분포의 누적분포함수입니다. 위치 location과 척도 scale로 구성된 코시분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-10, 10)

# 누적분포함수 시각화
plot(x, pcauchy(x, location = 0, scale = 1), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
pcauchy(3, location = 0, scale = 1)
```

`qcauchy(p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 코시분포의 분위수를 구하는 함수입니다. 위치 location과 척도 scale로 구성된 코시분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qcauchy(0.8, location = 0, scale = 1)  # p가 0.2~0.5까지는 2가 반환됨
pcauchy(1.37, location = 0, scale = 1)
```


### 이항분포(binom)

> 이산확률분포에는 이항분포, 베르누이분포, 다항분포, 초기하분포, 기하분포,  음이항분포, 포아송분포 등이 있습니다. 

이항분포는 시행결과가 오직 2개인 베르누이 시행을 여러번 반복하였을 때 나타나는 확률분포입니다. 시행결과가 오직 2개인 경우의 예로는 성공과 실패, 0과 1, 앞면과 뒷면 등을 들 수 있습니다. 만일 여기서 시행횟수가 1번이면 베르누이분포가 됩니다. 베르누이분포는 뒤에서 다루겠습니다. 이항분포의 모양을 결정하는 것은 시행횟수와 성공확률입니다. 

이항분포와 관련된 함수는 4가지가 있습니다.

* rbinom(n, size, prob)
* dbinom(x, size, prob, log = FALSE)
* pbinom(q, size, prob, lower.tail = TRUE, log.p = FALSE)
* qbinom(p, size, prob, lower.tail = TRUE, log.p = FALSE)

위 함수에서 인자 size는 시행횟수, prob는 각 시행에서의 성공확률을 의미합니다. 

`rbinom(n, size, prob)` 함수는 시행횟수 size와 성공확률 prob의 이항분포에서 n개의 난수를 생성하여 반환합니다. rbinom 함수명은 난수를 의미하는 r과 이항분포를 의미하는 binom이 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rbinom(n = 10, size = 5, prob = 0.5)
```

```{r}
set.seed(123)
x <- rbinom(n = 5000, size = 10, prob = 0.5)
hist(x, main = "") 
```

`dbinom(x, size, prob, log = FALSE)` 함수는 이항분포의 확률밀도함수입니다. 시행횟수 size와 성공확률 prob의 이항분포에서 인자 x의 함수값을 구해 반환합니다. 

> 통계학자에 따라 이산확률분포의 확률밀도함수(pdf: probability density function)를 확률질량함수(pmf: probability mass function)로 표현하거나 이산형 확률밀도함수로 표현합니다. 여기서는 R Help에 따라 확률밀도함수로 표현하겠습니다.

```{r}
x <- seq(0, 30, by = 1)

# 확률밀도함수 시각화
plot(x, dbinom(x, size = 30, prob = 0.5), type = "l", col = "red")

# x가 10일때의 함수값?
dbinom(10, size = 30, prob = 0.5)
```

```{r}
x <- seq(0, 30)

plot(x,  dbinom(x, size = 30, prob = 0.2), type = "l", col = "red")
lines(x, dbinom(x, size = 30, prob = 0.3), type = "l", col = "green")
lines(x, dbinom(x, size = 30, prob = 0.6), type = "l", col = "blue")
lines(x, dbinom(x, size = 30, prob = 0.8), type = "l", col = "purple")
```

```{r}
x <- seq(0, 30)

plot(x,  dbinom(x, size = 10, prob = 0.5), type = "l", col = "red")
lines(x, dbinom(x, size = 20, prob = 0.5), type = "l", col = "green")
lines(x, dbinom(x, size = 30, prob = 0.5), type = "l", col = "blue")
lines(x, dbinom(x, size = 40, prob = 0.5), type = "l", col = "purple")
```

```{r}
# 0에서 20까지의 면적(핑크색)은? pbinom(20, size = 30, prob = 0.5)
x <- seq(0, 30)
plot(x, dbinom(x, size = 30, prob = 0.5), type = "l", lwd = 2, col = "red")

u <- seq(0, 20)
v <- dbinom(u, size = 30, prob = 0.5)
polygon(c(0, u, 20), c(0, v, 0), col = "pink")
```

`plnorm(q, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 이항분포의 누적분포함수입니다. 시행횟수 size와 성공확률 prob의 이항분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 30)

# 누적분포함수 시각화
plot(x, pbinom(x, size = 30, prob = 0.5), type = "l", col = "red")

# q가 2일때의 누적분포함수값은? 즉 확률은?
pbinom(20, size = 30, prob = 0.5)
```

`qlnorm(p, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 이항분포의 분위수를 구하는 함수입니다. 시행횟수 size와 성공확률 prob의 이항분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qbinom(0.7, size = 30, prob = 0.5)
pbinom(16, size = 30, prob = 0.5)
```


### 베르누이분포

베르누이분포는 시행의 결과가 오직 두 가지인 경우에 1회 시행하여 일어난 확률분포입니다. 이항분포의 특수한 사례라고 할 수 있습니다. 시행결과가 오직 2개(베르누이 시행)인 경우의 예로는 성공과 실패, 0과 1, 앞면과 뒷면 등을 들 수 있습니다. 베르누이분포는 스위스의 수학자 야코프 베르누이(Jakob Bernoulli)의 이름에서 그 명칭을 따왔습니다.

R에서 베르누이분포를 위한 별도의 함수는 없고 이항분포함수에서 시행횟수를 지정하는 인자 size를 1로 설정합니다. 그 이유는 베르누이분포는 시행 횟수가 1인 이항분포이기 때문입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rbinom(n = 10, size = 1, prob = 0.5)

# sample 함수를 이용한 베르누이 시행
sample(c(0, 1), size = 10, replace = TRUE)
```

```{r}
set.seed(123)
x <- rbinom(n = 5000, size = 1, prob = 0.5)
hist(x, main = "") 
```


```{r}
x <- seq(0, 1)

# 확률밀도함수 시각화
plot(x, dbinom(x, size = 1, prob = 0.5), type = "l", col = "red")

# x가 1일때의 함수값?
dbinom(1, size = 1, prob = 0.5)
```

### 다항분포(multinom)

다항분포는 시행결과가 여러 개의 값을 가질 때 나타나는 확률분포입니다. 다항분포 중에서 시행 결과가 오직 2개인 경우가 이항분포가 됩니다. 보통은 시행결과가 3개 이상일 때 다항분포를 적용합니다. 

다항분포와 관련된 함수는 2가지가 있습니다.

* rmultinom(n, size, prob)
* dmultinom(x, size = NULL, prob, log = FALSE)

위 함수에서 인자 size는 시행횟수, prob는 각 시행에서의 성공확률을 의미합니다. 

`rmultinom(n, size, prob)` 함수는 시행횟수 size와 성공확률 prob의 다항분포에서 n개의 난수를 생성하여 반환합니다. 이때 성공확률 prob는 3개 이상으로 구성된 벡터이고, 이 성공확률들의 합은 내부적으로 1이 되도록 표준화됩니다. rmultinom 함수명은 난수를 의미하는 r과 다항분포를 의미하는 multinom이 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rmultinom(n = 10, size = 10, prob = c(0.2, 0.3, 0.5))

rmultinom(n = 10, size = 20, prob = c(1, 3, 6, 10))
table(rmultinom(n = 10, size = 20, prob = c(1, 3, 6, 10)))
```

```{r}
set.seed(123)
x <- rmultinom(n = 5000, size = 10, prob = c(0.2, 0.5, 0.3))
# 각 항목별 시행결과 평균 그래프
barplot(colMeans(t(x)), names.arg = c("0.2", "0.5", "0.3"))
# 각 항목별 시행결과 합계 그래프
barplot(colSums(t(x)), names.arg = c("0.2", "0.5", "0.3"))
# 전체 시행결과의 히스토그램
barplot(table(x))
```

`dmultinom(x, size = NULL, prob, log = FALSE)` 함수는 다항분포의 확률밀도함수입니다. 성공확률 prob의 다항분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
# 어느 지역 국회의원 선거 여론조사에서 유권자 40%는 A후보, 10%는 B후보를
# 선호하였고, 50%는 무응답이었습니다. 만일 10명의 유권자를 무작위로 추출하였을 때
# 이들 중 3명은 A후보, 2명은 B후보, 5명은 무응답을 할 확률은?
dmultinom(c(3, 2, 5), size = 10, prob = c(0.4, 0.1, 0.5))
```


### 초기하분포(hyper)

초기하분포는 N개가 들어있는 모집단에서 k개의 표본을 비복원으로 추출할 때 원하는 것이 추출될 확률의 분포입니다. 이항분포에서는 복원추출을 하였지만, 이를 비복원으로 추출하면 초기하분포가 됩니다. 예를 들면 흰색공 5개, 검정색공 5개가 있는 모집단에서 5개의 공을 표본으로 추출할 경우 처음에는 흰색공이 나오고 두번째에 흰색공이 나올 확률은 복원이냐 비복원이냐에 따라 다릅니다. 복원추출은 확률이 5/10(0.5)로 유지되지만, 비복원추출은 4/9로 줄어들게 됩니다.

만일 모집단이 매우 크다면 분모가 매우 커지기 때문에 초기하분포는 이항분포와 유사해집니다. 따라서 모집단이 작을 경우 복원추출은 이항분포, 비복원추출은 초기하분포를 사용하고 모집단이 매우 크면 어느 것을 사용해도 유사한 결과가 나올 것으로 보입니다.

초기하분포와 관련된 함수는 4가지가 있습니다.

* rhyper(nn, m, n, k)
* dhyper(x, m, n, k, log = FALSE)
* phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE)
* qhyper(p, m, n, k, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* m : 주머니 속의 흰색공의 개수
* n : 주머니 속의 검은색공의 개수
* k : 주머니 속에서 비복원으로 추출하는 공의 개수
* nn : 난수를 발생할 개수
* x, q : 확률밀도함수나 누적분포함수를 계산할 값(벡터)
* p : 분위수를 계산할 확률값

`rhyper(nn, m, n, k)` 함수는 m과 n의 개체로 구성되어 있는 모집단에서 k개의 표본을 추출하는 초기하분포에서 nn개의 난수를 생성하여 반환합니다. rhyper 함수명은 난수를 의미하는 r과 초기하분포를 의미하는 hyper가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rhyper(nn = 10, m = 10, n = 20, k = 5)
```

```{r}
set.seed(123)
x <- rhyper(nn = 5000, m = 10, n = 20, k = 5)
hist(x, main = "") 
```

`dhyper(x, m, n, k, log = FALSE)` 함수는 초기하분포의 확률밀도함수입니다. m과 n의 개체로 구성되어 있는 모집단에서 k개의 표본을 추출하는 초기하분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10)

# 확률밀도함수 시각화
plot(x, dhyper(x, m = 10, n = 20, k = 5), type = "l", col = "red")

# x가 2일때의 함수값?
dhyper(2, m = 10, n = 20, k = 5)
```

```{r}
x <- seq(0, 10)

plot(x,  dhyper(x, m = 10, n = 20, k = 5), type = "l", col = "red")
lines(x, dhyper(x, m = 20, n = 20, k = 5), type = "l", col = "green")
lines(x, dhyper(x, m = 30, n = 20, k = 5), type = "l", col = "blue")
lines(x, dhyper(x, m = 50, n = 20, k = 5), type = "l", col = "purple")
```

```{r}
x <- seq(0, 10)

plot(x,  dhyper(x, m = 10, n = 30, k = 5), type = "l", col = "red")
lines(x, dhyper(x, m = 10, n = 20, k = 5), type = "l", col = "green")
lines(x, dhyper(x, m = 10, n = 10, k = 5), type = "l", col = "blue")
lines(x, dhyper(x, m = 10, n = 5, k = 5), type = "l", col = "purple")
```

```{r}
x <- seq(0, 10)

plot(x,  dhyper(x, m = 10, n = 20, k = 2), type = "l", col = "red")
lines(x, dhyper(x, m = 10, n = 20, k = 5), type = "l", col = "green")
lines(x, dhyper(x, m = 10, n = 20, k = 10), type = "l", col = "blue")
lines(x, dhyper(x, m = 10, n = 20, k = 15), type = "l", col = "purple")
```

초기하분포의 모집단의 크기가 크면 이항분포와 유사한 결과를 보여줍니다.

```{r}
x <- seq(0, 10)

plot(x,  dhyper(x, m = 10, n = 10, k = 5), type = "l", col = "black")
lines(x, dhyper(x, m = 200, n = 200, k = 5), type = "l", col = "red")
lines(x, dbinom(x, size = 5, prob = 0.5), type = "p", col = "blue")
```

```{r}
# 0에서 3까지의 면적(핑크색)은? phyper(3, m = 10, n = 10, k = 5)
x <- seq(0, 10)
plot(x, dhyper(x, m = 10, n = 10, k = 5), type = "l", lwd = 2, col = "red")

u <- seq(0, 3)
v <- dhyper(u, m = 10, n = 10, k = 5)
polygon(c(0, u, 3), c(0, v, 0), col = "pink")
```

`phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE)` 함수는 초기하분포의 누적분포함수입니다. m과 n의 개체로 구성되어 있는 모집단에서 k개의 표본을 추출하는 초기하분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 10)

# 누적분포함수 시각화
plot(x, phyper(x, m = 10, n = 10, k = 5), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
phyper(3, m = 10, n = 10, k = 5)
```

`qhyper(p, m, n, k, lower.tail = TRUE, log.p = FALSE)` 함수는 초기하분포의 분위수를 구하는 함수입니다. m과 n의 개체로 구성되어 있는 모집단에서 k개의 표본을 추출하는 초기하분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qhyper(0.5, m = 10, n = 10, k = 5)  # p가 0.2~0.5까지는 2가 반환됨
phyper(2, m = 10, n = 10, k = 5)
```


### 기하 분포(geom)

기하분포는 베르누이 시행에서 처음 성공까지 시도한 횟수의 확률분포입니다. 예를 들면 연예를 시작한 남녀가 결혼할 확률이 5%라고 가정할 때 x번째 사귄 이성과 결혼하게 될 확률분포가 기하분포입니다. 

기하분포와 관련된 함수는 4가지가 있습니다.

* rgeom(n, prob)
* dgeom(x, prob, log = FALSE)
* pgeom(q, prob, lower.tail = TRUE, log.p = FALSE)
* qgeom(p, prob, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* prob : 각각의 시행에서 성공할 확률
* n : 난수를 발생할 개수
* x, q : 확률밀도함수나 누적분포함수를 계산할 값(벡터), 첫번째 성공까지 실패한 횟수
* p : 분위수를 계산할 확률값

`rgeom(n, prob)` 함수는 확률 prob의 기하분포에서 n개의 난수를 생성하여 반환합니다. rgeom 함수명은 난수를 의미하는 r과 기하분포를 의미하는 geom이 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rgeom(n = 10, prob = 0.5)
```

```{r}
set.seed(123)
x <- rgeom(n = 5000, prob = 0.5)
hist(x, main = "") 
```

`dhyper(x, m, n, k, log = FALSE)` 함수는 기하분포의 확률밀도함수입니다. 확률 prob의 기하분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10)

# 확률밀도함수 시각화
plot(x, dgeom(x, prob = 0.5), type = "l", col = "red")

# x가 2일때의 함수값?
dgeom(2, prob = 0.5)
```

```{r}
x <- seq(0, 10)

plot(x,  dgeom(x, prob = 0.7), type = "l", col = "red")
lines(x, dgeom(x, prob = 0.5), type = "l", col = "green")
lines(x, dgeom(x, prob = 0.2), type = "l", col = "blue")
```

```{r}
# 0에서 3까지의 면적(핑크색)은? pgeom(3, prob = 0.5)
x <- seq(0, 10)
plot(x, dgeom(x, prob = 0.5), type = "l", lwd = 2, col = "red")

u <- seq(0, 3)
v <- dgeom(u, prob = 0.5)
polygon(c(0, u, 3), c(0, v, 0), col = "pink")
```

`pgeom(q, prob, lower.tail = TRUE, log.p = FALSE)` 함수는 기하분포의 누적분포함수입니다. 확률 prob의 기하분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 10)

# 누적분포함수 시각화
plot(x, pgeom(x, prob = 0.5), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
pgeom(3, prob = 0.5)
```

`qgeom(p, prob, lower.tail = TRUE, log.p = FALSE)` 함수는 기하분포의 분위수를 구하는 함수입니다. 확률 prob의 기하분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qgeom(0.7, prob = 0.5)  # p가 0.6 ~ 0.7까지는 1이 반환됨
pgeom(1, prob = 0.5)
```


### 음이항 분포(nbinom)

음이항분포는 기하분포를 일반화시킨 것입니다. 기하분포가 베르누이 시행에서 처음 성공까지 시도한 횟수의 확률분포라면, 음이항분포는 베르누이 시행에서 k번째 성공까지 시도한 횟수의 확률분포입니다. 예를 들면 동전의 앞면이 다섯 번 나올 때까지 동전을 던져야 하는 횟수의 분포, 조립 라인에서 생산되는 제품에 대해 100개의 불량품이 생산되기 전까지 조립되는 단위의 수 분포 등을 들 수 있습니다.

음이항분포와 관련된 함수는 4가지가 있습니다.

* rnbinom(n, size, prob, mu)
* dnbinom(x, size, prob, mu, log = FALSE)
* pnbinom(q, size, prob, mu, lower.tail = TRUE, log.p = FALSE)
* qnbinom(p, size, prob, mu, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* size : 성공횟수
* prob : 성공확률
* mu : 음이항분포의 평균
* x, q : 확률밀도함수나 누적분포함수를 계산할 값(벡터)
* p : 분위수를 계산할 확률값

`rnbinom(n, size, prob, mu)` 함수는 성공횟수 size와 성공확률 prob로 구성된 음이항분포에서 n개의 난수를 생성하여 반환합니다. rnbinom 함수명은 난수를 의미하는 r과 음이항분포를 의미하는 nbinom가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rnbinom(n = 10, size = 5, prob = 0.5)
```

```{r}
set.seed(123)
x <- rnbinom(n = 5000, size = 5, prob = 0.5)
hist(x, main = "") 
```

`dnbinom(x, size, prob, mu, log = FALSE)` 함수는 음이항분포의 확률밀도함수입니다. 성공횟수 size와 성공확률 prob로 구성된 음이항분포에서인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10)

# 확률밀도함수 시각화
plot(x, dnbinom(x, size = 5, prob = 0.5), type = "l", col = "red")

# x가 2일때의 함수값?
dnbinom(2, size = 5, prob = 0.5)
```

```{r}
x <- seq(0, 10)

plot(x,  dnbinom(x, size = 1, prob = 0.5), type = "l", col = "red")
lines(x, dnbinom(x, size = 3, prob = 0.5), type = "l", col = "green")
lines(x, dnbinom(x, size = 5, prob = 0.5), type = "l", col = "blue")
lines(x, dnbinom(x, size = 7, prob = 0.5), type = "l", col = "purple")
```
```{r}
x <- seq(0, 10)

plot(x,  dnbinom(x, size = 5, prob = 0.7), type = "l", col = "red")
lines(x, dnbinom(x, size = 5, prob = 0.5), type = "l", col = "green")
lines(x, dnbinom(x, size = 5, prob = 0.3), type = "l", col = "blue")
lines(x, dnbinom(x, size = 5, prob = 0.1), type = "l", col = "purple")
```

```{r}
# 인자 prob 대신 평균 mu를 사용할 수 있음
# prob = size/(size+mu)   
x <- seq(0, 10)

plot(x,  dnbinom(x, size = 5, mu = 2), type = "l", col = "red")
lines(x, dnbinom(x, size = 5, mu = 3), type = "l", col = "green")
lines(x, dnbinom(x, size = 5, mu = 4), type = "l", col = "blue")
lines(x, dnbinom(x, size = 5, mu = 5), type = "l", col = "purple")
```


```{r}
# 0에서 3까지의 면적(핑크색)은? pnbinom(3, size = 5, prob = 0.5)
x <- seq(0, 10)
plot(x, dnbinom(x, size = 5, prob = 0.5), type = "l", lwd = 2, col = "red")

u <- seq(0, 3)
v <- dnbinom(u, size = 5, prob = 0.5)
polygon(c(0, u, 3), c(0, v, 0), col = "pink")
```

`phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE)` 함수는 음이항분포의 누적분포함수입니다. 성공횟수 size와 성공확률 prob로 구성된 음이항분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 10)

# 누적분포함수 시각화
plot(x, pnbinom(x, size = 5, prob = 0.5), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
pnbinom(3, size = 5, prob = 0.5)
```

`qnbinom(p, size, prob, mu, lower.tail = TRUE, log.p = FALSE)` 함수는 음이항분포의 분위수를 구하는 함수입니다. 성공횟수 size와 성공확률 prob로 구성된 음이항분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qnbinom(0.2, size = 5, prob = 0.5)  
pnbinom(2, size = 5, prob = 0.5)
```


### 포아송분포(pois)

포아송분포는 단위시간, 단위공간에 어떤 사건이 몇 번 발생할 것인가를 표현하는 확률분포입니다. 예를 들면 한 시간 동안 은행에 방문한 고객의 수, 한 시간 동안 사무실에 걸려온 전화의 수, 어떤 책 한 페이지에 존재하는 오타의 수 등에 대한 확률분포입니다. 포아송 분포는 프랑스의 수학자이자 물리학자인 시메옹 드니 푸아송(Siméon Denis Poisson, 1781 ~ 1840)이 정립한 분포입니다.

이항분포의 시행횟수가 매우 크고 발생확률이 매우 작으면 포아송분포와 유사해집니다. 반대로 포아송분포의 람다(lambda)가 매우 커지면 정규분포와 유사해집니다.

포아송분포의 모수인 lambda는 단위시간, 단위공간에서 어떤 사건이 발생한 평균횟수입니다.

포아송분포와 관련된 함수는 4가지가 있습니다.

* rpois(n, lambda)
* dpois(x, lambda, log = FALSE)
* ppois(q, lambda, lower.tail = TRUE, log.p = FALSE)
* qpois(p, lambda, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* lambda : 단위시간, 단위공간에서 어떤 사건이 발생한 평균횟수
* x, q : 확률밀도함수나 누적분포함수를 계산할 값(벡터)
* p : 분위수를 계산할 확률값

`rpois(n, lambda)` 함수는 모수 lambda인 포아송분포에서 n개의 난수를 생성하여 반환합니다. rpois 함수명은 난수를 의미하는 r과 포아송분포를 의미하는 pois가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rpois(n = 10, lambda = 5)
```

```{r}
set.seed(123)
x <- rpois(n = 5000, lambda = 5)
hist(x, main = "") 
```

`dpois(x, lambda, log = FALSE` 함수는 포아송분포의 확률밀도함수입니다. 모수 lambda인 포아송분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 10)

# 확률밀도함수 시각화
plot(x, dpois(x, lambda = 5), type = "l", col = "red")

# x가 2일때의 함수값?
dpois(2, lambda = 5)
```

```{r}
x <- seq(0, 20)

plot(x,  dpois(x, lambda = 1), type = "l", col = "red")
lines(x, dpois(x, lambda = 2), type = "l", col = "green")
lines(x, dpois(x, lambda = 5), type = "l", col = "blue")
lines(x, dpois(x, lambda = 10), type = "l", col = "purple")
```

```{r}
# 0에서 3까지의 면적(핑크색)은? ppois(3, lambda = 5)
x <- seq(0, 15)
plot(x, dpois(x, lambda = 5), type = "l", lwd = 2, col = "red")

u <- seq(0, 3)
v <- dpois(u, lambda = 5)
polygon(c(0, u, 3), c(0, v, 0), col = "pink")
```

`ppois(q, lambda, lower.tail = TRUE, log.p = FALSE)` 함수는 포아송분포의 누적분포함수입니다. 모수 lambda인 포아송분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 15)

# 누적분포함수 시각화
plot(x, ppois(x, lambda = 5), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
ppois(3, lambda = 5)
```

`qpois(p, lambda, lower.tail = TRUE, log.p = FALS` 함수는 포아송분포의 분위수를 구하는 함수입니다. 모수 lambda인 포아송분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qpois(0.265, lambda = 5) 
ppois(3, lambda = 5)
```


### 윌콕슨 순위합 분포(wilcox)

윌콕슨 순위합 통계량(Wilcoxon Rank Sum Statistic) 분포는 윌콕슨 순위합 검정에 주로 사용됩니다. 두 모집단의 중심 차이를 검정할 때 정규분포이면 t검정을 수행합니다. 그러나 정규분포가 아니면 비모수 검정을 수행하는데 대표적인 비모수검정으로 윌콕슨 순위합 검정과 윌콕슨 부호순위 검정이 있습니다. 윌콕슨 순위합 검정은 독립적인 두 모집단을 비교할 때, 윌콕슨 부호순위 검정은 동일한 집단의 사전과 사후를 비교할 때 주로 사용됩니다.

윌콕슨 순위합 통계량 분포와 관련된 함수는 4가지가 있습니다.

* rwilcox(nn, m, n)
* dwilcox(x, m, n, log = FALSE)
* pwilcox(q, m, n, lower.tail = TRUE, log.p = FALSE)
* qwilcox(p, m, n, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* m : 첫번째 표본의 개수
* n : 두번째 표본의 개수
* nn : 난수를 발생할 개수
* x, q : 확률밀도함수나 누적분포함수를 계산할 값(벡터)
* p : 분위수를 계산할 확률값

`rwilcox(nn, m, n)` 함수는 첫번째 표본 m개와 두번째 표본 n개로 구성되어 있는 윌콕슨 순위합 통계량 분포에서 nn개의 난수를 생성하여 반환합니다. rwilcox 함수명은 난수를 의미하는 r과 윌콕슨 순위합 통계량 분포를 의미하는 wilcox가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rwilcox(nn = 10, m = 30, n = 50)
```

```{r}
set.seed(123)
x <- rwilcox(nn = 5000, m = 30, n = 50)
hist(x, main = "") 
```

`dwilcox(x, m, n, log = FALSE)` 함수는 윌콕슨 순위합 통계량 분포의 확률밀도함수입니다. 첫번째 표본 m개와 두번째 표본 n개로 구성되어 있는 윌콕슨 순위합 통계량 분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 1000)

# 확률밀도함수 시각화
plot(x, dwilcox(x, m = 30, n = 30), type = "l", col = "red")

# x가 500일때의 함수값?
dwilcox(500, m = 30, n = 30)
```

```{r}
x <- seq(0, 1000)

plot(x,  dwilcox(x, m = 10, n = 30), type = "l", col = "red")
lines(x, dwilcox(x, m = 20, n = 30), type = "l", col = "green")
lines(x, dwilcox(x, m = 30, n = 30), type = "l", col = "blue")
lines(x, dwilcox(x, m = 40, n = 30), type = "l", col = "purple")
```

```{r}
x <- seq(0, 1000)

plot(x,  dwilcox(x, m = 30, n = 10), type = "l", col = "red")
lines(x, dwilcox(x, m = 30, n = 20), type = "l", col = "green")
lines(x, dwilcox(x, m = 30, n = 30), type = "l", col = "blue")
lines(x, dwilcox(x, m = 30, n = 40), type = "l", col = "purple")
```

```{r}
x <- seq(0, 1000)

plot(x,  dwilcox(x, m = 10, n = 10), type = "l", col = "red")
lines(x, dwilcox(x, m = 20, n = 20), type = "l", col = "green")
lines(x, dwilcox(x, m = 30, n = 30), type = "l", col = "blue")
lines(x, dwilcox(x, m = 40, n = 40), type = "l", col = "purple")
```


```{r}
# 0에서 3까지의 면적(핑크색)은? pwilcox(500, m = 30, n = 30)
x <- seq(0, 1000)
plot(x, dwilcox(x, m = 30, n = 30), type = "l", lwd = 2, col = "red")

u <- seq(0, 500)
v <- dwilcox(u, m = 30, n = 30)
polygon(c(0, u, 500), c(0, v, 0), col = "pink")
```

`pwilcox(q, m, n, lower.tail = TRUE, log.p = FALSE)` 함수는 윌콕슨 순위합 통계량 분포의 누적분포함수입니다. 첫번째 표본 m개와 두번째 표본 n개로 구성되어 있는 윌콕슨 순위합 통계량 분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 1000)

# 누적분포함수 시각화
plot(x, pwilcox(x, m = 30, n = 30), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
pwilcox(500, m = 30, n = 30)
```

`qwilcox(q, m, n, lower.tail = TRUE, log.p = FALSE)` 함수는 윌콕슨 순위합 통계량 분포의 분위수를 구하는 함수입니다. 첫번째 표본 m개와 두번째 표본 n개로 구성되어 있는 윌콕슨 순위합 통계량 분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qwilcox(0.7, m = 30, n = 30)  
pwilcox(486, m = 30, n = 30)
```


### 윌콕슨 부호순위 분포(signrank)

윌콕슨 부호순위 통계량(Wilcoxon Signed Rank Statistic) 분포는 윌콕슨 부호순위 검정에 주로 사용됩니다. 두 모집단의 중심 차이를 검정할 때 정규분포이면 t검정을 수행합니다. 그러나 정규분포가 아니면 비모수 검정을 수행하는데 대표적인 비모수검정으로 윌콕슨 순위합 검정과 윌콕슨 부호순위 검정이 있습니다. 윌콕슨 순위합 검정은 독립적인 두 모집단을 비교할 때, 윌콕슨 부호순위 검정은 동일한 집단의 사전과 사후를 비교할 때 주로 사용됩니다.

윌콕슨 부호순위 통계량 분포와 관련된 함수는 4가지가 있습니다.

* rsignrank(nn, n)
* dsignrank(x, n, log = FALSE)
* psignrank(q, n, lower.tail = TRUE, log.p = FALSE)
* qsignrank(p, n, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* n : 표본의 개수
* nn : 난수를 발생할 개수
* x, q : 확률밀도함수나 누적분포함수를 계산할 값(벡터)
* p : 분위수를 계산할 확률값

`rsignrank(nn, n)` 함수는 표본 n개로 구성되어 있는 윌콕슨 부호순위 통계량 분포에서 nn개의 난수를 생성하여 반환합니다. rsignrank 함수명은 난수를 의미하는 r과 윌콕슨 부호순위 통계량 분포를 의미하는 signrank가 결합되어진 것입니다.

```{r}
set.seed(123)
# 난수 10개 생성
rsignrank(nn = 10, n = 30)
```

```{r}
set.seed(123)
x <- rsignrank(nn = 5000, n = 30)
hist(x, main = "") 
```

`dsignrank(x, n, log = FALSE)` 함수는 윌콕슨 부호순위 통계량 분포의 확률밀도함수입니다. 표본 n개로 구성되어 있는 윌콕슨 부호순위 통계량 분포에서 인자 x의 함수값을 구해 반환합니다. 

```{r}
x <- seq(0, 500)

# 확률밀도함수 시각화
plot(x, dsignrank(x, n = 30), type = "l", col = "red")

# x가 200일때의 함수값?
dsignrank(200, n = 30)
```

```{r}
x <- seq(0, 1000)

plot(x,  dsignrank(x, n = 10), type = "l", col = "red")
lines(x, dsignrank(x, n = 20), type = "l", col = "green")
lines(x, dsignrank(x, n = 30), type = "l", col = "blue")
lines(x, dsignrank(x, n = 50), type = "l", col = "purple")
```

```{r}
# 0에서 3까지의 면적(핑크색)은? psignrank(300, n = 30)
x <- seq(0, 500)
plot(x, dsignrank(x, n = 30), type = "l", lwd = 2, col = "red")

u <- seq(0, 300)
v <- dsignrank(u, n = 30)
polygon(c(0, u, 300), c(0, v, 0), col = "pink")
```

`psignrank(q, n, lower.tail = TRUE, log.p = FALSE)` 함수는 윌콕슨 부호순위 통계량 분포의 누적분포함수입니다. 표본 n개로 구성되어 있는 윌콕슨 부호순위 통계량 분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(0, 500)

# 누적분포함수 시각화
plot(x, psignrank(x, n = 30), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
psignrank(300, n = 30)
```

`qsignrank(q, n, lower.tail = TRUE, log.p = FALSE)` 함수는 윌콕슨 부호순위 통계량 분포의 분위수를 구하는 함수입니다. 표본 n개로 구성되어 있는 윌콕슨 부호순위 통계량 분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qsignrank(0.7, n = 30)  
psignrank(258, n = 30)
```


### 스튜던트 범위 분포(tukey)


스튜던트 범위 분포(Studentized Range Distribution)는 3개 그룹간 평균의 차이를 알아보기 위해 분산분석을 수행하는데, 분산분석이후 구체적으로 개별 그룹간 차이가 있는지를 검정할 때 터키 검정(Tukey's test, Tukey's HSD)을 수행하게 됩니다. 이 터키검정에서 사용하는 확률분포가 스튜던트 범위 분포입니다.

스튜던트 범위 분포와 관련된 함수는 4가지가 있습니다.

* ptukey(q, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE)
* qtukey(p, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE)

위 함수에서 각 인자의 의미는 다음과 같습니다.

* nmeans : 범위 표본의 크기
* df : 자유도
* q : 확률밀도함수나 누적분포함수를 계산할 값(벡터)
* p : 분위수를 계산할 확률값

`ptukey(q, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 스튜던트 범위 분포 누적분포함수입니다. 범위 표본 nmeans개와 자유도 df로 구성되어 있는 스튜던트 범위 분포에서 인자 q의 누적분포함수값 즉 확률을 구해 반환합니다. 

```{r}
x <- seq(-1, 8, by = 0.1)

# 누적분포함수 시각화
plot(x, ptukey(x, nmeans = 6, df = 5), type = "l", col = "red")

# q가 3일때의 누적분포함수값은? 즉 확률은?
ptukey(3, nmeans = 6, df = 5)
```

`qtukey(p, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE)` 함수는 스튜던트 범위 분포의 분위수를 구하는 함수입니다. 범위 표본 nmeans개와 자유도 df로 구성되어 있는 스튜던트 범위 분포에서 확률이 인자 p일 때의 분위수 값을 구해 반환합니다. 

```{r}
qtukey(0.7, nmeans = 6, df = 5)
ptukey(3.4149, nmeans = 6, df = 5)
```

### mean() 

`mmean(x, trim = 0, na.rm = FALSE, ...)` 함수는 데이터 x의 산술평균을 반환합니다. 

* x : 숫자 또는 논리 벡터, 날짜 시간
* trim : 정렬된 벡터에서 양 극단을 제거(0 ~ 0.5)
* na.rm : TRUE이면 결측치(missing value) 제거

```{r}
x <- c(0:10, 50)
mean(x)
mean(x, trim = 0.1)
```

```{r}
x <- c(0:10, NA)
mean(x)
mean(x, na.rm = TRUE)
```

### weighted.mean() 

`weighted.mean(x, w, ...)` 함수는 가중치 w를 적용한 데이터 x의 산술평균을 반환합니다. 

* x : 숫자 또는 논리 벡터, 날짜 시간
* w : 가중치
* na.rm : TRUE이면 결측치(missing value) 제거

```{r}
x <- c(3.7, 3.3, 3.5, 2.8)
wt <- c(5, 5, 4, 1)/15
weighted.mean(x, w = wt)
```
```{r}
x <- c(9, 5, 2, 7, 3, 6, 4, 5, NA)
wt <- c(2, 3, 1, 5, 7, 1, 3, 7, 3)  
weighted.mean(x, w = wt, na.rm = TRUE)
```

### median() 

`median(x, na.rm = FALSE, ...)` 함수는 데이터 x의 중위수를 반환합니다.

* x : 숫자 또는 논리 벡터, 날짜 시간
* na.rm : TRUE이면 결측치(missing value) 제거

```{r}
median(c(1, 2, 3, 4))       # 짝수개일때
median(c(1, 2, 3, 4, 5))    # 홀수개일때
```

### var()  

`var(x, y = NULL, na.rm = FALSE, use)` 함수는 데이터 x의 분산을 반환합니다. 

* x : 숫자 벡터, 행렬, 데이터프레임
* y : NULL이 기본값, x와 대응되는 숫자 벡터, 행렬, 데이터프레임
* na.rm : TRUE이면 결측치(missing value) 제거
* use : 결측값 처리 방법
   * "everything" : 결측값이 있을 경우 NA로 계산 결과 제시 (기본값)
   * "all.obs" : 결측값이 있을 경우 오류 발생
   * "complete.obs" : 결측값이 있는 행은 모두 제거된 상태에서 계산
   * "pairwise.complete.obs" : 짝이 되는 변수들만을 대상으로 결측값이 있는 행 제거

```{r}
var(1:10)
var(c(1:10, NA), na.rm = TRUE)
var(c(1:10, NA), use = "complete.obs")
var(c(1:10, NA), c(5:15), use = "complete.obs")
```

### sd() 

`sd(x, na.rm = FALSE)` 함수는 x의 표준편차를 반환합니다.

* x : 숫자 벡터
* na.rm : TRUE이면 결측치(missing value) 제거

```{r}
sd(1:10)
```

### cov() 

`cov(x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman"))` 함수는 데이터 x와 y의 공분산을 반환합니다.

공분산은 2개의 확률변수의 상관정도를 나타내는 값입니다. 만약 2개의 변수 중 하나의 값이 상승하는 경향을 보일 때, 다른 값도 상승하는 경향의 상관관계에 있다면 공분산의 값은 양수가 됩니다. 반대로 2개의 변수 중 하나의 값이 상승하는 경향을 보일 때, 다른 값이 하강하는 경향을 보인다면 공분산은 음수가 됩니다.

* x : 숫자 벡터, 행렬, 데이터프레임
* y : NULL이 기본값, x와 대응되는 숫자 벡터, 행렬, 데이터프레임
* na.rm : TRUE이면 결측치(missing value) 제거
* use : 결측값 처리 방법
   * "everything" : 결측값이 있을 경우 NA로 계산 결과 제시 (기본값)
   * "all.obs" : 결측값이 있을 경우 오류 발생
   * "complete.obs" : 결측값이 있는 행은 모두 제거된 상태에서 계산
   * "pairwise.complete.obs" : 짝이 되는 변수들만을 대상으로 결측값이 있는 행 제거
* method : 상관계수 계산방법. "pearson"(기본값), "kendall", "spearman"

```{r}
str(iris)
plot(iris$Sepal.Length, iris$Petal.Length)
cov(iris$Sepal.Length, iris$Petal.Length, method = "pearson")
```


### cor() 

`cor(x, y = NULL, use = "everything", method = c("pearson", "kendall", "spearman"))` 함수는 데이터 x와 y의 상관계수를 반환합니다.

상관계수는 표준화된 공분산입니다.

```{r}
plot(iris$Sepal.Length, iris$Petal.Length)
cor(iris$Sepal.Length, iris$Petal.Length, method = "pearson")
```

### max and min

* max(..., na.rm = FALSE) : 최대값 반환
* min(..., na.rm = FALSE) : 최소값 반환
* pmax(..., na.rm = FALSE) : 두 벡터 사이에 상응하는 원소들 중 큰 값 반환
* pmin(..., na.rm = FALSE) : 두 벡터 사이에 상응하는 원소들 중 작은 값 반환
* pmax.int(..., na.rm = FALSE)
* pmin.int(..., na.rm = FALSE)

```{r}
x1 <- c(2, 8, 3, 4, 1, 5)
x2 <- c(0, 7, 5, 5, 6, 1) 

max(x1)
min(x2)
max(x1, x2)

pmax(x1, x2)
pmin(x1, x2)
```

```{r}
x1 <- c(2, 8, NA, 4, 1, 5)
x2 <- c(NA, 7, 5, 5, 6, 1) 
x3 <- c(3, 8, 9, 6, 7, 2)

max(x1)   # NA 때문에 올바른 결과가 나오지 않음
max(x1, na.rm = TRUE)

pmin(x1, x2)
pmin(x1, x2, na.rm = TRUE)   # NA 대신 상응하는 값이 선택됨

pmax(x1, x2, x3, na.rm = TRUE)
```

### range()

`range(..., na.rm = FALSE, finite = FALSE)` 함수는 데이터 벡터의 최소값과 최대값을 반환합니다.

* na.rm : TRUE이면 결측치(missing value) 제거
* finite : TRUE이면 Inf(무한) 제거

```{r}
x <- c(NA, 1:3, -1:1/0); x
range(x)
range(x, na.rm = TRUE)
range(x, finite = TRUE)
```


### quantile() 

`quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type = 7, ...)` 함수는 데이터 x의 사분위수를 반환합니다. 

* x : 사분위수를 구할 숫자 벡터
* probs : 0과 1사이의 확률 벡터(기본값은 0, 0.25, 0.5, 0.75, 1)
* na.rm : TRUE이면 결측치(missing value) 제거
* type : 분위수 계산방법 (기본값은 7), type 1~3 불연속변수, type 4~7 연속변수

```{r}
# 기본값은 4분위수(최소값, 1/4, 2/4, 3/4, 최대값)
# type의 기본값은 7
x <- c(11, 22, 33, 44, 55, 66, 77, 88)
quantile(x)
quantile(x, probs=c(0.05, 0.1, 0.9, 0.95))
```


### IQR()

`IQR(x, na.rm = FALSE, type = 7)` 함수는 데이터 x의 사분범위를 반환합니다. 사분범위는 3사분위수(Q3) - 1사분위수(Q1)로서 중앙 50%의 데이터들이 흩어진 정도를 의미합니다. IQR(x) = quantile(x, 3/4) - quantile(x, 1/4)

* x : 사분범위를 구할 숫자 벡터
* na.rm : TRUE이면 결측치(missing value) 제거
* type : 분위수 계산방법 (기본값은 7), type 1~3 불연속변수, type 4~7 연속변수

```{r}
x <- c(NA, 1:12, -1:1/0); x
IQR(x, na.rm = TRUE)
```

### fivenum()

`fivenum(x, na.rm = TRUE)` 함수는 데이터 x의 다섯 수치 요약을 반환합니다. 다섯 수치 요약은 테이터를 최소값, 제1사분위수, 중앙값, 제3사분위수, 최대값으로 요약합니다. summary 함수는 여기에 평균이 추가된 것입니다.

```{r}
fivenum(1:11)
summary(1:11)
```

데이터가 짝수일 때는 다르게 나옴(제1사분위수, 제3사분위수가 다름)
summary()는 quantile()의 복잡한 계산 방식으로 분위수를 구하지만, fivenum()은 중앙값 찾기 방식으로 분위수를 구합니다.

```{r}
fivenum(1:12)
summary(1:12)
quantile(1:12, 1/4)
```

### mad

`mad(x, center = median(x), constant = 1.4826, na.rm = FALSE, low = FALSE, high = FALSE)` 함수는 Median Absolute Deviation의 약자로 데이터 x의 중위수 절대 편차를 반환합니다. 계산방식은 각 데이터에서 중위수를 뺀 값을 절대값으로 바꾸고 이 중에서 중위수를 구하는 것입니다. MAD는 표준편차에 비해 이상치의 영향을 적게 받는 것이 특징입니다.

* center : 중심값 (기본값은 median(x))
* constant : scaling factor, 정규화 상수 (기본값은 1.4826)
* na.rm : TRUE이면 결측치(missing value) 제거
* low : TRUE이면 표본이 짝수일 때 2개의 중앙값 중 작은 것을 선택
* high : TRUE이면 표본이 짝수일 때 2개의 중앙값 중 큰 것을 선택

```{r}
x <- 1:9
mad(x)

# mad() 와 동일
median(abs(x - median(x))) * 1.4826
```

### rank() 

`rank(x, na.last = TRUE, ties.method = c("average", "first", "last", "random", "max", "min"))` 함수는 벡터 x에서 순위를 반환합니다. 

* x : 숫자, 문자, 논리 벡터
* na.last : NA 처리 방법
   * TRUE : NA를 마지막 번째 순위로 매김(기본값)
   * FALSE : NA를 첫 번째 순위로 매김
   * NA : NA를 제거
   * keep : NA를 그대로 나타냄
* ties.method : 동점 처리 방법
   * average : 각 순위의 평균으로 통일 (기본값)
   * first : 처음 오는 순서대로 1순위 (처음으로 발견된 데이터 우선) 
   * last : 마지막 데이터에 1순위 (마지막에 발견된 데이터 우선)
   * random : 순서 상관없이 랜덤
   * max : 동률 순위 중 가장 높은 값 출력 
   * min : 동률 순위 중 가장 낮은 값 출력

```{r}
# 순위대로 정렬하는 것이 아니라 순위값(순위색인)만 출력
x <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)
names(x) <- letters[1:11]; x
rank(x)

# 동점 min 방식 (일상에서 가장 많이 사용)
rank(x, ties.method = "min")
```
NA처리는 na.last 옵션에 어떤 값을 넣느냐에 따라 달라집니다.

```{r}
x <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, NA); x
rank(x, na.last = FALSE)  # NA가 1위
rank(x, na.last = NA)     # NA 제거
```

### sort()

`sort(x, decreasing = FALSE, na.last = NA, ...)` 함수는 데이터 x를 정렬한 결과를 반환합니다.

* x : 숫자, 문자, 논리 벡터
* decreasing : 기본은 오름차순, TRUE이면 내림차순
* na.last : NA 처리 방법
   * TRUE : NA를 마지막 번째 순위로 매김(기본값)
   * FALSE : NA를 첫 번째 순위로 매김
   * NA : NA를 제거
   * keep : NA를 그대로 나타냄

```{r}
x <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)
sort(x)
sort(x, decreasing = TRUE)
```

### order()

`order(..., na.last = TRUE, decreasing = FALSE, method = c("auto", "shell", "radix"))` 함수는 데이터 x를 정렬하기 위해 필요한 위치번호가 반환됩니다. 정렬하였을 때 원래 벡터에서 몇 번째 위치에 있었는지를 알려줍니다. 예제를 보면서 이해하는 것이 빠릅니다.

* ... : 숫자, 문자, 논리 벡터
* na.last : NA 처리 방법
   * TRUE : NA를 마지막 번째 순위로 매김(기본값)
   * FALSE : NA를 첫 번째 순위로 매김
   * NA : NA를 제거
   * keep : NA를 그대로 나타냄
* decreasing : 기본은 오름차순, TRUE이면 내림차순
* method : 정렬 알고리즘
   * auto : 자동(짧은 숫자 벡터들은 radix, 그렇지 않으면 shell)
   * shell : 쉘 정렬 알고리즘
   * radix : 기수 정렬 알고리즘

```{r}
x <- c(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5)
order(x)
# 원래 2번째 자리에 있는 숫자 1이 첫번째 자리이고, 
# 원래 4번째 자리에 있는 숫자 1이 두번째 자리이고, ...
```

### lm()

`lm(formula, data, subset, weights, na.action, method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...)` 함수는 선형모델적합을 위한 함수로써 주로 회귀분석에 사용됩니다.

* formula : 적용할 모델 (예: y ~ x1 + x2)
* data : 모델에 포함된 변수가 있는 데이터프레임(옵션)
* subset : 선형모델적합 과정에 사용될 데이터의 서브 세트(옵션)
* weights : 선형모델적합 과정에 사용될 가중치(옵션)
* na.action : 결측치 처리(기본값은 na.omit)

인자 formula는 여러가지 기호를 사용하여 모델을 표현합니다. `~`, `+`, `.`, `-`, `:`, `*` 기호에 대해 알아보겠습니다.

`~` 기호는 종속변수와 독립변수를 구분짓는 기호입니다. `종속변수 ~ 독립변수`의 형태로 사용합니다. 아래 예제에서 `mpg ~ wt`는 종속변수 mpg와 독립변수 wt로 구성된 모델을 의미합니다. lm 함수의 결과를 자세히 보려면 summary함수를 이용하는 것이 좋습니다. lm함수를 통해 아래 그래프의 빨간 회귀선이 도출되었다고 볼 수 있습니다.

```{r}
str(mtcars)
plot(mtcars$wt, mtcars$mpg)
fit <- lm(mpg ~ wt, data = mtcars)
summary(fit)
abline(fit, col = "red")
```

`+` 기호는 여러개의 독립변수 즉 다중회귀분석을 수행할 때 사용합니다. 독립변수들은 + 기호를 통해 연결됩니다. `plot(fit)`은 회귀모형을 진단하기 위한 plot을 그려줍니다. 이 그래프들을 통해 회귀모형의 선형성, 정규성, 등분산성 가정과 이상치들을 검토할 수 있습니다.

```{r}
plot(mpg ~ wt + cyl, data = mtcars)
fit <- lm(mpg ~ wt + cyl, data = mtcars)
summary(fit)
plot(fit)
```
`.` 기호는 "전부"의 의미를 갖는 기호입니다. 종속변수를 제외한 나머지 변수를 모두 독립변수로 사용할 경우 `종속변수 ~ .`의 형태로 모델을 만듭니다.

```{r}
fit <- lm(mpg ~ ., data = mtcars)
summary(fit)
```
`-` 기호는 `+` 기호의 반대입니다. 독립변수를 제외할 때 사용합니다. `.` 기호로 모든 변수를 독립변수로 지정하였지만 일부 변수를 제외할 때 사용합니다.

```{r}
fit <- lm(mpg ~ . - cyl, data = mtcars)
summary(fit)
```
만일 절편(Intercept)이 0인 모델로 만들고 싶을 경우 절편항을 제외할 때 `- 1` 기호를 삽입니다.

```{r}
# cyl 독립변수 제외, 절편은 0인 회귀모델
fit <- lm(mpg ~ . - cyl - 1, data = mtcars)
summary(fit)
```
`:`와 `*` 기호는 상호작용항을 부여할 때 사용합니다. `:` 기호는 두 변수의 상호작용을 직접 지정해주는 기호이고, `*` 기호는 자동으로 각 개별항과 모든 조합의 상호작용항을 만들어주는 기호입니다. 예를 들면 `x1 * x2 * x3`는 `x1 + x2 + x3 + x1:x2 + x1:x3 + x3:x3 + x1:x2:x3`를 만들어 줍니다.

```{r}
# `:` 기호를 사용할 때
fit <- lm(mpg ~ wt + cyl + wt:cyl, data = mtcars)
summary(fit)
```

```{r}
# `*` 기호를 사용할 때
fit <- lm(mpg ~ wt * cyl * gear, data = mtcars)
summary(fit)
```
모델의 formula에서 `I()` 함수는 연산자를 해석하여 계산할 수 있도록 도와줍니다. formula에서는 연산자들이 약손된 의미로만 사용됩니다. 예를 들면 + 기호는 독립변수들을 추가하는 의미로 사용되지 더하기의 의미로 사용되지 않습니다. 그러나 만일 더하기로 사용하고 싶다면 I() 함수를 사용하여야 합니다. 아래 예제에서 `I(sqrt(wt) + cyl)`는 wt와 cyl 변수를 계산하여 하나의 변수로 만든 것임을 의미합니다. 

```{r}
fit <- lm(mpg ~ I(sqrt(wt) + cyl), data = mtcars)
summary(fit)
```

### step()

`step(object, scope, scale = 0, direction = c("both", "backward", "forward"), trace = 1, keep = NULL, steps = 1000, k = 2, ...)` 함수는 단계적 알고리즘을 사용하여 AIC를 기준으로 모델을 선택하는 함수입니다. 

* object : 탐색할 모델 지정
* scope : 단계별 선택시 모델의 범위(하한과 상한)를 지정
* direction : both(기본값), backward, forward 방식 선택


다중회귀분석에 독립변수를 선택하는 방법으로 단계적 변수 선택방법이 있습니다. 

* 전진선택법(forward selection) : 절편만 있는 모델에서 기준 통계치를 가장 많이 개선시키는 변수를 차례로 추가하는 방법입니다. 
* 변수 소거법(backward elimination) : 모든 변수가 포함된 모델에서 기준 통계치에 가장 도움이 되지 않는 변수를 하나씩 제거하는 방법입니다.
* 단계적 방법(stepwise selection) : 모든 변수가 포함된 모델에서 출발하여 기준 통계치에 가장 도움이 되지 않는 변수를 삭제하거나, 모델에서 빠져 있는 변수 중에서 기준 통계치를 가장 개선시키는 변수를 추가합니다. 그리고 이러한 변수의 추가 또는 삭제를 반복하거나 반대로 절편만 포함된 모델에서 출발해 변수의 추가, 삭제를 반복할 수도 있습니다.

AIC는 Akaike’s Information Criterion의 약자로서 회귀모델의 상대적 품질을 추정하는 방식입니다. AIC와 유사한 것으로 BIC(Bayesian Infirmation Criterion)가 있습니다.

단계적 변수 선택방법으로 적절한 독립변수를 탐색하는 것은 과신하지 말아야 합니다. 회귀분석에서 적절한 독립변수는 우선 이론이나 논리적 설명을 바탕으로 시작해야 합니다. 가능한 모든 변수를 대상으로 변수선택법만으로 모델을 도출하는 것은 무의미한 결과를 도출하는 경우가 많습니다. 변수선택법은 하나의 참고로 사용하는 것이 좋습니다.


전진선택법(forward selection)은 먼저 상수항(절편)만 있는 회귀모형을 만들고 여기에 독립변수들을 하나씩 추가하는 과정을 거칩니다.

```{r}
# 절편(Intercept)만 있는 모델은 `1` 기호만 삽입
fit <- lm(mpg ~ 1, data = mtcars)
summary(fit)

# step 함수를 이용하여 'forward' 방식으로 변수 선택
fit_fwd <- step(fit, direction = "forward",
                scope = (mpg ~ cyl + disp + hp + drat + wt + vs + am))
summary(fit_fwd)
```

변수 소거법(backward elimination)은 먼저 변수를 포함시킨 회귀모형을 만들고 여기에 독립변수들을 하나씩 제거하는 과정을 거칩니다.

```{r}
fit <- lm(mpg ~ cyl + disp + hp + drat + wt + vs + am, data = mtcars)
summary(fit)

# step 함수를 이용하여 'backward' 방식으로 변수 선택
fit_bwd <- step(fit, direction = "backward",
                scope = (mpg ~ cyl + disp + hp + drat + wt + vs + am))
summary(fit_bwd)
```

단계적 방법(stepwise selection)은 먼저 상수항(절편)만 있는 회귀모형을 만들고여기에 독립변수들을 하나씩 제거하거나 추가하는 과정을 거칩니다.

```{r}
fit <- lm(mpg ~ 1, data = mtcars)
summary(fit)

# step 함수를 이용하여 'both' 방식으로 변수 선택
fit_both <- step(fit, direction = "both",
                scope = (mpg ~ cyl + disp + hp + drat + wt + vs + am))
summary(fit_both)
```

### predict() 

`predict(object, ...)` 함수는 예측값을 구하는 함수입니다. lm()과 같은 함수들을 이용해 만들어진 모델에 새로운 데이터를 적용하여 예측값을 구합니다. predict()는 인자로 주어진 모델에 따라 내부적으로 predict.lm()과 같은 함수들을 호출하여 예측을 합니다. 내부적으로 호출되는 함수들은 다음과 같습니다.

* predict.glm 일반화 선형모형
* predict.lm  선형회귀
* predict.loess  국소 가중 산점도 플롯 평활화
* predict.nls  비선형회귀
* predict.poly  다항회귀
* predict.princomp  주성분분석
* predict.smooth.spline  평활스플라인
* predict.ar  자기회귀
* predict.Arima 아리마
* predict.arima0  아리마
* predict.HoltWinters  홀트-윈터스 계절기법
* predict.StructTS 시계열 구조모형

`predict.lm()` 함수 기준으로 `predict(object, newdata, se.fit = FALSE, scale = NULL, df = Inf, interval = c("none", "confidence", "prediction"), level = 0.95, type = c("response", "terms"), terms = NULL, na.action = na.pass, pred.var = res.var/weights, weights = 1, ...)` 함수에 들어가는 주요 인자를 정리하면 다음과 같습니다.

* object : 예측에 사용할 회귀분석 결과식(model)
* newdata : 예측에 사용할 x값(data frame 형식)
* interval : 지정된 x값에 대한 y의 confidence interval 또는 prediction interval을 출력. 출력할 interval을 지정하지 않고 비워둘시 interval을 출력하지 않음

```{r}
fit <- lm(mpg ~ wt + cyl, data = mtcars)
summary(fit)

# 예측
predict(fit, newdata = data.frame(wt = 2.595, cyl = 6))

# 예측의 신뢰구간 추가
predict(fit, newdata = data.frame(wt = 2.595, cyl = 6), interval = "confidence")

# 예측의 오차구간 추가(신뢰구간 보다 폭이 커짐)
predict(fit, newdata = data.frame(wt = 2.595, cyl = 6), interval = "prediction")
```

### glm()

`glm(formula, family = gaussian, data, weights, subset, na.action, start = NULL, etastart, mustart, offset, control = list(...), model = TRUE, method = "glm.fit", x = FALSE, y = TRUE, singular.ok = TRUE, contrasts = NULL, ...)` 함수는 일반화 선형모형 적합을 위한 함수입니다.

선형회귀모형은 종속변수가 정규분포된 양적변수를 가정하고 있습니다. 그러나 종속변수가 정규분포가 아니거나 질적변수(범주형 변수)인 경우에는 선형회귀모형을 적용할 수 없습니다. 대신 일반화 선형모형(Generalized Linear Model)을 적용하게 됩니다.

glm() 함수에 들어가는 인자는 lm() 함수와 유사합니다. 다만 family라는 인자가 다릅니다. family에 들어가는 값은 종속변수의 확률분포에 따라 다릅니다.

* family 종속변수의 확률분포
   * gaussian : 정규분포
   * bionomial : 이항분포(로지스틱 회귀분석)
   * poisson : 포아송 분포
   * inverse.gaussian : 역정규분포
   * gamma : 감마분포
   * quasi :  응답분포가 확실하지 않은 때

로지스틱 회귀분석은 종속변수가 이항분포(0/1, 성공/실패) 경우에 사용됩니다.

```{r}
str(mtcars)

# am : 변속기(0=오토, 1=수동), hp : 마력, wt : 무게
fit <- glm(am ~ hp + wt, data = mtcars, family = binomial)
summary(fit)

# 예측
# predict() 함수의 인수 type : 예측 결과의 유형 지정
# type = "link" 는 log-odds 값 출력, type = "response"는 확률 $p$ 값 출력
newdata <- data.frame(hp = c(120, 150), wt = c(2.8, 3.8))
predict(fit, newdata = newdata, type = "response")
```

### loess() 


### nls() 

nls(formula, data, start, control, algorithm,
    trace, subset, weights, na.action, model,
    lower, upper, ...)


### poly()


### princomp()


### ar()

### arima()


### holtwinter()

### approx(x,y=) 


### spline(x,y=) 








### df.residual(fit) 

### coef(fit) 


### residuals(fit) 
### deviance(fit) 
### fitted(fit) 
### logLik(fit)
### AIC(fit) 
### aov(formula) 
### anova(fit,...) 
### density(x) 

### binom.test()
### prop.test()

comparing two variances (Fisher's F test: var.test())
comparing two sample means with normal errors (Student's t test: t.test())
comparing two means with non-normal errors (Wilcoxon's rank test: wilcox.test())
comparing two proportions (the binomial test: prop.test())
correlating two variables (Pearson's or Spearman's rank correlation: cor.test())
testing for independence of two variables in a contingency table (chi-squared, chisq.test(), or Fisher's exact test: fisher.test()).

ks.test(two$x, two$y)

The binomial test is a test of the statistical significance of deviations from a theoretically expected distribution of observations into two categories: e.g., does our count of heads:tails differ from a 1:1 ratio, when tossing a coin

### lgamma, gamma, digamma, trigamma


### optim() 

`optim(par, fn, gr = NULL, ..., method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), lower = -Inf, upper = Inf, control = list(), hessian = FALSE)` 함수는 

### optimize

### constroptim

### nlm(f,p) 

### nlminb

 
## R 날짜와 시간 함수

seq()
difftime()
as.Date(s) and as.POSIXct(s)
format(dt)

%a, %A Abbreviated and full weekday name.
%b, %B Abbreviated and full month name.
%d Day of the month (01–31).
%H Hours (00–23).
%I Hours (01–12).
%j Day of year (001–366).
%m Month (01–12).
%M Minute (00–59).
%p AM/PM indicator.
%S Second as decimal number (00–61).
%U Week (00–53); the first Sunday as day 1 of week 1.
%w Weekday (0–6, Sunday is 0).
%W Week (00–53); the first Monday as day 1 of week 1.
%y Year without century (00–99). Don’t use.
%Y Year with century.
%z (output only.) Offset from Greenwich; -0800 is 8 hours west of.
%Z (output only.) Time zone as a character string (empty if not available).

## R 객체 함수

### 객체 클라스와 타입 조사
typeof()
str()
class(x) 
unclass(x) 
attr(x,which) 
attributes(obj)

### 데이터 차원 조사
dim
nrow
ncol

### 객체정보 함수
length(x) 
dimnames(x) 


is.na(x), is.null(x), is.array(x), is.data.frame(x),
is.numeric(x), is.complex(x), is.character(x),


### 객체변환 함수
as.array(x), as.data.frame(x), as.numeric(x),
as.logical(x), as.complex(x), as.character(x),





## R 문자열 함수

paste(...) 
substr(x,start,stop) 
strsplit(x,split) 
grep(pattern,x) 
gsub(pattern,replacement,x) 
tolower(x) 
toupper(x) 
match(x,table) 
pmatch(x,table) 
nchar(x) 

### 정규표현식




## R 데이터 관리 함수

c(...) 
seq(from,to) 
seq(along=x) 
rep(x,times) 
rep(c(1,2,3),each=2) 

all.equal
identical

data.frame(...)
list(...) 
array(x,dim=) 
matrix(x,nrow=,ncol=) 
factor(x,levels=) 
gl(n,k,length=n*k,labels=1:n) 
expand.grid() 
rbind(...) 
cbind(...) 

Data selection and manipulation
which.max(x) 
which.min(x) 
rev(x) 
sort(x) rev(sort(x))
cut(x,breaks) 
match(x, y) 
which(x == a) 
choose(n, k) 
na.omit(x) 
na.fail(x) 
unique(x) 
table(x) 
subset(x, ...) 
sample(x, size) 
prop.table(x,margin=) 

by(data,INDEX,FUN) 
merge(a,b) 
xtabs(a b,data=x) 
aggregate(x,by,FUN) 
stack(x, ...) 
unstack(x, ...) 
reshape(x, ...) 


## R 입출력 함수

load() 
data(x) 
library(x) 
read.table(file) 
read.csv("filename",header=TRUE) 
read.delim("filename",header=TRUE) 
read.fwf(file,widths,header=FALSE,sep="",as.is=FALSE) 
save.image(file) 
cat(..., file="", sep=" ") 
print(a, ...) 
format(x,...) 
write.table(x,file="",row.names=TRUE,col.names=TRUE, sep=" ")
sink(file) 


## R 시스템 함수


 


## R 사용자 정의 함수



